"use strict";
const electron = require("electron");
const Store = require("electron-store");
const path = require("path");
const fs = require("fs");
const Database = require("better-sqlite3-multiple-ciphers");
const require$$2$1 = require("events");
const require$$2$2 = require("string_decoder");
const require$$3 = require("buffer");
const require$$1$3 = require("util");
const require$$0$2 = require("stream");
const icon = path.join(__dirname, "./chunks/icon-4363016c.png");
const defaultOpts$3 = {
  xml: false,
  decodeEntities: true
};
const xmlModeDefault = {
  _useHtmlParser2: true,
  xmlMode: true
};
function flatten$2(options2) {
  return (options2 === null || options2 === void 0 ? void 0 : options2.xml) ? typeof options2.xml === "boolean" ? xmlModeDefault : { ...xmlModeDefault, ...options2.xml } : options2 !== null && options2 !== void 0 ? options2 : void 0;
}
var ElementType$4;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType$4 || (ElementType$4 = {}));
function isTag$7(elem) {
  return elem.type === ElementType$4.Tag || elem.type === ElementType$4.Script || elem.type === ElementType$4.Style;
}
const Root = ElementType$4.Root;
const Text$1 = ElementType$4.Text;
const Directive = ElementType$4.Directive;
const Comment$1 = ElementType$4.Comment;
const Script = ElementType$4.Script;
const Style = ElementType$4.Style;
const Tag = ElementType$4.Tag;
const CDATA$1 = ElementType$4.CDATA;
const Doctype = ElementType$4.Doctype;
let Node$1 = class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent2) {
    this.parent = parent2;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev2) {
    this.prev = prev2;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next2) {
    this.next = next2;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
};
class DataNode extends Node$1 {
  /**
   * @param data The content of the data node
   */
  constructor(data2) {
    super();
    this.data = data2;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(data2) {
    this.data = data2;
  }
}
class Text extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType$4.Text;
  }
  get nodeType() {
    return 3;
  }
}
class Comment extends DataNode {
  constructor() {
    super(...arguments);
    this.type = ElementType$4.Comment;
  }
  get nodeType() {
    return 8;
  }
}
class ProcessingInstruction extends DataNode {
  constructor(name2, data2) {
    super(data2);
    this.name = name2;
    this.type = ElementType$4.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class NodeWithChildren extends Node$1 {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(children2) {
    super();
    this.children = children2;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var _a2;
    return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(children2) {
    this.children = children2;
  }
}
class CDATA extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType$4.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
class Document extends NodeWithChildren {
  constructor() {
    super(...arguments);
    this.type = ElementType$4.Root;
  }
  get nodeType() {
    return 9;
  }
}
let Element$1 = class Element extends NodeWithChildren {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(name2, attribs, children2 = [], type = name2 === "script" ? ElementType$4.Script : name2 === "style" ? ElementType$4.Style : ElementType$4.Tag) {
    super(children2);
    this.name = name2;
    this.attribs = attribs;
    this.type = type;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(name2) {
    this.name = name2;
  }
  get attributes() {
    return Object.keys(this.attribs).map((name2) => {
      var _a2, _b;
      return {
        name: name2,
        value: this.attribs[name2],
        namespace: (_a2 = this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name2],
        prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name2]
      };
    });
  }
};
function isTag$6(node2) {
  return isTag$7(node2);
}
function isCDATA(node2) {
  return node2.type === ElementType$4.CDATA;
}
function isText(node2) {
  return node2.type === ElementType$4.Text;
}
function isComment(node2) {
  return node2.type === ElementType$4.Comment;
}
function isDirective(node2) {
  return node2.type === ElementType$4.Directive;
}
function isDocument(node2) {
  return node2.type === ElementType$4.Root;
}
function hasChildren(node2) {
  return Object.prototype.hasOwnProperty.call(node2, "children");
}
function cloneNode(node2, recursive = false) {
  let result;
  if (isText(node2)) {
    result = new Text(node2.data);
  } else if (isComment(node2)) {
    result = new Comment(node2.data);
  } else if (isTag$6(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new Element$1(node2.name, { ...node2.attribs }, children2);
    children2.forEach((child2) => child2.parent = clone2);
    if (node2.namespace != null) {
      clone2.namespace = node2.namespace;
    }
    if (node2["x-attribsNamespace"]) {
      clone2["x-attribsNamespace"] = { ...node2["x-attribsNamespace"] };
    }
    if (node2["x-attribsPrefix"]) {
      clone2["x-attribsPrefix"] = { ...node2["x-attribsPrefix"] };
    }
    result = clone2;
  } else if (isCDATA(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new CDATA(children2);
    children2.forEach((child2) => child2.parent = clone2);
    result = clone2;
  } else if (isDocument(node2)) {
    const children2 = recursive ? cloneChildren(node2.children) : [];
    const clone2 = new Document(children2);
    children2.forEach((child2) => child2.parent = clone2);
    if (node2["x-mode"]) {
      clone2["x-mode"] = node2["x-mode"];
    }
    result = clone2;
  } else if (isDirective(node2)) {
    const instruction = new ProcessingInstruction(node2.name, node2.data);
    if (node2["x-name"] != null) {
      instruction["x-name"] = node2["x-name"];
      instruction["x-publicId"] = node2["x-publicId"];
      instruction["x-systemId"] = node2["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node2.type}`);
  }
  result.startIndex = node2.startIndex;
  result.endIndex = node2.endIndex;
  if (node2.sourceCodeLocation != null) {
    result.sourceCodeLocation = node2.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children2 = childs.map((child2) => cloneNode(child2, true));
  for (let i2 = 1; i2 < children2.length; i2++) {
    children2[i2].prev = children2[i2 - 1];
    children2[i2 - 1].next = children2[i2];
  }
  return children2;
}
const defaultOpts$2 = {
  withStartIndices: false,
  withEndIndices: false,
  xmlMode: false
};
let DomHandler$1 = class DomHandler {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(callback, options2, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options2 === "function") {
      elementCB = options2;
      options2 = defaultOpts$2;
    }
    if (typeof callback === "object") {
      options2 = callback;
      callback = void 0;
    }
    this.callback = callback !== null && callback !== void 0 ? callback : null;
    this.options = options2 !== null && options2 !== void 0 ? options2 : defaultOpts$2;
    this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
  }
  onparserinit(parser2) {
    this.parser = parser2;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error) {
    this.handleCallback(error);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name2, attribs) {
    const type = this.options.xmlMode ? ElementType$4.Tag : void 0;
    const element2 = new Element$1(name2, attribs, void 0, type);
    this.addNode(element2);
    this.tagStack.push(element2);
  }
  ontext(data2) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType$4.Text) {
      lastNode.data += data2;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node2 = new Text(data2);
      this.addNode(node2);
      this.lastNode = node2;
    }
  }
  oncomment(data2) {
    if (this.lastNode && this.lastNode.type === ElementType$4.Comment) {
      this.lastNode.data += data2;
      return;
    }
    const node2 = new Comment(data2);
    this.addNode(node2);
    this.lastNode = node2;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text2 = new Text("");
    const node2 = new CDATA([text2]);
    this.addNode(node2);
    text2.parent = node2;
    this.lastNode = text2;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name2, data2) {
    const node2 = new ProcessingInstruction(name2, data2);
    this.addNode(node2);
  }
  handleCallback(error) {
    if (typeof this.callback === "function") {
      this.callback(error, this.dom);
    } else if (error) {
      throw error;
    }
  }
  addNode(node2) {
    const parent2 = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent2.children[parent2.children.length - 1];
    if (this.options.withStartIndices) {
      node2.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node2.endIndex = this.parser.endIndex;
    }
    parent2.children.push(node2);
    if (previousSibling) {
      node2.prev = previousSibling;
      previousSibling.next = node2;
    }
    node2.parent = parent2;
    this.lastNode = null;
  }
};
const htmlDecodeTree = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((c) => c.charCodeAt(0))
);
const xmlDecodeTree = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((c) => c.charCodeAt(0))
);
var _a;
const decodeMap$1 = /* @__PURE__ */ new Map([
  [0, 65533],
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
const fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a2;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a2 = decodeMap$1.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
}
var CharCodes$1;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
})(CharCodes$1 || (CharCodes$1 = {}));
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid2 = lo + hi >>> 1;
    const midVal = decodeTree[mid2];
    if (midVal < char) {
      lo = mid2 + 1;
    } else if (midVal > char) {
      hi = mid2 - 1;
    } else {
      return decodeTree[mid2 + branchCount];
    }
  }
  return -1;
}
const xmlReplacer$1 = /["&'<>$\x80-\uFFFF]/g;
const xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
const getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index2) => str.codePointAt(index2) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index2) => (c.charCodeAt(index2) & 64512) === 55296 ? (c.charCodeAt(index2) - 55296) * 1024 + c.charCodeAt(index2 + 1) - 56320 + 65536 : c.charCodeAt(index2)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer$1.exec(str)) !== null) {
    const i2 = match.index;
    const char = str.charCodeAt(i2);
    const next2 = xmlCodeMap.get(char);
    if (next2 !== void 0) {
      ret += str.substring(lastIdx, i2) + next2;
      lastIdx = i2 + 1;
    } else {
      ret += `${str.substring(lastIdx, i2)}&#x${getCodePoint(str, i2).toString(16)};`;
      lastIdx = xmlReplacer$1.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape(data2) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data2)) {
      if (lastIdx !== match.index) {
        result += data2.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
const escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
const escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
const elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val2) => [val2.toLowerCase(), val2]));
const attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val2) => [val2.toLowerCase(), val2]));
const unencodedElements$1 = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes2, opts) {
  var _a2;
  if (!attributes2)
    return;
  const encode2 = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes2).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes2[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode2(value)}"`;
  }).join(" ");
}
const singleTag$1 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render$3(node2, options2 = {}) {
  const nodes = "length" in node2 ? node2 : [node2];
  let output = "";
  for (let i2 = 0; i2 < nodes.length; i2++) {
    output += renderNode(nodes[i2], options2);
  }
  return output;
}
function renderNode(node2, options2) {
  switch (node2.type) {
    case Root:
      return render$3(node2.children, options2);
    case Doctype:
    case Directive:
      return renderDirective$1(node2);
    case Comment$1:
      return renderComment$1(node2);
    case CDATA$1:
      return renderCdata$1(node2);
    case Script:
    case Style:
    case Tag:
      return renderTag$1(node2, options2);
    case Text$1:
      return renderText$1(node2, options2);
  }
}
const foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
const foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag$1(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag2 = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag2 += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag$1.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag2 += " ";
    tag2 += "/>";
  } else {
    tag2 += ">";
    if (elem.children.length > 0) {
      tag2 += render$3(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag$1.has(elem.name)) {
      tag2 += `</${elem.name}>`;
    }
  }
  return tag2;
}
function renderDirective$1(elem) {
  return `<${elem.data}>`;
}
function renderText$1(elem, opts) {
  var _a2;
  let data2 = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements$1.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
  }
  return data2;
}
function renderCdata$1(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment$1(elem) {
  return `<!--${elem.data}-->`;
}
function getOuterHTML$1(node2, options2) {
  return render$3(node2, options2);
}
function getInnerHTML$1(node2, options2) {
  return hasChildren(node2) ? node2.children.map((node3) => getOuterHTML$1(node3, options2)).join("") : "";
}
function getText$2(node2) {
  if (Array.isArray(node2))
    return node2.map(getText$2).join("");
  if (isTag$6(node2))
    return node2.name === "br" ? "\n" : getText$2(node2.children);
  if (isCDATA(node2))
    return getText$2(node2.children);
  if (isText(node2))
    return node2.data;
  return "";
}
function textContent(node2) {
  if (Array.isArray(node2))
    return node2.map(textContent).join("");
  if (hasChildren(node2) && !isComment(node2)) {
    return textContent(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function innerText(node2) {
  if (Array.isArray(node2))
    return node2.map(innerText).join("");
  if (hasChildren(node2) && (node2.type === ElementType$4.Tag || isCDATA(node2))) {
    return innerText(node2.children);
  }
  if (isText(node2))
    return node2.data;
  return "";
}
function getChildren$5(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent$4(elem) {
  return elem.parent || null;
}
function getSiblings$2(elem) {
  const parent2 = getParent$4(elem);
  if (parent2 != null)
    return getChildren$5(parent2);
  const siblings2 = [elem];
  let { prev: prev2, next: next2 } = elem;
  while (prev2 != null) {
    siblings2.unshift(prev2);
    ({ prev: prev2 } = prev2);
  }
  while (next2 != null) {
    siblings2.push(next2);
    ({ next: next2 } = next2);
  }
  return siblings2;
}
function getAttributeValue$1(elem, name2) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name2];
}
function hasAttrib$2(elem, name2) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name2) && elem.attribs[name2] != null;
}
function getName$2(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next: next2 } = elem;
  while (next2 !== null && !isTag$6(next2))
    ({ next: next2 } = next2);
  return next2;
}
function prevElementSibling(elem) {
  let { prev: prev2 } = elem;
  while (prev2 !== null && !isTag$6(prev2))
    ({ prev: prev2 } = prev2);
  return prev2;
}
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    childs.splice(childs.lastIndexOf(elem), 1);
  }
}
function replaceElement(elem, replacement) {
  const prev2 = replacement.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement;
  }
  const next2 = replacement.next = elem.next;
  if (next2) {
    next2.prev = replacement;
  }
  const parent2 = replacement.parent = elem.parent;
  if (parent2) {
    const childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild$2(elem, child2) {
  removeElement(child2);
  child2.next = null;
  child2.parent = elem;
  if (elem.children.push(child2) > 1) {
    const sibling2 = elem.children[elem.children.length - 2];
    sibling2.next = child2;
    child2.prev = sibling2;
  } else {
    child2.prev = null;
  }
}
function append$1(elem, next2) {
  removeElement(next2);
  const { parent: parent2 } = elem;
  const currNext = elem.next;
  next2.next = currNext;
  next2.prev = elem;
  elem.next = next2;
  next2.parent = parent2;
  if (currNext) {
    currNext.prev = next2;
    if (parent2) {
      const childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next2);
    }
  } else if (parent2) {
    parent2.children.push(next2);
  }
}
function prependChild(elem, child2) {
  removeElement(child2);
  child2.parent = elem;
  child2.prev = null;
  if (elem.children.unshift(child2) !== 1) {
    const sibling2 = elem.children[1];
    sibling2.prev = child2;
    child2.next = sibling2;
  } else {
    child2.next = null;
  }
}
function prepend$1(elem, prev2) {
  removeElement(prev2);
  const { parent: parent2 } = elem;
  if (parent2) {
    const childs = parent2.children;
    childs.splice(childs.indexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
}
function filter$4(test, node2, recurse = true, limit = Infinity) {
  if (!Array.isArray(node2))
    node2 = [node2];
  return find$3(test, node2, recurse, limit);
}
function find$3(test, nodes, recurse, limit) {
  const result = [];
  for (const elem of nodes) {
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        break;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      const children2 = find$3(test, elem.children, recurse, limit);
      result.push(...children2);
      limit -= children2.length;
      if (limit <= 0)
        break;
    }
  }
  return result;
}
function findOneChild$1(test, nodes) {
  return nodes.find(test);
}
function findOne$2(test, nodes, recurse = true) {
  let elem = null;
  for (let i2 = 0; i2 < nodes.length && !elem; i2++) {
    const checked = nodes[i2];
    if (!isTag$6(checked)) {
      continue;
    } else if (test(checked)) {
      elem = checked;
    } else if (recurse && checked.children.length > 0) {
      elem = findOne$2(test, checked.children, true);
    }
  }
  return elem;
}
function existsOne$2(test, nodes) {
  return nodes.some((checked) => isTag$6(checked) && (test(checked) || checked.children.length > 0 && existsOne$2(test, checked.children)));
}
function findAll$2(test, nodes) {
  var _a2;
  const result = [];
  const stack = nodes.filter(isTag$6);
  let elem;
  while (elem = stack.shift()) {
    const children2 = (_a2 = elem.children) === null || _a2 === void 0 ? void 0 : _a2.filter(isTag$6);
    if (children2 && children2.length > 0) {
      stack.unshift(...children2);
    }
    if (test(elem))
      result.push(elem);
  }
  return result;
}
const Checks$1 = {
  tag_name(name2) {
    if (typeof name2 === "function") {
      return (elem) => isTag$6(elem) && name2(elem.name);
    } else if (name2 === "*") {
      return isTag$6;
    }
    return (elem) => isTag$6(elem) && elem.name === name2;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data2) {
    if (typeof data2 === "function") {
      return (elem) => isText(elem) && data2(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data2;
  }
};
function getAttribCheck$1(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag$6(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag$6(elem) && elem.attribs[attrib] === value;
}
function combineFuncs$1(a, b) {
  return (elem) => a(elem) || b(elem);
}
function compileTest(options2) {
  const funcs = Object.keys(options2).map((key) => {
    const value = options2[key];
    return Object.prototype.hasOwnProperty.call(Checks$1, key) ? Checks$1[key](value) : getAttribCheck$1(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs$1);
}
function testElement(options2, node2) {
  const test = compileTest(options2);
  return test ? test(node2) : true;
}
function getElements(options2, nodes, recurse, limit = Infinity) {
  const test = compileTest(options2);
  return test ? filter$4(test, nodes, recurse, limit) : [];
}
function getElementById(id, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne$2(getAttribCheck$1("id", id), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter$4(Checks$1["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter$4(Checks$1["tag_type"](type), nodes, recurse, limit);
}
function removeSubsets$1(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node2 = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node2, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node2.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings2 = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node2, i2, arr) => !arr.includes(node2, i2 + 1));
  nodes.sort((a, b) => {
    const relative = compareDocumentPosition(a, b);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "id", children2);
      addConditionally(entry, "title", "title", children2);
      const href2 = (_a3 = getOneElement("link", children2)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description2 = fetch$1("summary", children2) || fetch$1("content", children2);
      if (description2) {
        entry.description = description2;
      }
      const pubDate = fetch$1("updated", children2);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch$1("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children: children2 } = item;
      const entry = { media: getMediaElements(children2) };
      addConditionally(entry, "id", "guid", children2);
      addConditionally(entry, "title", "title", children2);
      addConditionally(entry, "link", "link", children2);
      addConditionally(entry, "description", "description", children2);
      const pubDate = fetch$1("pubDate", children2);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch$1("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
const MEDIA_KEYS_STRING = ["url", "type", "lang"];
const MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node2) {
  return getElementsByTagName(tagName, node2, true, 1)[0];
}
function fetch$1(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop2, tagName, where, recurse = false) {
  const val2 = fetch$1(tagName, where, recurse);
  if (val2)
    obj[prop2] = val2;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
const DomUtils$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DocumentPosition() {
    return DocumentPosition;
  },
  append: append$1,
  appendChild: appendChild$2,
  compareDocumentPosition,
  existsOne: existsOne$2,
  filter: filter$4,
  find: find$3,
  findAll: findAll$2,
  findOne: findOne$2,
  findOneChild: findOneChild$1,
  getAttributeValue: getAttributeValue$1,
  getChildren: getChildren$5,
  getElementById,
  getElements,
  getElementsByTagName,
  getElementsByTagType,
  getFeed,
  getInnerHTML: getInnerHTML$1,
  getName: getName$2,
  getOuterHTML: getOuterHTML$1,
  getParent: getParent$4,
  getSiblings: getSiblings$2,
  getText: getText$2,
  hasAttrib: hasAttrib$2,
  hasChildren,
  innerText,
  isCDATA,
  isComment,
  isDocument,
  isTag: isTag$6,
  isText,
  nextElementSibling,
  prepend: prepend$1,
  prependChild,
  prevElementSibling,
  removeElement,
  removeSubsets: removeSubsets$1,
  replaceElement,
  testElement,
  textContent,
  uniqueSort
}, Symbol.toStringTag, { value: "Module" }));
function render$2(that, dom, options2) {
  if (!that)
    return "";
  return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, void 0, options2).toString();
}
function isOptions(dom, options2) {
  return !options2 && typeof dom === "object" && dom != null && !("length" in dom) && !("type" in dom);
}
function html$2(dom, options2) {
  const toRender = isOptions(dom) ? (options2 = dom, void 0) : dom;
  const opts = {
    ...defaultOpts$3,
    ...this === null || this === void 0 ? void 0 : this._options,
    ...flatten$2(options2 !== null && options2 !== void 0 ? options2 : {})
  };
  return render$2(this, toRender, opts);
}
function xml(dom) {
  const options2 = { ...this._options, xmlMode: true };
  return render$2(this, dom, options2);
}
function text$1(elements) {
  const elems = elements ? elements : this ? this.root() : [];
  let ret = "";
  for (let i2 = 0; i2 < elems.length; i2++) {
    ret += textContent(elems[i2]);
  }
  return ret;
}
function parseHTML(data2, context, keepScripts = typeof context === "boolean" ? context : false) {
  if (!data2 || typeof data2 !== "string") {
    return null;
  }
  if (typeof context === "boolean") {
    keepScripts = context;
  }
  const parsed = this.load(data2, defaultOpts$3, false);
  if (!keepScripts) {
    parsed("script").remove();
  }
  return parsed.root()[0].children.slice();
}
function root$d() {
  return this(this._root);
}
function contains(container, contained) {
  if (contained === container) {
    return false;
  }
  let next2 = contained;
  while (next2 && next2 !== next2.parent) {
    next2 = next2.parent;
    if (next2 === container) {
      return true;
    }
  }
  return false;
}
function merge$1(arr1, arr2) {
  if (!isArrayLike$8(arr1) || !isArrayLike$8(arr2)) {
    return;
  }
  let newLength = arr1.length;
  const len = +arr2.length;
  for (let i2 = 0; i2 < len; i2++) {
    arr1[newLength++] = arr2[i2];
  }
  arr1.length = newLength;
  return arr1;
}
function isArrayLike$8(item) {
  if (Array.isArray(item)) {
    return true;
  }
  if (typeof item !== "object" || !Object.prototype.hasOwnProperty.call(item, "length") || typeof item.length !== "number" || item.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < item.length; i2++) {
    if (!(i2 in item)) {
      return false;
    }
  }
  return true;
}
const staticMethods = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contains,
  html: html$2,
  merge: merge$1,
  parseHTML,
  root: root$d,
  text: text$1,
  xml
}, Symbol.toStringTag, { value: "Module" }));
function isCheerio(maybeCheerio) {
  return maybeCheerio.cheerio != null;
}
function camelCase(str) {
  return str.replace(/[_.-](\w|$)/g, (_2, x) => x.toUpperCase());
}
function cssCase(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
}
function domEach$1(array, fn) {
  const len = array.length;
  for (let i2 = 0; i2 < len; i2++)
    fn(array[i2], i2);
  return array;
}
function cloneDom(dom) {
  const clone2 = "length" in dom ? Array.prototype.map.call(dom, (el2) => cloneNode(el2, true)) : [cloneNode(dom, true)];
  const root2 = new Document(clone2);
  clone2.forEach((node2) => {
    node2.parent = root2;
  });
  return clone2;
}
var CharacterCodes;
(function(CharacterCodes2) {
  CharacterCodes2[CharacterCodes2["LowerA"] = 97] = "LowerA";
  CharacterCodes2[CharacterCodes2["LowerZ"] = 122] = "LowerZ";
  CharacterCodes2[CharacterCodes2["UpperA"] = 65] = "UpperA";
  CharacterCodes2[CharacterCodes2["UpperZ"] = 90] = "UpperZ";
  CharacterCodes2[CharacterCodes2["Exclamation"] = 33] = "Exclamation";
})(CharacterCodes || (CharacterCodes = {}));
function isHtml(str) {
  const tagStart = str.indexOf("<");
  if (tagStart < 0 || tagStart > str.length - 3)
    return false;
  const tagChar = str.charCodeAt(tagStart + 1);
  return (tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ || tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ || tagChar === CharacterCodes.Exclamation) && str.includes(">", tagStart + 2);
}
const hasOwn = Object.prototype.hasOwnProperty;
const rspace = /\s+/;
const dataAttrPrefix = "data-";
const primitives = {
  null: null,
  true: true,
  false: false
};
const rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
const rbrace$1 = /^{[^]*}$|^\[[^]*]$/;
function getAttr(elem, name2, xmlMode) {
  var _a2;
  if (!elem || !isTag$6(elem))
    return void 0;
  (_a2 = elem.attribs) !== null && _a2 !== void 0 ? _a2 : elem.attribs = {};
  if (!name2) {
    return elem.attribs;
  }
  if (hasOwn.call(elem.attribs, name2)) {
    return !xmlMode && rboolean.test(name2) ? name2 : elem.attribs[name2];
  }
  if (elem.name === "option" && name2 === "value") {
    return text$1(elem.children);
  }
  if (elem.name === "input" && (elem.attribs["type"] === "radio" || elem.attribs["type"] === "checkbox") && name2 === "value") {
    return "on";
  }
  return void 0;
}
function setAttr(el2, name2, value) {
  if (value === null) {
    removeAttribute(el2, name2);
  } else {
    el2.attribs[name2] = `${value}`;
  }
}
function attr(name2, value) {
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 !== "string") {
        {
          throw new Error("Bad combination of arguments.");
        }
      }
      return domEach$1(this, (el2, i2) => {
        if (isTag$6(el2))
          setAttr(el2, name2, value.call(el2, i2, el2.attribs[name2]));
      });
    }
    return domEach$1(this, (el2) => {
      if (!isTag$6(el2))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach((objName) => {
          const objValue = name2[objName];
          setAttr(el2, objName, objValue);
        });
      } else {
        setAttr(el2, name2, value);
      }
    });
  }
  return arguments.length > 1 ? this : getAttr(this[0], name2, this.options.xmlMode);
}
function getProp(el2, name2, xmlMode) {
  return name2 in el2 ? (
    // @ts-expect-error TS doesn't like us accessing the value directly here.
    el2[name2]
  ) : !xmlMode && rboolean.test(name2) ? getAttr(el2, name2, false) !== void 0 : getAttr(el2, name2, xmlMode);
}
function setProp(el2, name2, value, xmlMode) {
  if (name2 in el2) {
    el2[name2] = value;
  } else {
    setAttr(el2, name2, !xmlMode && rboolean.test(name2) ? value ? "" : null : `${value}`);
  }
}
function prop$1(name2, value) {
  var _a2;
  if (typeof name2 === "string" && value === void 0) {
    const el2 = this[0];
    if (!el2 || !isTag$6(el2))
      return void 0;
    switch (name2) {
      case "style": {
        const property2 = this.css();
        const keys2 = Object.keys(property2);
        keys2.forEach((p, i2) => {
          property2[i2] = p;
        });
        property2.length = keys2.length;
        return property2;
      }
      case "tagName":
      case "nodeName": {
        return el2.name.toUpperCase();
      }
      case "href":
      case "src": {
        const prop2 = (_a2 = el2.attribs) === null || _a2 === void 0 ? void 0 : _a2[name2];
        if (typeof URL !== "undefined" && (name2 === "href" && (el2.tagName === "a" || el2.name === "link") || name2 === "src" && (el2.tagName === "img" || el2.tagName === "iframe" || el2.tagName === "audio" || el2.tagName === "video" || el2.tagName === "source")) && prop2 !== void 0 && this.options.baseURI) {
          return new URL(prop2, this.options.baseURI).href;
        }
        return prop2;
      }
      case "innerText": {
        return innerText(el2);
      }
      case "textContent": {
        return textContent(el2);
      }
      case "outerHTML":
        return this.clone().wrap("<container />").parent().html();
      case "innerHTML":
        return this.html();
      default:
        return getProp(el2, name2, this.options.xmlMode);
    }
  }
  if (typeof name2 === "object" || value !== void 0) {
    if (typeof value === "function") {
      if (typeof name2 === "object") {
        throw new Error("Bad combination of arguments.");
      }
      return domEach$1(this, (el2, i2) => {
        if (isTag$6(el2)) {
          setProp(el2, name2, value.call(el2, i2, getProp(el2, name2, this.options.xmlMode)), this.options.xmlMode);
        }
      });
    }
    return domEach$1(this, (el2) => {
      if (!isTag$6(el2))
        return;
      if (typeof name2 === "object") {
        Object.keys(name2).forEach((key) => {
          const val2 = name2[key];
          setProp(el2, key, val2, this.options.xmlMode);
        });
      } else {
        setProp(el2, name2, value, this.options.xmlMode);
      }
    });
  }
  return void 0;
}
function setData$3(el2, name2, value) {
  var _a2;
  const elem = el2;
  (_a2 = elem.data) !== null && _a2 !== void 0 ? _a2 : elem.data = {};
  if (typeof name2 === "object")
    Object.assign(elem.data, name2);
  else if (typeof name2 === "string" && value !== void 0) {
    elem.data[name2] = value;
  }
}
function readData(el2, name2) {
  let domNames;
  let jsNames;
  let value;
  if (name2 == null) {
    domNames = Object.keys(el2.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));
    jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));
  } else {
    domNames = [dataAttrPrefix + cssCase(name2)];
    jsNames = [name2];
  }
  for (let idx = 0; idx < domNames.length; ++idx) {
    const domName = domNames[idx];
    const jsName = jsNames[idx];
    if (hasOwn.call(el2.attribs, domName) && !hasOwn.call(el2.data, jsName)) {
      value = el2.attribs[domName];
      if (hasOwn.call(primitives, value)) {
        value = primitives[value];
      } else if (value === String(Number(value))) {
        value = Number(value);
      } else if (rbrace$1.test(value)) {
        try {
          value = JSON.parse(value);
        } catch (e) {
        }
      }
      el2.data[jsName] = value;
    }
  }
  return name2 == null ? el2.data : value;
}
function data(name2, value) {
  var _a2;
  const elem = this[0];
  if (!elem || !isTag$6(elem))
    return;
  const dataEl = elem;
  (_a2 = dataEl.data) !== null && _a2 !== void 0 ? _a2 : dataEl.data = {};
  if (!name2) {
    return readData(dataEl);
  }
  if (typeof name2 === "object" || value !== void 0) {
    domEach$1(this, (el2) => {
      if (isTag$6(el2)) {
        if (typeof name2 === "object")
          setData$3(el2, name2);
        else
          setData$3(el2, name2, value);
      }
    });
    return this;
  }
  if (hasOwn.call(dataEl.data, name2)) {
    return dataEl.data[name2];
  }
  return readData(dataEl, name2);
}
function val(value) {
  const querying2 = arguments.length === 0;
  const element2 = this[0];
  if (!element2 || !isTag$6(element2))
    return querying2 ? void 0 : this;
  switch (element2.name) {
    case "textarea":
      return this.text(value);
    case "select": {
      const option = this.find("option:selected");
      if (!querying2) {
        if (this.attr("multiple") == null && typeof value === "object") {
          return this;
        }
        this.find("option").removeAttr("selected");
        const values = typeof value !== "object" ? [value] : value;
        for (let i2 = 0; i2 < values.length; i2++) {
          this.find(`option[value="${values[i2]}"]`).attr("selected", "");
        }
        return this;
      }
      return this.attr("multiple") ? option.toArray().map((el2) => text$1(el2.children)) : option.attr("value");
    }
    case "input":
    case "option":
      return querying2 ? this.attr("value") : this.attr("value", value);
  }
  return void 0;
}
function removeAttribute(elem, name2) {
  if (!elem.attribs || !hasOwn.call(elem.attribs, name2))
    return;
  delete elem.attribs[name2];
}
function splitNames(names) {
  return names ? names.trim().split(rspace) : [];
}
function removeAttr(name2) {
  const attrNames = splitNames(name2);
  for (let i2 = 0; i2 < attrNames.length; i2++) {
    domEach$1(this, (elem) => {
      if (isTag$6(elem))
        removeAttribute(elem, attrNames[i2]);
    });
  }
  return this;
}
function hasClass(className) {
  return this.toArray().some((elem) => {
    const clazz = isTag$6(elem) && elem.attribs["class"];
    let idx = -1;
    if (clazz && className.length) {
      while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
        const end2 = idx + className.length;
        if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end2 === clazz.length || rspace.test(clazz[end2]))) {
          return true;
        }
      }
    }
    return false;
  });
}
function addClass(value) {
  if (typeof value === "function") {
    return domEach$1(this, (el2, i2) => {
      if (isTag$6(el2)) {
        const className = el2.attribs["class"] || "";
        addClass.call([el2], value.call(el2, i2, className));
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numElements = this.length;
  for (let i2 = 0; i2 < numElements; i2++) {
    const el2 = this[i2];
    if (!isTag$6(el2))
      continue;
    const className = getAttr(el2, "class", false);
    if (!className) {
      setAttr(el2, "class", classNames.join(" ").trim());
    } else {
      let setClass = ` ${className} `;
      for (let j2 = 0; j2 < classNames.length; j2++) {
        const appendClass = `${classNames[j2]} `;
        if (!setClass.includes(` ${appendClass}`))
          setClass += appendClass;
      }
      setAttr(el2, "class", setClass.trim());
    }
  }
  return this;
}
function removeClass(name2) {
  if (typeof name2 === "function") {
    return domEach$1(this, (el2, i2) => {
      if (isTag$6(el2)) {
        removeClass.call([el2], name2.call(el2, i2, el2.attribs["class"] || ""));
      }
    });
  }
  const classes = splitNames(name2);
  const numClasses = classes.length;
  const removeAll = arguments.length === 0;
  return domEach$1(this, (el2) => {
    if (!isTag$6(el2))
      return;
    if (removeAll) {
      el2.attribs["class"] = "";
    } else {
      const elClasses = splitNames(el2.attribs["class"]);
      let changed = false;
      for (let j2 = 0; j2 < numClasses; j2++) {
        const index2 = elClasses.indexOf(classes[j2]);
        if (index2 >= 0) {
          elClasses.splice(index2, 1);
          changed = true;
          j2--;
        }
      }
      if (changed) {
        el2.attribs["class"] = elClasses.join(" ");
      }
    }
  });
}
function toggleClass(value, stateVal) {
  if (typeof value === "function") {
    return domEach$1(this, (el2, i2) => {
      if (isTag$6(el2)) {
        toggleClass.call([el2], value.call(el2, i2, el2.attribs["class"] || "", stateVal), stateVal);
      }
    });
  }
  if (!value || typeof value !== "string")
    return this;
  const classNames = value.split(rspace);
  const numClasses = classNames.length;
  const state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0;
  const numElements = this.length;
  for (let i2 = 0; i2 < numElements; i2++) {
    const el2 = this[i2];
    if (!isTag$6(el2))
      continue;
    const elementClasses = splitNames(el2.attribs["class"]);
    for (let j2 = 0; j2 < numClasses; j2++) {
      const index2 = elementClasses.indexOf(classNames[j2]);
      if (state >= 0 && index2 < 0) {
        elementClasses.push(classNames[j2]);
      } else if (state <= 0 && index2 >= 0) {
        elementClasses.splice(index2, 1);
      }
    }
    el2.attribs["class"] = elementClasses.join(" ");
  }
  return this;
}
const Attributes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addClass,
  attr,
  data,
  hasClass,
  prop: prop$1,
  removeAttr,
  removeClass,
  toggleClass,
  val
}, Symbol.toStringTag, { value: "Module" }));
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
const actionTypes$1 = /* @__PURE__ */ new Map([
  [126, AttributeAction.Element],
  [94, AttributeAction.Start],
  [36, AttributeAction.End],
  [42, AttributeAction.Any],
  [33, AttributeAction.Not],
  [124, AttributeAction.Hyphen]
]);
const unpackPseudos$1 = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
function isTraversal$2(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
const stripQuotesFromPseudos$1 = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape$1(_2, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS$1(str) {
  return str.replace(reEscape, funescape$1);
}
function isQuote(c) {
  return c === 39 || c === 34;
}
function isWhitespace$4(c) {
  return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
}
function parse$b(selector) {
  const subselects2 = [];
  const endIndex = parseSelector$1(subselects2, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector$1(subselects2, selector, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name2] = match;
    selectorIndex += offset + name2.length;
    return unescapeCSS$1(name2);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace$4(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS$1(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$2(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name2, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name: name2,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name2;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name2 = getName2(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name2 = getName2(2);
          } else {
            name2 = getName2(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name2;
              name2 = getName2(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes$1.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS$1(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace$4(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS$1(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name: name2,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName2(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name2 = getName2(1).toLowerCase();
          let data2 = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos$1.has(name2)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name2} cannot be quoted`);
              }
              data2 = [];
              selectorIndex = parseSelector$1(data2, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name2} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data2 = readValueWithParenthesis();
              if (stripQuotesFromPseudos$1.has(name2)) {
                const quot2 = data2.charCodeAt(0);
                if (quot2 === data2.charCodeAt(data2.length - 1) && isQuote(quot2)) {
                  data2 = data2.slice(1, -1);
                }
              }
              data2 = unescapeCSS$1(data2);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name: name2, data: data2 });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name2;
          if (firstChar === 42) {
            selectorIndex += 1;
            name2 = "*";
          } else if (firstChar === 124) {
            name2 = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name2 = getName2(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name2;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name2 = "*";
              selectorIndex += 2;
            } else {
              name2 = getName2(1);
            }
          }
          tokens.push(name2 === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name: name2, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f, args);
        return new Ctor();
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var boolbase = {
  trueFunc: function trueFunc() {
    return true;
  },
  falseFunc: function falseFunc() {
    return false;
  }
};
const procedure$2 = /* @__PURE__ */ new Map([
  [SelectorType.Universal, 50],
  [SelectorType.Tag, 30],
  [SelectorType.Attribute, 1],
  [SelectorType.Pseudo, 0]
]);
function isTraversal$1(token) {
  return !procedure$2.has(token.type);
}
const attributes$3 = /* @__PURE__ */ new Map([
  [AttributeAction.Exists, 10],
  [AttributeAction.Equals, 8],
  [AttributeAction.Not, 7],
  [AttributeAction.Start, 6],
  [AttributeAction.End, 6],
  [AttributeAction.Any, 5]
]);
function sortByProcedure$1(arr) {
  const procs = arr.map(getProcedure$1);
  for (let i2 = 1; i2 < arr.length; i2++) {
    const procNew = procs[i2];
    if (procNew < 0)
      continue;
    for (let j2 = i2 - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
      const token = arr[j2 + 1];
      arr[j2 + 1] = arr[j2];
      arr[j2] = token;
      procs[j2 + 1] = procs[j2];
      procs[j2] = procNew;
    }
  }
}
function getProcedure$1(token) {
  var _a2, _b;
  let proc = (_a2 = procedure$2.get(token.type)) !== null && _a2 !== void 0 ? _a2 : -1;
  if (token.type === SelectorType.Attribute) {
    proc = (_b = attributes$3.get(token.action)) !== null && _b !== void 0 ? _b : 4;
    if (token.action === AttributeAction.Equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (token.type === SelectorType.Pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (Array.isArray(token.data)) {
      proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure$1))));
      if (proc < 0) {
        proc = 0;
      }
    } else {
      proc = 2;
    }
  }
  return proc;
}
const reChars$1 = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars$1, "\\$&");
}
const caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options2) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options2.quirksMode : !options2.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
const attributeRules$1 = {
  equals(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2 } = data2;
    let { value } = data2;
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length === value.length && attr2.toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name2) === value && next2(elem);
  },
  hyphen(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return function hyphen2(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name2);
      return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len) === value && next2(elem);
    };
  },
  element(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2, value } = data2;
    if (/\s/.test(value)) {
      return boolbase.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options2) ? "i" : "");
    return function element2(elem) {
      const attr2 = adapter2.getAttributeValue(elem, name2);
      return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
    };
  },
  exists(next2, { name: name2 }, { adapter: adapter2 }) {
    return (elem) => adapter2.hasAttrib(elem, name2) && next2(elem);
  },
  start(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = value.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= len && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value)) && next2(elem);
    };
  },
  end(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2 } = data2;
    let { value } = data2;
    const len = -value.length;
    if (len === 0) {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return (elem) => {
        var _a2;
        return ((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value)) && next2(elem);
    };
  },
  any(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2, value } = data2;
    if (value === "") {
      return boolbase.falseFunc;
    }
    if (shouldIgnoreCase(data2, options2)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return attr2 != null && attr2.length >= value.length && regex.test(attr2) && next2(elem);
      };
    }
    return (elem) => {
      var _a2;
      return !!((_a2 = adapter2.getAttributeValue(elem, name2)) === null || _a2 === void 0 ? void 0 : _a2.includes(value)) && next2(elem);
    };
  },
  not(next2, data2, options2) {
    const { adapter: adapter2 } = options2;
    const { name: name2 } = data2;
    let { value } = data2;
    if (value === "") {
      return (elem) => !!adapter2.getAttributeValue(elem, name2) && next2(elem);
    } else if (shouldIgnoreCase(data2, options2)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr2 = adapter2.getAttributeValue(elem, name2);
        return (attr2 == null || attr2.length !== value.length || attr2.toLowerCase() !== value) && next2(elem);
      };
    }
    return (elem) => adapter2.getAttributeValue(elem, name2) !== value && next2(elem);
  }
};
const whitespace$1 = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
const ZERO = "0".charCodeAt(0);
const NINE = "9".charCodeAt(0);
function parse$a(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace$1.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile$5(parsed) {
  const a = parsed[0];
  const b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return boolbase.falseFunc;
  if (a === -1)
    return (index2) => index2 <= b;
  if (a === 0)
    return (index2) => index2 === b;
  if (a === 1)
    return b < 0 ? boolbase.trueFunc : (index2) => index2 >= b;
  const absA = Math.abs(a);
  const bMod = (b % absA + absA) % absA;
  return a > 1 ? (index2) => index2 >= b && index2 % absA === bMod : (index2) => index2 <= b && index2 % absA === bMod;
}
function nthCheck$1(formula) {
  return compile$5(parse$a(formula));
}
function getChildFunc$1(next2, adapter2) {
  return (elem) => {
    const parent2 = adapter2.getParent(elem);
    return parent2 != null && adapter2.isTag(parent2) && next2(elem);
  };
}
const filters$2 = {
  contains(next2, text2, { adapter: adapter2 }) {
    return function contains2(elem) {
      return next2(elem) && adapter2.getText(elem).includes(text2);
    };
  },
  icontains(next2, text2, { adapter: adapter2 }) {
    const itext = text2.toLowerCase();
    return function icontains(elem) {
      return next2(elem) && adapter2.getText(elem).toLowerCase().includes(itext);
    };
  },
  // Location specific methods
  "nth-child"(next2, rule, { adapter: adapter2, equals: equals2 }) {
    const func = nthCheck$1(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc$1(next2, adapter2);
    return function nthChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = 0; i2 < siblings2.length; i2++) {
        if (equals2(elem, siblings2[i2]))
          break;
        if (adapter2.isTag(siblings2[i2])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-child"(next2, rule, { adapter: adapter2, equals: equals2 }) {
    const func = nthCheck$1(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc$1(next2, adapter2);
    return function nthLastChild(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = siblings2.length - 1; i2 >= 0; i2--) {
        if (equals2(elem, siblings2[i2]))
          break;
        if (adapter2.isTag(siblings2[i2])) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-of-type"(next2, rule, { adapter: adapter2, equals: equals2 }) {
    const func = nthCheck$1(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc$1(next2, adapter2);
    return function nthOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = 0; i2 < siblings2.length; i2++) {
        const currentSibling = siblings2[i2];
        if (equals2(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-of-type"(next2, rule, { adapter: adapter2, equals: equals2 }) {
    const func = nthCheck$1(rule);
    if (func === boolbase.falseFunc)
      return boolbase.falseFunc;
    if (func === boolbase.trueFunc)
      return getChildFunc$1(next2, adapter2);
    return function nthLastOfType(elem) {
      const siblings2 = adapter2.getSiblings(elem);
      let pos = 0;
      for (let i2 = siblings2.length - 1; i2 >= 0; i2--) {
        const currentSibling = siblings2[i2];
        if (equals2(elem, currentSibling))
          break;
        if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === adapter2.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  // TODO determine the actual root element
  root(next2, _rule, { adapter: adapter2 }) {
    return (elem) => {
      const parent2 = adapter2.getParent(elem);
      return (parent2 == null || !adapter2.isTag(parent2)) && next2(elem);
    };
  },
  scope(next2, rule, options2, context) {
    const { equals: equals2 } = options2;
    if (!context || context.length === 0) {
      return filters$2["root"](next2, rule, options2);
    }
    if (context.length === 1) {
      return (elem) => equals2(context[0], elem) && next2(elem);
    }
    return (elem) => context.includes(elem) && next2(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name2) {
  return function dynamicPseudo(next2, _rule, { adapter: adapter2 }) {
    const func = adapter2[name2];
    if (typeof func !== "function") {
      return boolbase.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next2(elem);
    };
  };
}
const pseudos$1 = {
  empty(elem, { adapter: adapter2 }) {
    return !adapter2.getChildren(elem).some((elem2) => (
      // FIXME: `getText` call is potentially expensive.
      adapter2.isTag(elem2) || adapter2.getText(elem2) !== ""
    ));
  },
  "first-child"(elem, { adapter: adapter2, equals: equals2 }) {
    if (adapter2.prevElementSibling) {
      return adapter2.prevElementSibling(elem) == null;
    }
    const firstChild = adapter2.getSiblings(elem).find((elem2) => adapter2.isTag(elem2));
    return firstChild != null && equals2(elem, firstChild);
  },
  "last-child"(elem, { adapter: adapter2, equals: equals2 }) {
    const siblings2 = adapter2.getSiblings(elem);
    for (let i2 = siblings2.length - 1; i2 >= 0; i2--) {
      if (equals2(elem, siblings2[i2]))
        return true;
      if (adapter2.isTag(siblings2[i2]))
        break;
    }
    return false;
  },
  "first-of-type"(elem, { adapter: adapter2, equals: equals2 }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i2 = 0; i2 < siblings2.length; i2++) {
      const currentSibling = siblings2[i2];
      if (equals2(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter: adapter2, equals: equals2 }) {
    const siblings2 = adapter2.getSiblings(elem);
    const elemName = adapter2.getName(elem);
    for (let i2 = siblings2.length - 1; i2 >= 0; i2--) {
      const currentSibling = siblings2[i2];
      if (equals2(elem, currentSibling))
        return true;
      if (adapter2.isTag(currentSibling) && adapter2.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter: adapter2, equals: equals2 }) {
    const elemName = adapter2.getName(elem);
    return adapter2.getSiblings(elem).every((sibling2) => equals2(elem, sibling2) || !adapter2.isTag(sibling2) || adapter2.getName(sibling2) !== elemName);
  },
  "only-child"(elem, { adapter: adapter2, equals: equals2 }) {
    return adapter2.getSiblings(elem).every((sibling2) => equals2(elem, sibling2) || !adapter2.isTag(sibling2));
  }
};
function verifyPseudoArgs(func, name2, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name2} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name2} doesn't have any arguments`);
  }
}
const aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  // JQuery extensions
  // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
const PLACEHOLDER_ELEMENT$1 = {};
function ensureIsTag(next2, adapter2) {
  if (next2 === boolbase.falseFunc)
    return boolbase.falseFunc;
  return (elem) => adapter2.isTag(elem) && next2(elem);
}
function getNextSiblings(elem, adapter2) {
  const siblings2 = adapter2.getSiblings(elem);
  if (siblings2.length <= 1)
    return [];
  const elemIndex = siblings2.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings2.length - 1)
    return [];
  return siblings2.slice(elemIndex + 1).filter(adapter2.isTag);
}
function copyOptions(options2) {
  return {
    xmlMode: !!options2.xmlMode,
    lowerCaseAttributeNames: !!options2.lowerCaseAttributeNames,
    lowerCaseTags: !!options2.lowerCaseTags,
    quirksMode: !!options2.quirksMode,
    cacheResults: !!options2.cacheResults,
    pseudos: options2.pseudos,
    adapter: options2.adapter,
    equals: options2.equals
  };
}
const is$3 = (next2, token, options2, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options2), context);
  return func === boolbase.trueFunc ? next2 : func === boolbase.falseFunc ? boolbase.falseFunc : (elem) => func(elem) && next2(elem);
};
const subselects = {
  is: is$3,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is$3,
  where: is$3,
  not(next2, token, options2, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options2), context);
    return func === boolbase.falseFunc ? next2 : func === boolbase.trueFunc ? boolbase.falseFunc : (elem) => !func(elem) && next2(elem);
  },
  has(next2, subselect, options2, _context, compileToken2) {
    const { adapter: adapter2 } = options2;
    const opts = copyOptions(options2);
    opts.relativeSelector = true;
    const context = subselect.some((s) => s.some(isTraversal$1)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT$1]
    ) : void 0;
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === boolbase.falseFunc)
      return boolbase.falseFunc;
    const hasElement = ensureIsTag(compiled, adapter2);
    if (context && compiled !== boolbase.trueFunc) {
      const { shouldTestNextSiblings = false } = compiled;
      return (elem) => {
        if (!next2(elem))
          return false;
        context[0] = elem;
        const childs = adapter2.getChildren(elem);
        const nextElements = shouldTestNextSiblings ? [...childs, ...getNextSiblings(elem, adapter2)] : childs;
        return adapter2.existsOne(hasElement, nextElements);
      };
    }
    return (elem) => next2(elem) && adapter2.existsOne(hasElement, adapter2.getChildren(elem));
  }
};
function compilePseudoSelector(next2, selector, options2, context, compileToken2) {
  var _a2;
  const { name: name2, data: data2 } = selector;
  if (Array.isArray(data2)) {
    if (!(name2 in subselects)) {
      throw new Error(`Unknown pseudo-class :${name2}(${data2})`);
    }
    return subselects[name2](next2, data2, options2, context, compileToken2);
  }
  const userPseudo = (_a2 = options2.pseudos) === null || _a2 === void 0 ? void 0 : _a2[name2];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name2];
  if (typeof stringPseudo === "string") {
    if (data2 != null) {
      throw new Error(`Pseudo ${name2} doesn't have any arguments`);
    }
    const alias = parse$b(stringPseudo);
    return subselects["is"](next2, alias, options2, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name2, data2, 1);
    return (elem) => userPseudo(elem, data2) && next2(elem);
  }
  if (name2 in filters$2) {
    return filters$2[name2](next2, data2, options2, context);
  }
  if (name2 in pseudos$1) {
    const pseudo2 = pseudos$1[name2];
    verifyPseudoArgs(pseudo2, name2, data2, 2);
    return (elem) => pseudo2(elem, options2, data2) && next2(elem);
  }
  throw new Error(`Unknown pseudo-class :${name2}`);
}
function getElementParent(node2, adapter2) {
  const parent2 = adapter2.getParent(node2);
  if (parent2 && adapter2.isTag(parent2)) {
    return parent2;
  }
  return null;
}
function compileGeneralSelector(next2, selector, options2, context, compileToken2) {
  const { adapter: adapter2, equals: equals2 } = options2;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options2.xmlMode || options2.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules$1[selector.action](next2, selector, options2);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next2, selector, options2, context, compileToken2);
    }
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name: name2 } = selector;
      if (!options2.xmlMode || options2.lowerCaseTags) {
        name2 = name2.toLowerCase();
      }
      return function tag2(elem) {
        return adapter2.getName(elem) === name2 && next2(elem);
      };
    }
    case SelectorType.Descendant: {
      if (options2.cacheResults === false || typeof WeakSet === "undefined") {
        return function descendant2(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter2)) {
            if (next2(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const isFalseCache = /* @__PURE__ */ new WeakSet();
      return function cachedDescendant(elem) {
        let current = elem;
        while (current = getElementParent(current, adapter2)) {
          if (!isFalseCache.has(current)) {
            if (adapter2.isTag(current) && next2(current)) {
              return true;
            }
            isFalseCache.add(current);
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next2(current))
            return true;
        } while (current = getElementParent(current, adapter2));
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent2(elem) {
        return adapter2.getChildren(elem).some((elem2) => adapter2.isTag(elem2) && next2(elem2));
      };
    }
    case SelectorType.Child: {
      return function child2(elem) {
        const parent2 = adapter2.getParent(elem);
        return parent2 != null && adapter2.isTag(parent2) && next2(parent2);
      };
    }
    case SelectorType.Sibling: {
      return function sibling2(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        for (let i2 = 0; i2 < siblings2.length; i2++) {
          const currentSibling = siblings2[i2];
          if (equals2(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling) && next2(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter2.prevElementSibling) {
        return function adjacent2(elem) {
          const previous = adapter2.prevElementSibling(elem);
          return previous != null && next2(previous);
        };
      }
      return function adjacent2(elem) {
        const siblings2 = adapter2.getSiblings(elem);
        let lastElement;
        for (let i2 = 0; i2 < siblings2.length; i2++) {
          const currentSibling = siblings2[i2];
          if (equals2(elem, currentSibling))
            break;
          if (adapter2.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next2(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next2;
    }
  }
}
function includesScopePseudo$1(t) {
  return t.type === SelectorType.Pseudo && (t.name === "scope" || Array.isArray(t.data) && t.data.some((data2) => data2.some(includesScopePseudo$1)));
}
const DESCENDANT_TOKEN$1 = { type: SelectorType.Descendant };
const FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
const SCOPE_TOKEN$1 = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize$1(token, { adapter: adapter2 }, context) {
  const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
    const parent2 = adapter2.isTag(e) && adapter2.getParent(e);
    return e === PLACEHOLDER_ELEMENT$1 || parent2 && adapter2.isTag(parent2);
  }));
  for (const t of token) {
    if (t.length > 0 && isTraversal$1(t[0]) && t[0].type !== SelectorType.Descendant)
      ;
    else if (hasContext && !t.some(includesScopePseudo$1)) {
      t.unshift(DESCENDANT_TOKEN$1);
    } else {
      continue;
    }
    t.unshift(SCOPE_TOKEN$1);
  }
}
function compileToken$2(token, options2, context) {
  var _a2;
  token.forEach(sortByProcedure$1);
  context = (_a2 = options2.context) !== null && _a2 !== void 0 ? _a2 : context;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options2.relativeSelector !== false) {
    absolutize$1(token, options2, finalContext);
  } else if (token.some((t) => t.length > 0 && isTraversal$1(t[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  const query = token.map((rules) => {
    if (rules.length >= 2) {
      const [first2, second] = rules;
      if (first2.type !== SelectorType.Pseudo || first2.name !== "scope")
        ;
      else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    return compileRules$1(rules, options2, finalContext);
  }).reduce(reduceRules$1, boolbase.falseFunc);
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function compileRules$1(rules, options2, context) {
  var _a2;
  return rules.reduce((previous, rule) => previous === boolbase.falseFunc ? boolbase.falseFunc : compileGeneralSelector(previous, rule, options2, context, compileToken$2), (_a2 = options2.rootFunc) !== null && _a2 !== void 0 ? _a2 : boolbase.trueFunc);
}
function reduceRules$1(a, b) {
  if (b === boolbase.falseFunc || a === boolbase.trueFunc) {
    return a;
  }
  if (a === boolbase.falseFunc || b === boolbase.trueFunc) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}
const defaultEquals = (a, b) => a === b;
const defaultOptions = {
  adapter: DomUtils$5,
  equals: defaultEquals
};
function convertOptionFormats(options2) {
  var _a2, _b, _c, _d;
  const opts = options2 !== null && options2 !== void 0 ? options2 : defaultOptions;
  (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = DomUtils$5;
  (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
  return opts;
}
function wrapCompile(func) {
  return function addAdapter(selector, options2, context) {
    const opts = convertOptionFormats(options2);
    return func(selector, opts, context);
  };
}
const _compileToken = wrapCompile(compileToken$2);
function prepareContext(elems, adapter2, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter2);
  }
  return Array.isArray(elems) ? adapter2.removeSubsets(elems) : adapter2.getChildren(elems);
}
function appendNextSiblings(elem, adapter2) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i2 = 0; i2 < elemsLength; i2++) {
    const nextSiblings = getNextSiblings(elems[i2], adapter2);
    elems.push(...nextSiblings);
  }
  return elems;
}
const filterNames = /* @__PURE__ */ new Set([
  "first",
  "last",
  "eq",
  "gt",
  "nth",
  "lt",
  "even",
  "odd"
]);
function isFilter(s) {
  if (s.type !== "pseudo")
    return false;
  if (filterNames.has(s.name))
    return true;
  if (s.name === "not" && Array.isArray(s.data)) {
    return s.data.some((s2) => s2.some(isFilter));
  }
  return false;
}
function getLimit(filter2, data2, partLimit) {
  const num2 = data2 != null ? parseInt(data2, 10) : NaN;
  switch (filter2) {
    case "first":
      return 1;
    case "nth":
    case "eq":
      return isFinite(num2) ? num2 >= 0 ? num2 + 1 : Infinity : 0;
    case "lt":
      return isFinite(num2) ? num2 >= 0 ? Math.min(num2, partLimit) : Infinity : 0;
    case "gt":
      return isFinite(num2) ? Infinity : 0;
    case "odd":
      return 2 * partLimit;
    case "even":
      return 2 * partLimit - 1;
    case "last":
    case "not":
      return Infinity;
  }
}
function getDocumentRoot(node2) {
  while (node2.parent)
    node2 = node2.parent;
  return node2;
}
function groupSelectors(selectors) {
  const filteredSelectors = [];
  const plainSelectors = [];
  for (const selector of selectors) {
    if (selector.some(isFilter)) {
      filteredSelectors.push(selector);
    } else {
      plainSelectors.push(selector);
    }
  }
  return [plainSelectors, filteredSelectors];
}
const UNIVERSAL_SELECTOR = {
  type: SelectorType.Universal,
  namespace: null
};
const SCOPE_PSEUDO = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function is$2(element2, selector, options2 = {}) {
  return some$1([element2], selector, options2);
}
function some$1(elements, selector, options2 = {}) {
  if (typeof selector === "function")
    return elements.some(selector);
  const [plain, filtered] = groupSelectors(parse$b(selector));
  return plain.length > 0 && elements.some(_compileToken(plain, options2)) || filtered.some((sel) => filterBySelector(sel, elements, options2).length > 0);
}
function filterByPosition(filter2, elems, data2, options2) {
  const num2 = typeof data2 === "string" ? parseInt(data2, 10) : NaN;
  switch (filter2) {
    case "first":
    case "lt":
      return elems;
    case "last":
      return elems.length > 0 ? [elems[elems.length - 1]] : elems;
    case "nth":
    case "eq":
      return isFinite(num2) && Math.abs(num2) < elems.length ? [num2 < 0 ? elems[elems.length + num2] : elems[num2]] : [];
    case "gt":
      return isFinite(num2) ? elems.slice(num2 + 1) : [];
    case "even":
      return elems.filter((_2, i2) => i2 % 2 === 0);
    case "odd":
      return elems.filter((_2, i2) => i2 % 2 === 1);
    case "not": {
      const filtered = new Set(filterParsed(data2, elems, options2));
      return elems.filter((e) => !filtered.has(e));
    }
  }
}
function filter$3(selector, elements, options2 = {}) {
  return filterParsed(parse$b(selector), elements, options2);
}
function filterParsed(selector, elements, options2) {
  if (elements.length === 0)
    return [];
  const [plainSelectors, filteredSelectors] = groupSelectors(selector);
  let found;
  if (plainSelectors.length) {
    const filtered = filterElements(elements, plainSelectors, options2);
    if (filteredSelectors.length === 0) {
      return filtered;
    }
    if (filtered.length) {
      found = new Set(filtered);
    }
  }
  for (let i2 = 0; i2 < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i2++) {
    const filteredSelector = filteredSelectors[i2];
    const missing = found ? elements.filter((e) => isTag$6(e) && !found.has(e)) : elements;
    if (missing.length === 0)
      break;
    const filtered = filterBySelector(filteredSelector, elements, options2);
    if (filtered.length) {
      if (!found) {
        if (i2 === filteredSelectors.length - 1) {
          return filtered;
        }
        found = new Set(filtered);
      } else {
        filtered.forEach((el2) => found.add(el2));
      }
    }
  }
  return typeof found !== "undefined" ? found.size === elements.length ? elements : (
    // Filter elements to preserve order
    elements.filter((el2) => found.has(el2))
  ) : [];
}
function filterBySelector(selector, elements, options2) {
  var _a2;
  if (selector.some(isTraversal$2)) {
    const root2 = (_a2 = options2.root) !== null && _a2 !== void 0 ? _a2 : getDocumentRoot(elements[0]);
    const opts = { ...options2, context: elements, relativeSelector: false };
    selector.push(SCOPE_PSEUDO);
    return findFilterElements(root2, selector, opts, true, elements.length);
  }
  return findFilterElements(elements, selector, options2, false, elements.length);
}
function select(selector, root2, options2 = {}, limit = Infinity) {
  if (typeof selector === "function") {
    return find$2(root2, selector);
  }
  const [plain, filtered] = groupSelectors(parse$b(selector));
  const results = filtered.map((sel) => findFilterElements(root2, sel, options2, true, limit));
  if (plain.length) {
    results.push(findElements(root2, plain, options2, limit));
  }
  if (results.length === 0) {
    return [];
  }
  if (results.length === 1) {
    return results[0];
  }
  return uniqueSort(results.reduce((a, b) => [...a, ...b]));
}
function findFilterElements(root2, selector, options2, queryForSelector, totalLimit) {
  const filterIndex = selector.findIndex(isFilter);
  const sub2 = selector.slice(0, filterIndex);
  const filter2 = selector[filterIndex];
  const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
  const limit = getLimit(filter2.name, filter2.data, partLimit);
  if (limit === 0)
    return [];
  const elemsNoLimit = sub2.length === 0 && !Array.isArray(root2) ? getChildren$5(root2).filter(isTag$6) : sub2.length === 0 ? (Array.isArray(root2) ? root2 : [root2]).filter(isTag$6) : queryForSelector || sub2.some(isTraversal$2) ? findElements(root2, [sub2], options2, limit) : filterElements(root2, [sub2], options2);
  const elems = elemsNoLimit.slice(0, limit);
  let result = filterByPosition(filter2.name, elems, filter2.data, options2);
  if (result.length === 0 || selector.length === filterIndex + 1) {
    return result;
  }
  const remainingSelector = selector.slice(filterIndex + 1);
  const remainingHasTraversal = remainingSelector.some(isTraversal$2);
  if (remainingHasTraversal) {
    if (isTraversal$2(remainingSelector[0])) {
      const { type } = remainingSelector[0];
      if (type === SelectorType.Sibling || type === SelectorType.Adjacent) {
        result = prepareContext(result, DomUtils$5, true);
      }
      remainingSelector.unshift(UNIVERSAL_SELECTOR);
    }
    options2 = {
      ...options2,
      // Avoid absolutizing the selector
      relativeSelector: false,
      /*
       * Add a custom root func, to make sure traversals don't match elements
       * that aren't a part of the considered tree.
       */
      rootFunc: (el2) => result.includes(el2)
    };
  } else if (options2.rootFunc && options2.rootFunc !== boolbase.trueFunc) {
    options2 = { ...options2, rootFunc: boolbase.trueFunc };
  }
  return remainingSelector.some(isFilter) ? findFilterElements(result, remainingSelector, options2, false, totalLimit) : remainingHasTraversal ? (
    // Query existing elements to resolve traversal.
    findElements(result, [remainingSelector], options2, totalLimit)
  ) : (
    // If we don't have any more traversals, simply filter elements.
    filterElements(result, [remainingSelector], options2)
  );
}
function findElements(root2, sel, options2, limit) {
  const query = _compileToken(sel, options2, root2);
  return find$2(root2, query, limit);
}
function find$2(root2, query, limit = Infinity) {
  const elems = prepareContext(root2, DomUtils$5, query.shouldTestNextSiblings);
  return find$3((node2) => isTag$6(node2) && query(node2), elems, true, limit);
}
function filterElements(elements, sel, options2) {
  const els2 = (Array.isArray(elements) ? elements : [elements]).filter(isTag$6);
  if (els2.length === 0)
    return els2;
  const query = _compileToken(sel, options2);
  return query === boolbase.trueFunc ? els2 : els2.filter(query);
}
const reSiblingSelector = /^\s*[~+]/;
function find$1(selectorOrHaystack) {
  var _a2;
  if (!selectorOrHaystack) {
    return this._make([]);
  }
  const context = this.toArray();
  if (typeof selectorOrHaystack !== "string") {
    const haystack = isCheerio(selectorOrHaystack) ? selectorOrHaystack.toArray() : [selectorOrHaystack];
    return this._make(haystack.filter((elem) => context.some((node2) => contains(node2, elem))));
  }
  const elems = reSiblingSelector.test(selectorOrHaystack) ? context : this.children().toArray();
  const options2 = {
    context,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0],
    // Pass options that are recognized by `cheerio-select`
    xmlMode: this.options.xmlMode,
    lowerCaseTags: this.options.lowerCaseTags,
    lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
    pseudos: this.options.pseudos,
    quirksMode: this.options.quirksMode
  };
  return this._make(select(selectorOrHaystack, elems, options2));
}
function _getMatcher(matchMap) {
  return function(fn, ...postFns) {
    return function(selector) {
      var _a2;
      let matched = matchMap(fn, this);
      if (selector) {
        matched = filterArray(matched, selector, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]);
      }
      return this._make(
        // Post processing is only necessary if there is more than one element.
        this.length > 1 && matched.length > 1 ? postFns.reduce((elems, fn2) => fn2(elems), matched) : matched
      );
    };
  };
}
const _matcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i2 = 0; i2 < elems.length; i2++) {
    const value = fn(elems[i2]);
    ret.push(value);
  }
  return new Array().concat(...ret);
});
const _singleMatcher = _getMatcher((fn, elems) => {
  const ret = [];
  for (let i2 = 0; i2 < elems.length; i2++) {
    const value = fn(elems[i2]);
    if (value !== null) {
      ret.push(value);
    }
  }
  return ret;
});
function _matchUntil(nextElem, ...postFns) {
  let matches = null;
  const innerMatcher = _getMatcher((nextElem2, elems) => {
    const matched = [];
    domEach$1(elems, (elem) => {
      for (let next2; next2 = nextElem2(elem); elem = next2) {
        if (matches === null || matches === void 0 ? void 0 : matches(next2, matched.length))
          break;
        matched.push(next2);
      }
    });
    return matched;
  })(nextElem, ...postFns);
  return function(selector, filterSelector) {
    matches = typeof selector === "string" ? (elem) => is$2(elem, selector, this.options) : selector ? getFilterFn(selector) : null;
    const ret = innerMatcher.call(this, filterSelector);
    matches = null;
    return ret;
  };
}
function _removeDuplicates(elems) {
  return Array.from(new Set(elems));
}
const parent$1 = _singleMatcher(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, _removeDuplicates);
const parents = _matcher((elem) => {
  const matched = [];
  while (elem.parent && !isDocument(elem.parent)) {
    matched.push(elem.parent);
    elem = elem.parent;
  }
  return matched;
}, uniqueSort, (elems) => elems.reverse());
const parentsUntil = _matchUntil(({ parent: parent2 }) => parent2 && !isDocument(parent2) ? parent2 : null, uniqueSort, (elems) => elems.reverse());
function closest(selector) {
  var _a2;
  const set = [];
  if (!selector) {
    return this._make(set);
  }
  const selectOpts = {
    xmlMode: this.options.xmlMode,
    root: (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]
  };
  const selectFn = typeof selector === "string" ? (elem) => is$2(elem, selector, selectOpts) : getFilterFn(selector);
  domEach$1(this, (elem) => {
    while (elem && isTag$6(elem)) {
      if (selectFn(elem, 0)) {
        if (!set.includes(elem)) {
          set.push(elem);
        }
        break;
      }
      elem = elem.parent;
    }
  });
  return this._make(set);
}
const next = _singleMatcher((elem) => nextElementSibling(elem));
const nextAll = _matcher((elem) => {
  const matched = [];
  while (elem.next) {
    elem = elem.next;
    if (isTag$6(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
const nextUntil = _matchUntil((el2) => nextElementSibling(el2), _removeDuplicates);
const prev = _singleMatcher((elem) => prevElementSibling(elem));
const prevAll = _matcher((elem) => {
  const matched = [];
  while (elem.prev) {
    elem = elem.prev;
    if (isTag$6(elem))
      matched.push(elem);
  }
  return matched;
}, _removeDuplicates);
const prevUntil = _matchUntil((el2) => prevElementSibling(el2), _removeDuplicates);
const siblings = _matcher((elem) => getSiblings$2(elem).filter((el2) => isTag$6(el2) && el2 !== elem), uniqueSort);
const children = _matcher((elem) => getChildren$5(elem).filter(isTag$6), _removeDuplicates);
function contents() {
  const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
  return this._make(elems);
}
function each(fn) {
  let i2 = 0;
  const len = this.length;
  while (i2 < len && fn.call(this[i2], i2, this[i2]) !== false)
    ++i2;
  return this;
}
function map$2(fn) {
  let elems = [];
  for (let i2 = 0; i2 < this.length; i2++) {
    const el2 = this[i2];
    const val2 = fn.call(el2, i2, el2);
    if (val2 != null) {
      elems = elems.concat(val2);
    }
  }
  return this._make(elems);
}
function getFilterFn(match) {
  if (typeof match === "function") {
    return (el2, i2) => match.call(el2, i2, el2);
  }
  if (isCheerio(match)) {
    return (el2) => Array.prototype.includes.call(match, el2);
  }
  return function(el2) {
    return match === el2;
  };
}
function filter$2(match) {
  var _a2;
  return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a2 = this._root) === null || _a2 === void 0 ? void 0 : _a2[0]));
}
function filterArray(nodes, match, xmlMode, root2) {
  return typeof match === "string" ? filter$3(match, nodes, { xmlMode, root: root2 }) : nodes.filter(getFilterFn(match));
}
function is$1(selector) {
  const nodes = this.toArray();
  return typeof selector === "string" ? some$1(nodes.filter(isTag$6), selector, this.options) : selector ? nodes.some(getFilterFn(selector)) : false;
}
function not$2(match) {
  let nodes = this.toArray();
  if (typeof match === "string") {
    const matches = new Set(filter$3(match, nodes, this.options));
    nodes = nodes.filter((el2) => !matches.has(el2));
  } else {
    const filterFn = getFilterFn(match);
    nodes = nodes.filter((el2, i2) => !filterFn(el2, i2));
  }
  return this._make(nodes);
}
function has(selectorOrHaystack) {
  return this.filter(typeof selectorOrHaystack === "string" ? (
    // Using the `:has` selector here short-circuits searches.
    `:has(${selectorOrHaystack})`
  ) : (_2, el2) => this._make(el2).find(selectorOrHaystack).length > 0);
}
function first() {
  return this.length > 1 ? this._make(this[0]) : this;
}
function last() {
  return this.length > 0 ? this._make(this[this.length - 1]) : this;
}
function eq$7(i2) {
  var _a2;
  i2 = +i2;
  if (i2 === 0 && this.length <= 1)
    return this;
  if (i2 < 0)
    i2 = this.length + i2;
  return this._make((_a2 = this[i2]) !== null && _a2 !== void 0 ? _a2 : []);
}
function get$2(i2) {
  if (i2 == null) {
    return this.toArray();
  }
  return this[i2 < 0 ? this.length + i2 : i2];
}
function toArray() {
  return Array.prototype.slice.call(this);
}
function index(selectorOrNeedle) {
  let $haystack;
  let needle;
  if (selectorOrNeedle == null) {
    $haystack = this.parent().children();
    needle = this[0];
  } else if (typeof selectorOrNeedle === "string") {
    $haystack = this._make(selectorOrNeedle);
    needle = this[0];
  } else {
    $haystack = this;
    needle = isCheerio(selectorOrNeedle) ? selectorOrNeedle[0] : selectorOrNeedle;
  }
  return Array.prototype.indexOf.call($haystack, needle);
}
function slice(start, end2) {
  return this._make(Array.prototype.slice.call(this, start, end2));
}
function end() {
  var _a2;
  return (_a2 = this.prevObject) !== null && _a2 !== void 0 ? _a2 : this._make([]);
}
function add(other, context) {
  const selection = this._make(other, context);
  const contents2 = uniqueSort([...this.get(), ...selection.get()]);
  return this._make(contents2);
}
function addBack(selector) {
  return this.prevObject ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject) : this;
}
const Traversing = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add,
  addBack,
  children,
  closest,
  contents,
  each,
  end,
  eq: eq$7,
  filter: filter$2,
  filterArray,
  find: find$1,
  first,
  get: get$2,
  has,
  index,
  is: is$1,
  last,
  map: map$2,
  next,
  nextAll,
  nextUntil,
  not: not$2,
  parent: parent$1,
  parents,
  parentsUntil,
  prev,
  prevAll,
  prevUntil,
  siblings,
  slice,
  toArray
}, Symbol.toStringTag, { value: "Module" }));
function getParse(parser2) {
  return function parse3(content, options2, isDocument$1, context) {
    if (typeof Buffer !== "undefined" && Buffer.isBuffer(content)) {
      content = content.toString();
    }
    if (typeof content === "string") {
      return parser2(content, options2, isDocument$1, context);
    }
    const doc = content;
    if (!Array.isArray(doc) && isDocument(doc)) {
      return doc;
    }
    const root2 = new Document([]);
    update(doc, root2);
    return root2;
  };
}
function update(newChilds, parent2) {
  const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
  if (parent2) {
    parent2.children = arr;
  } else {
    parent2 = null;
  }
  for (let i2 = 0; i2 < arr.length; i2++) {
    const node2 = arr[i2];
    if (node2.parent && node2.parent.children !== arr) {
      removeElement(node2);
    }
    if (parent2) {
      node2.prev = arr[i2 - 1] || null;
      node2.next = arr[i2 + 1] || null;
    } else {
      node2.prev = node2.next = null;
    }
    node2.parent = parent2;
  }
  return parent2;
}
function _makeDomArray(elem, clone2) {
  if (elem == null) {
    return [];
  }
  if (isCheerio(elem)) {
    return clone2 ? cloneDom(elem.get()) : elem.get();
  }
  if (Array.isArray(elem)) {
    return elem.reduce((newElems, el2) => newElems.concat(this._makeDomArray(el2, clone2)), []);
  }
  if (typeof elem === "string") {
    return this._parse(elem, this.options, false, null).children;
  }
  return clone2 ? cloneDom([elem]) : [elem];
}
function _insert(concatenator) {
  return function(...elems) {
    const lastIdx = this.length - 1;
    return domEach$1(this, (el2, i2) => {
      if (!hasChildren(el2))
        return;
      const domSrc = typeof elems[0] === "function" ? elems[0].call(el2, i2, this._render(el2.children)) : elems;
      const dom = this._makeDomArray(domSrc, i2 < lastIdx);
      concatenator(dom, el2.children, el2);
    });
  };
}
function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent2) {
  var _a2, _b;
  const spliceArgs = [
    spliceIdx,
    spliceCount,
    ...newElems
  ];
  const prev2 = spliceIdx === 0 ? null : array[spliceIdx - 1];
  const next2 = spliceIdx + spliceCount >= array.length ? null : array[spliceIdx + spliceCount];
  for (let idx = 0; idx < newElems.length; ++idx) {
    const node2 = newElems[idx];
    const oldParent = node2.parent;
    if (oldParent) {
      const oldSiblings = oldParent.children;
      const prevIdx = oldSiblings.indexOf(node2);
      if (prevIdx > -1) {
        oldParent.children.splice(prevIdx, 1);
        if (parent2 === oldParent && spliceIdx > prevIdx) {
          spliceArgs[0]--;
        }
      }
    }
    node2.parent = parent2;
    if (node2.prev) {
      node2.prev.next = (_a2 = node2.next) !== null && _a2 !== void 0 ? _a2 : null;
    }
    if (node2.next) {
      node2.next.prev = (_b = node2.prev) !== null && _b !== void 0 ? _b : null;
    }
    node2.prev = idx === 0 ? prev2 : newElems[idx - 1];
    node2.next = idx === newElems.length - 1 ? next2 : newElems[idx + 1];
  }
  if (prev2) {
    prev2.next = newElems[0];
  }
  if (next2) {
    next2.prev = newElems[newElems.length - 1];
  }
  return array.splice(...spliceArgs);
}
function appendTo(target2) {
  const appendTarget = isCheerio(target2) ? target2 : this._make(target2);
  appendTarget.append(this);
  return this;
}
function prependTo(target2) {
  const prependTarget = isCheerio(target2) ? target2 : this._make(target2);
  prependTarget.prepend(this);
  return this;
}
const append = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, children2.length, 0, dom, parent2);
});
const prepend = _insert((dom, children2, parent2) => {
  uniqueSplice(children2, 0, 0, dom, parent2);
});
function _wrap(insert) {
  return function(wrapper) {
    const lastIdx = this.length - 1;
    const lastParent = this.parents().last();
    for (let i2 = 0; i2 < this.length; i2++) {
      const el2 = this[i2];
      const wrap2 = typeof wrapper === "function" ? wrapper.call(el2, i2, el2) : typeof wrapper === "string" && !isHtml(wrapper) ? lastParent.find(wrapper).clone() : wrapper;
      const [wrapperDom] = this._makeDomArray(wrap2, i2 < lastIdx);
      if (!wrapperDom || !hasChildren(wrapperDom))
        continue;
      let elInsertLocation = wrapperDom;
      let j2 = 0;
      while (j2 < elInsertLocation.children.length) {
        const child2 = elInsertLocation.children[j2];
        if (isTag$6(child2)) {
          elInsertLocation = child2;
          j2 = 0;
        } else {
          j2++;
        }
      }
      insert(el2, elInsertLocation, [wrapperDom]);
    }
    return this;
  };
}
const wrap$1 = _wrap((el2, elInsertLocation, wrapperDom) => {
  const { parent: parent2 } = el2;
  if (!parent2)
    return;
  const siblings2 = parent2.children;
  const index2 = siblings2.indexOf(el2);
  update([el2], elInsertLocation);
  uniqueSplice(siblings2, index2, 0, wrapperDom, parent2);
});
const wrapInner = _wrap((el2, elInsertLocation, wrapperDom) => {
  if (!hasChildren(el2))
    return;
  update(el2.children, elInsertLocation);
  update(wrapperDom, el2);
});
function unwrap(selector) {
  this.parent(selector).not("body").each((_2, el2) => {
    this._make(el2).replaceWith(el2.children);
  });
  return this;
}
function wrapAll(wrapper) {
  const el2 = this[0];
  if (el2) {
    const wrap2 = this._make(typeof wrapper === "function" ? wrapper.call(el2, 0, el2) : wrapper).insertBefore(el2);
    let elInsertLocation;
    for (let i2 = 0; i2 < wrap2.length; i2++) {
      if (wrap2[i2].type === "tag")
        elInsertLocation = wrap2[i2];
    }
    let j2 = 0;
    while (elInsertLocation && j2 < elInsertLocation.children.length) {
      const child2 = elInsertLocation.children[j2];
      if (child2.type === "tag") {
        elInsertLocation = child2;
        j2 = 0;
      } else {
        j2++;
      }
    }
    if (elInsertLocation)
      this._make(elInsertLocation).append(this);
  }
  return this;
}
function after(...elems) {
  const lastIdx = this.length - 1;
  return domEach$1(this, (el2, i2) => {
    const { parent: parent2 } = el2;
    if (!hasChildren(el2) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el2);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el2, i2, this._render(el2.children)) : elems;
    const dom = this._makeDomArray(domSrc, i2 < lastIdx);
    uniqueSplice(siblings2, index2 + 1, 0, dom, parent2);
  });
}
function insertAfter(target2) {
  if (typeof target2 === "string") {
    target2 = this._make(target2);
  }
  this.remove();
  const clones = [];
  this._makeDomArray(target2).forEach((el2) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el2;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el2);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2 + 1, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function before(...elems) {
  const lastIdx = this.length - 1;
  return domEach$1(this, (el2, i2) => {
    const { parent: parent2 } = el2;
    if (!hasChildren(el2) || !parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el2);
    if (index2 < 0)
      return;
    const domSrc = typeof elems[0] === "function" ? elems[0].call(el2, i2, this._render(el2.children)) : elems;
    const dom = this._makeDomArray(domSrc, i2 < lastIdx);
    uniqueSplice(siblings2, index2, 0, dom, parent2);
  });
}
function insertBefore$2(target2) {
  const targetArr = this._make(target2);
  this.remove();
  const clones = [];
  domEach$1(targetArr, (el2) => {
    const clonedSelf = this.clone().toArray();
    const { parent: parent2 } = el2;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const index2 = siblings2.indexOf(el2);
    if (index2 < 0)
      return;
    uniqueSplice(siblings2, index2, 0, clonedSelf, parent2);
    clones.push(...clonedSelf);
  });
  return this._make(clones);
}
function remove(selector) {
  const elems = selector ? this.filter(selector) : this;
  domEach$1(elems, (el2) => {
    removeElement(el2);
    el2.prev = el2.next = el2.parent = null;
  });
  return this;
}
function replaceWith(content) {
  return domEach$1(this, (el2, i2) => {
    const { parent: parent2 } = el2;
    if (!parent2) {
      return;
    }
    const siblings2 = parent2.children;
    const cont = typeof content === "function" ? content.call(el2, i2, el2) : content;
    const dom = this._makeDomArray(cont);
    update(dom, null);
    const index2 = siblings2.indexOf(el2);
    uniqueSplice(siblings2, index2, 1, dom, parent2);
    if (!dom.includes(el2)) {
      el2.parent = el2.prev = el2.next = null;
    }
  });
}
function empty$1() {
  return domEach$1(this, (el2) => {
    if (!hasChildren(el2))
      return;
    el2.children.forEach((child2) => {
      child2.next = child2.prev = child2.parent = null;
    });
    el2.children.length = 0;
  });
}
function html$1(str) {
  if (str === void 0) {
    const el2 = this[0];
    if (!el2 || !hasChildren(el2))
      return null;
    return this._render(el2.children);
  }
  return domEach$1(this, (el2) => {
    if (!hasChildren(el2))
      return;
    el2.children.forEach((child2) => {
      child2.next = child2.prev = child2.parent = null;
    });
    const content = isCheerio(str) ? str.toArray() : this._parse(`${str}`, this.options, false, el2).children;
    update(content, el2);
  });
}
function toString$3() {
  return this._render(this);
}
function text(str) {
  if (str === void 0) {
    return text$1(this);
  }
  if (typeof str === "function") {
    return domEach$1(this, (el2, i2) => this._make(el2).text(str.call(el2, i2, text$1([el2]))));
  }
  return domEach$1(this, (el2) => {
    if (!hasChildren(el2))
      return;
    el2.children.forEach((child2) => {
      child2.next = child2.prev = child2.parent = null;
    });
    const textNode = new Text(`${str}`);
    update(textNode, el2);
  });
}
function clone() {
  return this._make(cloneDom(this.get()));
}
const Manipulation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _makeDomArray,
  after,
  append,
  appendTo,
  before,
  clone,
  empty: empty$1,
  html: html$1,
  insertAfter,
  insertBefore: insertBefore$2,
  prepend,
  prependTo,
  remove,
  replaceWith,
  text,
  toString: toString$3,
  unwrap,
  wrap: wrap$1,
  wrapAll,
  wrapInner
}, Symbol.toStringTag, { value: "Module" }));
function css$1(prop2, val2) {
  if (prop2 != null && val2 != null || // When `prop` is a "plain" object
  typeof prop2 === "object" && !Array.isArray(prop2)) {
    return domEach$1(this, (el2, i2) => {
      if (isTag$6(el2)) {
        setCss$1(el2, prop2, val2, i2);
      }
    });
  }
  if (this.length === 0) {
    return void 0;
  }
  return getCss$1(this[0], prop2);
}
function setCss$1(el2, prop2, value, idx) {
  if (typeof prop2 === "string") {
    const styles = getCss$1(el2);
    const val2 = typeof value === "function" ? value.call(el2, idx, styles[prop2]) : value;
    if (val2 === "") {
      delete styles[prop2];
    } else if (val2 != null) {
      styles[prop2] = val2;
    }
    el2.attribs["style"] = stringify$2(styles);
  } else if (typeof prop2 === "object") {
    Object.keys(prop2).forEach((k, i2) => {
      setCss$1(el2, k, prop2[k], i2);
    });
  }
}
function getCss$1(el2, prop2) {
  if (!el2 || !isTag$6(el2))
    return;
  const styles = parse$9(el2.attribs["style"]);
  if (typeof prop2 === "string") {
    return styles[prop2];
  }
  if (Array.isArray(prop2)) {
    const newStyles = {};
    prop2.forEach((item) => {
      if (styles[item] != null) {
        newStyles[item] = styles[item];
      }
    });
    return newStyles;
  }
  return styles;
}
function stringify$2(obj) {
  return Object.keys(obj).reduce((str, prop2) => `${str}${str ? " " : ""}${prop2}: ${obj[prop2]};`, "");
}
function parse$9(styles) {
  styles = (styles || "").trim();
  if (!styles)
    return {};
  const obj = {};
  let key;
  for (const str of styles.split(";")) {
    const n = str.indexOf(":");
    if (n < 1 || n === str.length - 1) {
      const trimmed = str.trimEnd();
      if (trimmed.length > 0 && key !== void 0) {
        obj[key] += `;${trimmed}`;
      }
    } else {
      key = str.slice(0, n).trim();
      obj[key] = str.slice(n + 1).trim();
    }
  }
  return obj;
}
const Css = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  css: css$1
}, Symbol.toStringTag, { value: "Module" }));
const submittableSelector$1 = "input,select,textarea,keygen";
const r20$1 = /%20/g;
const rCRLF$1 = /\r?\n/g;
function serialize() {
  const arr = this.serializeArray();
  const retArr = arr.map((data2) => `${encodeURIComponent(data2.name)}=${encodeURIComponent(data2.value)}`);
  return retArr.join("&").replace(r20$1, "+");
}
function serializeArray() {
  return this.map((_2, elem) => {
    const $elem = this._make(elem);
    if (isTag$6(elem) && elem.name === "form") {
      return $elem.find(submittableSelector$1).toArray();
    }
    return $elem.filter(submittableSelector$1).toArray();
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
    '[name!=""]:enabled:not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
  ).map((_2, elem) => {
    var _a2;
    const $elem = this._make(elem);
    const name2 = $elem.attr("name");
    const value = (_a2 = $elem.val()) !== null && _a2 !== void 0 ? _a2 : "";
    if (Array.isArray(value)) {
      return value.map((val2) => (
        /*
         * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
         * These can occur inside of `<textarea>'s`
         */
        { name: name2, value: val2.replace(rCRLF$1, "\r\n") }
      ));
    }
    return { name: name2, value: value.replace(rCRLF$1, "\r\n") };
  }).toArray();
}
const Forms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  serialize,
  serializeArray
}, Symbol.toStringTag, { value: "Module" }));
class Cheerio {
  /**
   * Instance of cheerio. Methods are specified in the modules. Usage of this
   * constructor is not recommended. Please use `$.load` instead.
   *
   * @private
   * @param elements - The new selection.
   * @param root - Sets the root node.
   * @param options - Options for the instance.
   */
  constructor(elements, root2, options2) {
    this.length = 0;
    this.options = options2;
    this._root = root2;
    if (elements) {
      for (let idx = 0; idx < elements.length; idx++) {
        this[idx] = elements[idx];
      }
      this.length = elements.length;
    }
  }
}
Cheerio.prototype.cheerio = "[cheerio object]";
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);
function getLoad(parse3, render2) {
  return function load2(content, options2, isDocument2 = true) {
    if (content == null) {
      throw new Error("cheerio.load() expects a string");
    }
    const internalOpts = { ...defaultOpts$3, ...flatten$2(options2) };
    const initialRoot = parse3(content, internalOpts, isDocument2, null);
    class LoadedCheerio extends Cheerio {
      _make(selector, context) {
        const cheerio2 = initialize(selector, context);
        cheerio2.prevObject = this;
        return cheerio2;
      }
      _parse(content2, options3, isDocument3, context) {
        return parse3(content2, options3, isDocument3, context);
      }
      _render(dom) {
        return render2(dom, this.options);
      }
    }
    function initialize(selector, context, root2 = initialRoot, opts) {
      if (selector && isCheerio(selector))
        return selector;
      const options3 = {
        ...internalOpts,
        ...flatten$2(opts)
      };
      const r = typeof root2 === "string" ? [parse3(root2, options3, false, null)] : "length" in root2 ? root2 : [root2];
      const rootInstance = isCheerio(r) ? r : new LoadedCheerio(r, null, options3);
      rootInstance._root = rootInstance;
      if (!selector) {
        return new LoadedCheerio(void 0, rootInstance, options3);
      }
      const elements = typeof selector === "string" && isHtml(selector) ? (
        // $(<html>)
        parse3(selector, options3, false, null).children
      ) : isNode(selector) ? (
        // $(dom)
        [selector]
      ) : Array.isArray(selector) ? (
        // $([dom])
        selector
      ) : void 0;
      const instance = new LoadedCheerio(elements, rootInstance, options3);
      if (elements) {
        return instance;
      }
      if (typeof selector !== "string") {
        throw new Error("Unexpected type of selector");
      }
      let search = selector;
      const searchContext = !context ? (
        // If we don't have a context, maybe we have a root, from loading
        rootInstance
      ) : typeof context === "string" ? isHtml(context) ? (
        // $('li', '<ul>...</ul>')
        new LoadedCheerio([parse3(context, options3, false, null)], rootInstance, options3)
      ) : (
        // $('li', 'ul')
        (search = `${context} ${search}`, rootInstance)
      ) : isCheerio(context) ? (
        // $('li', $)
        context
      ) : (
        // $('li', node), $('li', [nodes])
        new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options3)
      );
      if (!searchContext)
        return instance;
      return searchContext.find(search);
    }
    Object.assign(initialize, staticMethods, {
      load: load2,
      // `_root` and `_options` are used in static methods.
      _root: initialRoot,
      _options: internalOpts,
      // Add `fn` for plugins
      fn: LoadedCheerio.prototype,
      // Add the prototype here to maintain `instanceof` behavior.
      prototype: LoadedCheerio.prototype
    });
    return initialize;
  };
}
function isNode(obj) {
  return !!obj.name || obj.type === "root" || obj.type === "text" || obj.type === "comment";
}
const UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
const REPLACEMENT_CHARACTER = "ï¿½";
var CODE_POINTS;
(function(CODE_POINTS2) {
  CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
  CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
  CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
  CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
  CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
  CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
  CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
  CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
  CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
  CODE_POINTS2[CODE_POINTS2["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
  CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
  CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
  CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
  CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
  CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
  CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
  CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
  CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
  CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
  CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
  CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
  CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
  CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
  CODE_POINTS2[CODE_POINTS2["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
})(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
const SEQUENCES = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function isSurrogate(cp) {
  return cp >= 55296 && cp <= 57343;
}
function isSurrogatePair$1(cp) {
  return cp >= 56320 && cp <= 57343;
}
function getSurrogatePairCodePoint$1(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
function isControlCodePoint(cp) {
  return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
}
function isUndefinedCodePoint(cp) {
  return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
}
var ERR;
(function(ERR2) {
  ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
  ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
  ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
  ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
  ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
  ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
  ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
  ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
  ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
  ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
  ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
  ERR2["missingEndTagName"] = "missing-end-tag-name";
  ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
  ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
  ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
  ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
  ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
  ERR2["eofBeforeTagName"] = "eof-before-tag-name";
  ERR2["eofInTag"] = "eof-in-tag";
  ERR2["missingAttributeValue"] = "missing-attribute-value";
  ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
  ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
  ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
  ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
  ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
  ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
  ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
  ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
  ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
  ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
  ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
  ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
  ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
  ERR2["eofInDoctype"] = "eof-in-doctype";
  ERR2["nestedComment"] = "nested-comment";
  ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
  ERR2["eofInComment"] = "eof-in-comment";
  ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
  ERR2["eofInCdata"] = "eof-in-cdata";
  ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
  ERR2["nullCharacterReference"] = "null-character-reference";
  ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
  ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
  ERR2["controlCharacterReference"] = "control-character-reference";
  ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
  ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
  ERR2["missingDoctypeName"] = "missing-doctype-name";
  ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
  ERR2["duplicateAttribute"] = "duplicate-attribute";
  ERR2["nonConformingDoctype"] = "non-conforming-doctype";
  ERR2["missingDoctype"] = "missing-doctype";
  ERR2["misplacedDoctype"] = "misplaced-doctype";
  ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
  ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
  ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
  ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
  ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
  ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
  ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
  ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
})(ERR = ERR || (ERR = {}));
const DEFAULT_BUFFER_WATERLINE$1 = 1 << 16;
let Preprocessor$2 = class Preprocessor {
  constructor(handler) {
    this.handler = handler;
    this.html = "";
    this.pos = -1;
    this.lastGapPos = -2;
    this.gapStack = [];
    this.skipNextNewLine = false;
    this.lastChunkWritten = false;
    this.endOfChunkHit = false;
    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE$1;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.line = 1;
    this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(code) {
    const { line, col, offset } = this;
    return {
      code,
      startLine: line,
      endLine: line,
      startCol: col,
      endCol: col,
      startOffset: offset,
      endOffset: offset
    };
  }
  _err(code) {
    if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
      this.lastErrOffset = this.offset;
      this.handler.onParseError(this.getError(code));
    }
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos);
    this.lastGapPos = this.pos;
  }
  _processSurrogate(cp) {
    if (this.pos !== this.html.length - 1) {
      const nextCp = this.html.charCodeAt(this.pos + 1);
      if (isSurrogatePair$1(nextCp)) {
        this.pos++;
        this._addGap();
        return getSurrogatePairCodePoint$1(cp, nextCp);
      }
    } else if (!this.lastChunkWritten) {
      this.endOfChunkHit = true;
      return CODE_POINTS.EOF;
    }
    this._err(ERR.surrogateInInputStream);
    return cp;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    if (this.willDropParsedChunk()) {
      this.html = this.html.substring(this.pos);
      this.lineStartPos -= this.pos;
      this.droppedBufferSize += this.pos;
      this.pos = 0;
      this.lastGapPos = -2;
      this.gapStack.length = 0;
    }
  }
  write(chunk, isLastChunk) {
    if (this.html.length > 0) {
      this.html += chunk;
    } else {
      this.html = chunk;
    }
    this.endOfChunkHit = false;
    this.lastChunkWritten = isLastChunk;
  }
  insertHtmlAtCurrentPos(chunk) {
    this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
    this.endOfChunkHit = false;
  }
  startsWith(pattern, caseSensitive) {
    if (this.pos + pattern.length > this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return false;
    }
    if (caseSensitive) {
      return this.html.startsWith(pattern, this.pos);
    }
    for (let i2 = 0; i2 < pattern.length; i2++) {
      const cp = this.html.charCodeAt(this.pos + i2) | 32;
      if (cp !== pattern.charCodeAt(i2)) {
        return false;
      }
    }
    return true;
  }
  peek(offset) {
    const pos = this.pos + offset;
    if (pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    const code = this.html.charCodeAt(pos);
    return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
  }
  advance() {
    this.pos++;
    if (this.isEol) {
      this.isEol = false;
      this.line++;
      this.lineStartPos = this.pos;
    }
    if (this.pos >= this.html.length) {
      this.endOfChunkHit = !this.lastChunkWritten;
      return CODE_POINTS.EOF;
    }
    let cp = this.html.charCodeAt(this.pos);
    if (cp === CODE_POINTS.CARRIAGE_RETURN) {
      this.isEol = true;
      this.skipNextNewLine = true;
      return CODE_POINTS.LINE_FEED;
    }
    if (cp === CODE_POINTS.LINE_FEED) {
      this.isEol = true;
      if (this.skipNextNewLine) {
        this.line--;
        this.skipNextNewLine = false;
        this._addGap();
        return this.advance();
      }
    }
    this.skipNextNewLine = false;
    if (isSurrogate(cp)) {
      cp = this._processSurrogate(cp);
    }
    const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
    if (!isCommonValidRange) {
      this._checkForProblematicCharacters(cp);
    }
    return cp;
  }
  _checkForProblematicCharacters(cp) {
    if (isControlCodePoint(cp)) {
      this._err(ERR.controlCharacterInInputStream);
    } else if (isUndefinedCodePoint(cp)) {
      this._err(ERR.noncharacterInInputStream);
    }
  }
  retreat(count) {
    this.pos -= count;
    while (this.pos < this.lastGapPos) {
      this.lastGapPos = this.gapStack.pop();
      this.pos--;
    }
    this.isEol = false;
  }
};
var TokenType;
(function(TokenType2) {
  TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
  TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
  TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
  TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
  TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
  TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
  TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
  TokenType2[TokenType2["EOF"] = 7] = "EOF";
  TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
})(TokenType = TokenType || (TokenType = {}));
function getTokenAttr(token, attrName) {
  for (let i2 = token.attrs.length - 1; i2 >= 0; i2--) {
    if (token.attrs[i2].name === attrName) {
      return token.attrs[i2].value;
    }
  }
  return null;
}
var NS$6;
(function(NS2) {
  NS2["HTML"] = "http://www.w3.org/1999/xhtml";
  NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
  NS2["SVG"] = "http://www.w3.org/2000/svg";
  NS2["XLINK"] = "http://www.w3.org/1999/xlink";
  NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
  NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
})(NS$6 = NS$6 || (NS$6 = {}));
var ATTRS$2;
(function(ATTRS2) {
  ATTRS2["TYPE"] = "type";
  ATTRS2["ACTION"] = "action";
  ATTRS2["ENCODING"] = "encoding";
  ATTRS2["PROMPT"] = "prompt";
  ATTRS2["NAME"] = "name";
  ATTRS2["COLOR"] = "color";
  ATTRS2["FACE"] = "face";
  ATTRS2["SIZE"] = "size";
})(ATTRS$2 = ATTRS$2 || (ATTRS$2 = {}));
var DOCUMENT_MODE$3;
(function(DOCUMENT_MODE2) {
  DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
  DOCUMENT_MODE2["QUIRKS"] = "quirks";
  DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
})(DOCUMENT_MODE$3 = DOCUMENT_MODE$3 || (DOCUMENT_MODE$3 = {}));
var TAG_NAMES;
(function(TAG_NAMES2) {
  TAG_NAMES2["A"] = "a";
  TAG_NAMES2["ADDRESS"] = "address";
  TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
  TAG_NAMES2["APPLET"] = "applet";
  TAG_NAMES2["AREA"] = "area";
  TAG_NAMES2["ARTICLE"] = "article";
  TAG_NAMES2["ASIDE"] = "aside";
  TAG_NAMES2["B"] = "b";
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BASEFONT"] = "basefont";
  TAG_NAMES2["BGSOUND"] = "bgsound";
  TAG_NAMES2["BIG"] = "big";
  TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["BR"] = "br";
  TAG_NAMES2["BUTTON"] = "button";
  TAG_NAMES2["CAPTION"] = "caption";
  TAG_NAMES2["CENTER"] = "center";
  TAG_NAMES2["CODE"] = "code";
  TAG_NAMES2["COL"] = "col";
  TAG_NAMES2["COLGROUP"] = "colgroup";
  TAG_NAMES2["DD"] = "dd";
  TAG_NAMES2["DESC"] = "desc";
  TAG_NAMES2["DETAILS"] = "details";
  TAG_NAMES2["DIALOG"] = "dialog";
  TAG_NAMES2["DIR"] = "dir";
  TAG_NAMES2["DIV"] = "div";
  TAG_NAMES2["DL"] = "dl";
  TAG_NAMES2["DT"] = "dt";
  TAG_NAMES2["EM"] = "em";
  TAG_NAMES2["EMBED"] = "embed";
  TAG_NAMES2["FIELDSET"] = "fieldset";
  TAG_NAMES2["FIGCAPTION"] = "figcaption";
  TAG_NAMES2["FIGURE"] = "figure";
  TAG_NAMES2["FONT"] = "font";
  TAG_NAMES2["FOOTER"] = "footer";
  TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
  TAG_NAMES2["FORM"] = "form";
  TAG_NAMES2["FRAME"] = "frame";
  TAG_NAMES2["FRAMESET"] = "frameset";
  TAG_NAMES2["H1"] = "h1";
  TAG_NAMES2["H2"] = "h2";
  TAG_NAMES2["H3"] = "h3";
  TAG_NAMES2["H4"] = "h4";
  TAG_NAMES2["H5"] = "h5";
  TAG_NAMES2["H6"] = "h6";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HEADER"] = "header";
  TAG_NAMES2["HGROUP"] = "hgroup";
  TAG_NAMES2["HR"] = "hr";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["I"] = "i";
  TAG_NAMES2["IMG"] = "img";
  TAG_NAMES2["IMAGE"] = "image";
  TAG_NAMES2["INPUT"] = "input";
  TAG_NAMES2["IFRAME"] = "iframe";
  TAG_NAMES2["KEYGEN"] = "keygen";
  TAG_NAMES2["LABEL"] = "label";
  TAG_NAMES2["LI"] = "li";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["LISTING"] = "listing";
  TAG_NAMES2["MAIN"] = "main";
  TAG_NAMES2["MALIGNMARK"] = "malignmark";
  TAG_NAMES2["MARQUEE"] = "marquee";
  TAG_NAMES2["MATH"] = "math";
  TAG_NAMES2["MENU"] = "menu";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["MGLYPH"] = "mglyph";
  TAG_NAMES2["MI"] = "mi";
  TAG_NAMES2["MO"] = "mo";
  TAG_NAMES2["MN"] = "mn";
  TAG_NAMES2["MS"] = "ms";
  TAG_NAMES2["MTEXT"] = "mtext";
  TAG_NAMES2["NAV"] = "nav";
  TAG_NAMES2["NOBR"] = "nobr";
  TAG_NAMES2["NOFRAMES"] = "noframes";
  TAG_NAMES2["NOEMBED"] = "noembed";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["OBJECT"] = "object";
  TAG_NAMES2["OL"] = "ol";
  TAG_NAMES2["OPTGROUP"] = "optgroup";
  TAG_NAMES2["OPTION"] = "option";
  TAG_NAMES2["P"] = "p";
  TAG_NAMES2["PARAM"] = "param";
  TAG_NAMES2["PLAINTEXT"] = "plaintext";
  TAG_NAMES2["PRE"] = "pre";
  TAG_NAMES2["RB"] = "rb";
  TAG_NAMES2["RP"] = "rp";
  TAG_NAMES2["RT"] = "rt";
  TAG_NAMES2["RTC"] = "rtc";
  TAG_NAMES2["RUBY"] = "ruby";
  TAG_NAMES2["S"] = "s";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["SECTION"] = "section";
  TAG_NAMES2["SELECT"] = "select";
  TAG_NAMES2["SOURCE"] = "source";
  TAG_NAMES2["SMALL"] = "small";
  TAG_NAMES2["SPAN"] = "span";
  TAG_NAMES2["STRIKE"] = "strike";
  TAG_NAMES2["STRONG"] = "strong";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["SUB"] = "sub";
  TAG_NAMES2["SUMMARY"] = "summary";
  TAG_NAMES2["SUP"] = "sup";
  TAG_NAMES2["TABLE"] = "table";
  TAG_NAMES2["TBODY"] = "tbody";
  TAG_NAMES2["TEMPLATE"] = "template";
  TAG_NAMES2["TEXTAREA"] = "textarea";
  TAG_NAMES2["TFOOT"] = "tfoot";
  TAG_NAMES2["TD"] = "td";
  TAG_NAMES2["TH"] = "th";
  TAG_NAMES2["THEAD"] = "thead";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["TR"] = "tr";
  TAG_NAMES2["TRACK"] = "track";
  TAG_NAMES2["TT"] = "tt";
  TAG_NAMES2["U"] = "u";
  TAG_NAMES2["UL"] = "ul";
  TAG_NAMES2["SVG"] = "svg";
  TAG_NAMES2["VAR"] = "var";
  TAG_NAMES2["WBR"] = "wbr";
  TAG_NAMES2["XMP"] = "xmp";
})(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
var TAG_ID;
(function(TAG_ID2) {
  TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
  TAG_ID2[TAG_ID2["A"] = 1] = "A";
  TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
  TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
  TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
  TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
  TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
  TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
  TAG_ID2[TAG_ID2["B"] = 8] = "B";
  TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
  TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
  TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
  TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
  TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
  TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
  TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
  TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
  TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
  TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
  TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
  TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
  TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
  TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
  TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
  TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
  TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
  TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
  TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
  TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
  TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
  TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
  TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
  TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
  TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
  TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
  TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
  TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
  TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
  TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
  TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
  TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
  TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
  TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
  TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
  TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
  TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
  TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
  TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
  TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
  TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
  TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
  TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
  TAG_ID2[TAG_ID2["I"] = 52] = "I";
  TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
  TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
  TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
  TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
  TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
  TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
  TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
  TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
  TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
  TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
  TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
  TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
  TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
  TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
  TAG_ID2[TAG_ID2["META"] = 67] = "META";
  TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
  TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
  TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
  TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
  TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
  TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
  TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
  TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
  TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
  TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
  TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
  TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
  TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
  TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
  TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
  TAG_ID2[TAG_ID2["P"] = 83] = "P";
  TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
  TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
  TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
  TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
  TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
  TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
  TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
  TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
  TAG_ID2[TAG_ID2["S"] = 92] = "S";
  TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
  TAG_ID2[TAG_ID2["SECTION"] = 94] = "SECTION";
  TAG_ID2[TAG_ID2["SELECT"] = 95] = "SELECT";
  TAG_ID2[TAG_ID2["SOURCE"] = 96] = "SOURCE";
  TAG_ID2[TAG_ID2["SMALL"] = 97] = "SMALL";
  TAG_ID2[TAG_ID2["SPAN"] = 98] = "SPAN";
  TAG_ID2[TAG_ID2["STRIKE"] = 99] = "STRIKE";
  TAG_ID2[TAG_ID2["STRONG"] = 100] = "STRONG";
  TAG_ID2[TAG_ID2["STYLE"] = 101] = "STYLE";
  TAG_ID2[TAG_ID2["SUB"] = 102] = "SUB";
  TAG_ID2[TAG_ID2["SUMMARY"] = 103] = "SUMMARY";
  TAG_ID2[TAG_ID2["SUP"] = 104] = "SUP";
  TAG_ID2[TAG_ID2["TABLE"] = 105] = "TABLE";
  TAG_ID2[TAG_ID2["TBODY"] = 106] = "TBODY";
  TAG_ID2[TAG_ID2["TEMPLATE"] = 107] = "TEMPLATE";
  TAG_ID2[TAG_ID2["TEXTAREA"] = 108] = "TEXTAREA";
  TAG_ID2[TAG_ID2["TFOOT"] = 109] = "TFOOT";
  TAG_ID2[TAG_ID2["TD"] = 110] = "TD";
  TAG_ID2[TAG_ID2["TH"] = 111] = "TH";
  TAG_ID2[TAG_ID2["THEAD"] = 112] = "THEAD";
  TAG_ID2[TAG_ID2["TITLE"] = 113] = "TITLE";
  TAG_ID2[TAG_ID2["TR"] = 114] = "TR";
  TAG_ID2[TAG_ID2["TRACK"] = 115] = "TRACK";
  TAG_ID2[TAG_ID2["TT"] = 116] = "TT";
  TAG_ID2[TAG_ID2["U"] = 117] = "U";
  TAG_ID2[TAG_ID2["UL"] = 118] = "UL";
  TAG_ID2[TAG_ID2["SVG"] = 119] = "SVG";
  TAG_ID2[TAG_ID2["VAR"] = 120] = "VAR";
  TAG_ID2[TAG_ID2["WBR"] = 121] = "WBR";
  TAG_ID2[TAG_ID2["XMP"] = 122] = "XMP";
})(TAG_ID = TAG_ID || (TAG_ID = {}));
const TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
  [TAG_NAMES.A, TAG_ID.A],
  [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
  [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
  [TAG_NAMES.APPLET, TAG_ID.APPLET],
  [TAG_NAMES.AREA, TAG_ID.AREA],
  [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
  [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
  [TAG_NAMES.B, TAG_ID.B],
  [TAG_NAMES.BASE, TAG_ID.BASE],
  [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
  [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
  [TAG_NAMES.BIG, TAG_ID.BIG],
  [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
  [TAG_NAMES.BODY, TAG_ID.BODY],
  [TAG_NAMES.BR, TAG_ID.BR],
  [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
  [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
  [TAG_NAMES.CENTER, TAG_ID.CENTER],
  [TAG_NAMES.CODE, TAG_ID.CODE],
  [TAG_NAMES.COL, TAG_ID.COL],
  [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
  [TAG_NAMES.DD, TAG_ID.DD],
  [TAG_NAMES.DESC, TAG_ID.DESC],
  [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
  [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
  [TAG_NAMES.DIR, TAG_ID.DIR],
  [TAG_NAMES.DIV, TAG_ID.DIV],
  [TAG_NAMES.DL, TAG_ID.DL],
  [TAG_NAMES.DT, TAG_ID.DT],
  [TAG_NAMES.EM, TAG_ID.EM],
  [TAG_NAMES.EMBED, TAG_ID.EMBED],
  [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
  [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
  [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
  [TAG_NAMES.FONT, TAG_ID.FONT],
  [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
  [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
  [TAG_NAMES.FORM, TAG_ID.FORM],
  [TAG_NAMES.FRAME, TAG_ID.FRAME],
  [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
  [TAG_NAMES.H1, TAG_ID.H1],
  [TAG_NAMES.H2, TAG_ID.H2],
  [TAG_NAMES.H3, TAG_ID.H3],
  [TAG_NAMES.H4, TAG_ID.H4],
  [TAG_NAMES.H5, TAG_ID.H5],
  [TAG_NAMES.H6, TAG_ID.H6],
  [TAG_NAMES.HEAD, TAG_ID.HEAD],
  [TAG_NAMES.HEADER, TAG_ID.HEADER],
  [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
  [TAG_NAMES.HR, TAG_ID.HR],
  [TAG_NAMES.HTML, TAG_ID.HTML],
  [TAG_NAMES.I, TAG_ID.I],
  [TAG_NAMES.IMG, TAG_ID.IMG],
  [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
  [TAG_NAMES.INPUT, TAG_ID.INPUT],
  [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
  [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
  [TAG_NAMES.LABEL, TAG_ID.LABEL],
  [TAG_NAMES.LI, TAG_ID.LI],
  [TAG_NAMES.LINK, TAG_ID.LINK],
  [TAG_NAMES.LISTING, TAG_ID.LISTING],
  [TAG_NAMES.MAIN, TAG_ID.MAIN],
  [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
  [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
  [TAG_NAMES.MATH, TAG_ID.MATH],
  [TAG_NAMES.MENU, TAG_ID.MENU],
  [TAG_NAMES.META, TAG_ID.META],
  [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
  [TAG_NAMES.MI, TAG_ID.MI],
  [TAG_NAMES.MO, TAG_ID.MO],
  [TAG_NAMES.MN, TAG_ID.MN],
  [TAG_NAMES.MS, TAG_ID.MS],
  [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
  [TAG_NAMES.NAV, TAG_ID.NAV],
  [TAG_NAMES.NOBR, TAG_ID.NOBR],
  [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
  [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
  [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
  [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
  [TAG_NAMES.OL, TAG_ID.OL],
  [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
  [TAG_NAMES.OPTION, TAG_ID.OPTION],
  [TAG_NAMES.P, TAG_ID.P],
  [TAG_NAMES.PARAM, TAG_ID.PARAM],
  [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
  [TAG_NAMES.PRE, TAG_ID.PRE],
  [TAG_NAMES.RB, TAG_ID.RB],
  [TAG_NAMES.RP, TAG_ID.RP],
  [TAG_NAMES.RT, TAG_ID.RT],
  [TAG_NAMES.RTC, TAG_ID.RTC],
  [TAG_NAMES.RUBY, TAG_ID.RUBY],
  [TAG_NAMES.S, TAG_ID.S],
  [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
  [TAG_NAMES.SECTION, TAG_ID.SECTION],
  [TAG_NAMES.SELECT, TAG_ID.SELECT],
  [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
  [TAG_NAMES.SMALL, TAG_ID.SMALL],
  [TAG_NAMES.SPAN, TAG_ID.SPAN],
  [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
  [TAG_NAMES.STRONG, TAG_ID.STRONG],
  [TAG_NAMES.STYLE, TAG_ID.STYLE],
  [TAG_NAMES.SUB, TAG_ID.SUB],
  [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
  [TAG_NAMES.SUP, TAG_ID.SUP],
  [TAG_NAMES.TABLE, TAG_ID.TABLE],
  [TAG_NAMES.TBODY, TAG_ID.TBODY],
  [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
  [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
  [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
  [TAG_NAMES.TD, TAG_ID.TD],
  [TAG_NAMES.TH, TAG_ID.TH],
  [TAG_NAMES.THEAD, TAG_ID.THEAD],
  [TAG_NAMES.TITLE, TAG_ID.TITLE],
  [TAG_NAMES.TR, TAG_ID.TR],
  [TAG_NAMES.TRACK, TAG_ID.TRACK],
  [TAG_NAMES.TT, TAG_ID.TT],
  [TAG_NAMES.U, TAG_ID.U],
  [TAG_NAMES.UL, TAG_ID.UL],
  [TAG_NAMES.SVG, TAG_ID.SVG],
  [TAG_NAMES.VAR, TAG_ID.VAR],
  [TAG_NAMES.WBR, TAG_ID.WBR],
  [TAG_NAMES.XMP, TAG_ID.XMP]
]);
function getTagID(tagName) {
  var _a2;
  return (_a2 = TAG_NAME_TO_ID.get(tagName)) !== null && _a2 !== void 0 ? _a2 : TAG_ID.UNKNOWN;
}
const $$b = TAG_ID;
const SPECIAL_ELEMENTS$1 = {
  [NS$6.HTML]: /* @__PURE__ */ new Set([
    $$b.ADDRESS,
    $$b.APPLET,
    $$b.AREA,
    $$b.ARTICLE,
    $$b.ASIDE,
    $$b.BASE,
    $$b.BASEFONT,
    $$b.BGSOUND,
    $$b.BLOCKQUOTE,
    $$b.BODY,
    $$b.BR,
    $$b.BUTTON,
    $$b.CAPTION,
    $$b.CENTER,
    $$b.COL,
    $$b.COLGROUP,
    $$b.DD,
    $$b.DETAILS,
    $$b.DIR,
    $$b.DIV,
    $$b.DL,
    $$b.DT,
    $$b.EMBED,
    $$b.FIELDSET,
    $$b.FIGCAPTION,
    $$b.FIGURE,
    $$b.FOOTER,
    $$b.FORM,
    $$b.FRAME,
    $$b.FRAMESET,
    $$b.H1,
    $$b.H2,
    $$b.H3,
    $$b.H4,
    $$b.H5,
    $$b.H6,
    $$b.HEAD,
    $$b.HEADER,
    $$b.HGROUP,
    $$b.HR,
    $$b.HTML,
    $$b.IFRAME,
    $$b.IMG,
    $$b.INPUT,
    $$b.LI,
    $$b.LINK,
    $$b.LISTING,
    $$b.MAIN,
    $$b.MARQUEE,
    $$b.MENU,
    $$b.META,
    $$b.NAV,
    $$b.NOEMBED,
    $$b.NOFRAMES,
    $$b.NOSCRIPT,
    $$b.OBJECT,
    $$b.OL,
    $$b.P,
    $$b.PARAM,
    $$b.PLAINTEXT,
    $$b.PRE,
    $$b.SCRIPT,
    $$b.SECTION,
    $$b.SELECT,
    $$b.SOURCE,
    $$b.STYLE,
    $$b.SUMMARY,
    $$b.TABLE,
    $$b.TBODY,
    $$b.TD,
    $$b.TEMPLATE,
    $$b.TEXTAREA,
    $$b.TFOOT,
    $$b.TH,
    $$b.THEAD,
    $$b.TITLE,
    $$b.TR,
    $$b.TRACK,
    $$b.UL,
    $$b.WBR,
    $$b.XMP
  ]),
  [NS$6.MATHML]: /* @__PURE__ */ new Set([$$b.MI, $$b.MO, $$b.MN, $$b.MS, $$b.MTEXT, $$b.ANNOTATION_XML]),
  [NS$6.SVG]: /* @__PURE__ */ new Set([$$b.TITLE, $$b.FOREIGN_OBJECT, $$b.DESC]),
  [NS$6.XLINK]: /* @__PURE__ */ new Set(),
  [NS$6.XML]: /* @__PURE__ */ new Set(),
  [NS$6.XMLNS]: /* @__PURE__ */ new Set()
};
function isNumberedHeader(tn) {
  return tn === $$b.H1 || tn === $$b.H2 || tn === $$b.H3 || tn === $$b.H4 || tn === $$b.H5 || tn === $$b.H6;
}
const UNESCAPED_TEXT = /* @__PURE__ */ new Set([
  TAG_NAMES.STYLE,
  TAG_NAMES.SCRIPT,
  TAG_NAMES.XMP,
  TAG_NAMES.IFRAME,
  TAG_NAMES.NOEMBED,
  TAG_NAMES.NOFRAMES,
  TAG_NAMES.PLAINTEXT
]);
function hasUnescapedText(tn, scriptingEnabled) {
  return UNESCAPED_TEXT.has(tn) || scriptingEnabled && tn === TAG_NAMES.NOSCRIPT;
}
const C1_CONTROLS_REFERENCE_REPLACEMENTS = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var State$1;
(function(State2) {
  State2[State2["DATA"] = 0] = "DATA";
  State2[State2["RCDATA"] = 1] = "RCDATA";
  State2[State2["RAWTEXT"] = 2] = "RAWTEXT";
  State2[State2["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
  State2[State2["PLAINTEXT"] = 4] = "PLAINTEXT";
  State2[State2["TAG_OPEN"] = 5] = "TAG_OPEN";
  State2[State2["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
  State2[State2["TAG_NAME"] = 7] = "TAG_NAME";
  State2[State2["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
  State2[State2["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
  State2[State2["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
  State2[State2["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
  State2[State2["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
  State2[State2["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
  State2[State2["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
  State2[State2["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
  State2[State2["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
  State2[State2["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
  State2[State2["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
  State2[State2["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
  State2[State2["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
  State2[State2["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
  State2[State2["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
  State2[State2["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
  State2[State2["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
  State2[State2["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
  State2[State2["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
  State2[State2["COMMENT_START"] = 42] = "COMMENT_START";
  State2[State2["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
  State2[State2["COMMENT"] = 44] = "COMMENT";
  State2[State2["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
  State2[State2["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
  State2[State2["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
  State2[State2["COMMENT_END"] = 50] = "COMMENT_END";
  State2[State2["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
  State2[State2["DOCTYPE"] = 52] = "DOCTYPE";
  State2[State2["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
  State2[State2["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
  State2[State2["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
  State2[State2["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
  State2[State2["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
  State2[State2["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
  State2[State2["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
  State2[State2["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
  State2[State2["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
  State2[State2["CDATA_SECTION"] = 68] = "CDATA_SECTION";
  State2[State2["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
  State2[State2["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
  State2[State2["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
  State2[State2["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
  State2[State2["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
  State2[State2["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
  State2[State2["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
  State2[State2["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
  State2[State2["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(State$1 || (State$1 = {}));
const TokenizerMode = {
  DATA: State$1.DATA,
  RCDATA: State$1.RCDATA,
  RAWTEXT: State$1.RAWTEXT,
  SCRIPT_DATA: State$1.SCRIPT_DATA,
  PLAINTEXT: State$1.PLAINTEXT,
  CDATA_SECTION: State$1.CDATA_SECTION
};
function isAsciiDigit$1(cp) {
  return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
}
function isAsciiUpper$1(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
}
function isAsciiLower$1(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
}
function isAsciiLetter$1(cp) {
  return isAsciiLower$1(cp) || isAsciiUpper$1(cp);
}
function isAsciiAlphaNumeric$1(cp) {
  return isAsciiLetter$1(cp) || isAsciiDigit$1(cp);
}
function isAsciiUpperHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
}
function isAsciiLowerHexDigit(cp) {
  return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
}
function isAsciiHexDigit(cp) {
  return isAsciiDigit$1(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
}
function toAsciiLower(cp) {
  return cp + 32;
}
function isWhitespace$3(cp) {
  return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
}
function isEntityInAttributeInvalidEnd(nextCp) {
  return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric$1(nextCp);
}
function isScriptDataDoubleEscapeSequenceEnd(cp) {
  return isWhitespace$3(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
}
let Tokenizer$a = class Tokenizer {
  constructor(options2, handler) {
    this.options = options2;
    this.handler = handler;
    this.paused = false;
    this.inLoop = false;
    this.inForeignNode = false;
    this.lastStartTagName = "";
    this.active = false;
    this.state = State$1.DATA;
    this.returnState = State$1.DATA;
    this.charRefCode = -1;
    this.consumedAfterSnapshot = -1;
    this.currentCharacterToken = null;
    this.currentToken = null;
    this.currentAttr = { name: "", value: "" };
    this.preprocessor = new Preprocessor$2(handler);
    this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(code) {
    var _a2, _b;
    (_b = (_a2 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a2, this.preprocessor.getError(code));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(offset) {
    if (!this.options.sourceCodeLocationInfo) {
      return null;
    }
    return {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - offset,
      startOffset: this.preprocessor.offset - offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
  }
  _runParsingLoop() {
    if (this.inLoop)
      return;
    this.inLoop = true;
    while (this.active && !this.paused) {
      this.consumedAfterSnapshot = 0;
      const cp = this._consume();
      if (!this._ensureHibernation()) {
        this._callState(cp);
      }
    }
    this.inLoop = false;
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(writeCallback) {
    if (!this.paused) {
      throw new Error("Parser was already resumed");
    }
    this.paused = false;
    if (this.inLoop)
      return;
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  write(chunk, isLastChunk, writeCallback) {
    this.active = true;
    this.preprocessor.write(chunk, isLastChunk);
    this._runParsingLoop();
    if (!this.paused) {
      writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
    }
  }
  insertHtmlAtCurrentPos(chunk) {
    this.active = true;
    this.preprocessor.insertHtmlAtCurrentPos(chunk);
    this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    if (this.preprocessor.endOfChunkHit) {
      this._unconsume(this.consumedAfterSnapshot);
      this.active = false;
      return true;
    }
    return false;
  }
  //Consumption
  _consume() {
    this.consumedAfterSnapshot++;
    return this.preprocessor.advance();
  }
  _unconsume(count) {
    this.consumedAfterSnapshot -= count;
    this.preprocessor.retreat(count);
  }
  _reconsumeInState(state, cp) {
    this.state = state;
    this._callState(cp);
  }
  _advanceBy(count) {
    this.consumedAfterSnapshot += count;
    for (let i2 = 0; i2 < count; i2++) {
      this.preprocessor.advance();
    }
  }
  _consumeSequenceIfMatch(pattern, caseSensitive) {
    if (this.preprocessor.startsWith(pattern, caseSensitive)) {
      this._advanceBy(pattern.length - 1);
      return true;
    }
    return false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: TokenType.START_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: TokenType.END_TAG,
      tagName: "",
      tagID: TAG_ID.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(offset) {
    this.currentToken = {
      type: TokenType.COMMENT,
      data: "",
      location: this.getCurrentLocation(offset)
    };
  }
  _createDoctypeToken(initialName) {
    this.currentToken = {
      type: TokenType.DOCTYPE,
      name: initialName,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(type, chars) {
    this.currentCharacterToken = {
      type,
      chars,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(attrNameFirstCh) {
    this.currentAttr = {
      name: attrNameFirstCh,
      value: ""
    };
    this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var _a2;
    var _b;
    const token = this.currentToken;
    if (getTokenAttr(token, this.currentAttr.name) === null) {
      token.attrs.push(this.currentAttr);
      if (token.location && this.currentLocation) {
        const attrLocations = (_a2 = (_b = token.location).attrs) !== null && _a2 !== void 0 ? _a2 : _b.attrs = /* @__PURE__ */ Object.create(null);
        attrLocations[this.currentAttr.name] = this.currentLocation;
        this._leaveAttrValue();
      }
    } else {
      this._err(ERR.duplicateAttribute);
    }
  }
  _leaveAttrValue() {
    if (this.currentLocation) {
      this.currentLocation.endLine = this.preprocessor.line;
      this.currentLocation.endCol = this.preprocessor.col;
      this.currentLocation.endOffset = this.preprocessor.offset;
    }
  }
  //Token emission
  prepareToken(ct) {
    this._emitCurrentCharacterToken(ct.location);
    this.currentToken = null;
    if (ct.location) {
      ct.location.endLine = this.preprocessor.line;
      ct.location.endCol = this.preprocessor.col + 1;
      ct.location.endOffset = this.preprocessor.offset + 1;
    }
    this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const ct = this.currentToken;
    this.prepareToken(ct);
    ct.tagID = getTagID(ct.tagName);
    if (ct.type === TokenType.START_TAG) {
      this.lastStartTagName = ct.tagName;
      this.handler.onStartTag(ct);
    } else {
      if (ct.attrs.length > 0) {
        this._err(ERR.endTagWithAttributes);
      }
      if (ct.selfClosing) {
        this._err(ERR.endTagWithTrailingSolidus);
      }
      this.handler.onEndTag(ct);
    }
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(ct) {
    this.prepareToken(ct);
    this.handler.onComment(ct);
    this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(ct) {
    this.prepareToken(ct);
    this.handler.onDoctype(ct);
    this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(nextLocation) {
    if (this.currentCharacterToken) {
      if (nextLocation && this.currentCharacterToken.location) {
        this.currentCharacterToken.location.endLine = nextLocation.startLine;
        this.currentCharacterToken.location.endCol = nextLocation.startCol;
        this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
      }
      switch (this.currentCharacterToken.type) {
        case TokenType.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const location = this.getCurrentLocation(0);
    if (location) {
      location.endLine = location.startLine;
      location.endCol = location.startCol;
      location.endOffset = location.startOffset;
    }
    this._emitCurrentCharacterToken(location);
    this.handler.onEof({ type: TokenType.EOF, location });
    this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(type, ch) {
    if (this.currentCharacterToken) {
      if (this.currentCharacterToken.type !== type) {
        this.currentLocation = this.getCurrentLocation(0);
        this._emitCurrentCharacterToken(this.currentLocation);
        this.preprocessor.dropParsedChunk();
      } else {
        this.currentCharacterToken.chars += ch;
        return;
      }
    }
    this._createCharacterToken(type, ch);
  }
  _emitCodePoint(cp) {
    const type = isWhitespace$3(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
    this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(ch) {
    this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
  }
  // Character reference helpers
  _matchNamedCharacterReference(cp) {
    let result = null;
    let excess = 0;
    let withoutSemicolon = false;
    for (let i2 = 0, current = htmlDecodeTree[0]; i2 >= 0; cp = this._consume()) {
      i2 = determineBranch(htmlDecodeTree, current, i2 + 1, cp);
      if (i2 < 0)
        break;
      excess += 1;
      current = htmlDecodeTree[i2];
      const masked = current & BinTrieFlags.VALUE_LENGTH;
      if (masked) {
        const valueLength = (masked >> 14) - 1;
        if (cp !== CODE_POINTS.SEMICOLON && this._isCharacterReferenceInAttribute() && isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))) {
          result = [CODE_POINTS.AMPERSAND];
          i2 += valueLength;
        } else {
          result = valueLength === 0 ? [htmlDecodeTree[i2] & ~BinTrieFlags.VALUE_LENGTH] : valueLength === 1 ? [htmlDecodeTree[++i2]] : [htmlDecodeTree[++i2], htmlDecodeTree[++i2]];
          excess = 0;
          withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
        }
        if (valueLength === 0) {
          this._consume();
          break;
        }
      }
    }
    this._unconsume(excess);
    if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
      this._err(ERR.missingSemicolonAfterCharacterReference);
    }
    this._unconsume(1);
    return result;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State$1.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(cp) {
    if (this._isCharacterReferenceInAttribute()) {
      this.currentAttr.value += String.fromCodePoint(cp);
    } else {
      this._emitCodePoint(cp);
    }
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(cp) {
    switch (this.state) {
      case State$1.DATA: {
        this._stateData(cp);
        break;
      }
      case State$1.RCDATA: {
        this._stateRcdata(cp);
        break;
      }
      case State$1.RAWTEXT: {
        this._stateRawtext(cp);
        break;
      }
      case State$1.SCRIPT_DATA: {
        this._stateScriptData(cp);
        break;
      }
      case State$1.PLAINTEXT: {
        this._statePlaintext(cp);
        break;
      }
      case State$1.TAG_OPEN: {
        this._stateTagOpen(cp);
        break;
      }
      case State$1.END_TAG_OPEN: {
        this._stateEndTagOpen(cp);
        break;
      }
      case State$1.TAG_NAME: {
        this._stateTagName(cp);
        break;
      }
      case State$1.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(cp);
        break;
      }
      case State$1.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(cp);
        break;
      }
      case State$1.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(cp);
        break;
      }
      case State$1.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(cp);
        break;
      }
      case State$1.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(cp);
        break;
      }
      case State$1.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(cp);
        break;
      }
      case State$1.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(cp);
        break;
      }
      case State$1.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(cp);
        break;
      }
      case State$1.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(cp);
        break;
      }
      case State$1.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(cp);
        break;
      }
      case State$1.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(cp);
        break;
      }
      case State$1.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(cp);
        break;
      }
      case State$1.ATTRIBUTE_NAME: {
        this._stateAttributeName(cp);
        break;
      }
      case State$1.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(cp);
        break;
      }
      case State$1.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(cp);
        break;
      }
      case State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(cp);
        break;
      }
      case State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(cp);
        break;
      }
      case State$1.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(cp);
        break;
      }
      case State$1.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(cp);
        break;
      }
      case State$1.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(cp);
        break;
      }
      case State$1.BOGUS_COMMENT: {
        this._stateBogusComment(cp);
        break;
      }
      case State$1.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(cp);
        break;
      }
      case State$1.COMMENT_START: {
        this._stateCommentStart(cp);
        break;
      }
      case State$1.COMMENT_START_DASH: {
        this._stateCommentStartDash(cp);
        break;
      }
      case State$1.COMMENT: {
        this._stateComment(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(cp);
        break;
      }
      case State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(cp);
        break;
      }
      case State$1.COMMENT_END_DASH: {
        this._stateCommentEndDash(cp);
        break;
      }
      case State$1.COMMENT_END: {
        this._stateCommentEnd(cp);
        break;
      }
      case State$1.COMMENT_END_BANG: {
        this._stateCommentEndBang(cp);
        break;
      }
      case State$1.DOCTYPE: {
        this._stateDoctype(cp);
        break;
      }
      case State$1.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case State$1.DOCTYPE_NAME: {
        this._stateDoctypeName(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(cp);
        break;
      }
      case State$1.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(cp);
        break;
      }
      case State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(cp);
        break;
      }
      case State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(cp);
        break;
      }
      case State$1.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(cp);
        break;
      }
      case State$1.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(cp);
        break;
      }
      case State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
        break;
      }
      case State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(cp);
        break;
      }
      case State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(cp);
        break;
      }
      case State$1.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(cp);
        break;
      }
      case State$1.CDATA_SECTION: {
        this._stateCdataSection(cp);
        break;
      }
      case State$1.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(cp);
        break;
      }
      case State$1.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(cp);
        break;
      }
      case State$1.CHARACTER_REFERENCE: {
        this._stateCharacterReference(cp);
        break;
      }
      case State$1.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(cp);
        break;
      }
      case State$1.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(cp);
        break;
      }
      case State$1.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(cp);
        break;
      }
      case State$1.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(cp);
        break;
      }
      case State$1.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(cp);
        break;
      }
      case State$1.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(cp);
        break;
      }
      case State$1.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(cp);
        break;
      }
      default: {
        throw new Error("Unknown state");
      }
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.TAG_OPEN;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.DATA;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(cp) {
    switch (cp) {
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.RCDATA;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(cp) {
    switch (cp) {
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(cp) {
    switch (cp) {
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(cp) {
    if (isAsciiLetter$1(cp)) {
      this._createStartTagToken();
      this.state = State$1.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.EXCLAMATION_MARK: {
          this.state = State$1.MARKUP_DECLARATION_OPEN;
          break;
        }
        case CODE_POINTS.SOLIDUS: {
          this.state = State$1.END_TAG_OPEN;
          break;
        }
        case CODE_POINTS.QUESTION_MARK: {
          this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken(1);
          this.state = State$1.BOGUS_COMMENT;
          this._stateBogusComment(cp);
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this.state = State$1.DATA;
          this._stateData(cp);
        }
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(cp) {
    if (isAsciiLetter$1(cp)) {
      this._createEndTagToken();
      this.state = State$1.TAG_NAME;
      this._stateTagName(cp);
    } else
      switch (cp) {
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingEndTagName);
          this.state = State$1.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
          break;
        }
        default: {
          this._err(ERR.invalidFirstCharacterOfTagName);
          this._createCommentToken(2);
          this.state = State$1.BOGUS_COMMENT;
          this._stateBogusComment(cp);
        }
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State$1.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.tagName += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        token.tagName += String.fromCodePoint(isAsciiUpper$1(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.RCDATA_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State$1.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(cp) {
    if (isAsciiLetter$1(cp)) {
      this.state = State$1.RCDATA_END_TAG_NAME;
      this._stateRcdataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.RCDATA;
      this._stateRcdata(cp);
    }
  }
  handleSpecialEndTag(_cp) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
      return !this._ensureHibernation();
    }
    this._createEndTagToken();
    const token = this.currentToken;
    token.tagName = this.lastStartTagName;
    const cp = this.preprocessor.peek(this.lastStartTagName.length);
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        return false;
      }
      case CODE_POINTS.SOLIDUS: {
        this._advanceBy(this.lastStartTagName.length);
        this.state = State$1.SELF_CLOSING_START_TAG;
        return false;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._advanceBy(this.lastStartTagName.length);
        this.emitCurrentTagToken();
        this.state = State$1.DATA;
        return false;
      }
      default: {
        return !this._ensureHibernation();
      }
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.RCDATA;
      this._stateRcdata(cp);
    }
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.RAWTEXT_END_TAG_OPEN;
    } else {
      this._emitChars("<");
      this.state = State$1.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(cp) {
    if (isAsciiLetter$1(cp)) {
      this.state = State$1.RAWTEXT_END_TAG_NAME;
      this._stateRawtextEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.RAWTEXT;
      this._stateRawtext(cp);
    }
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(cp) {
    switch (cp) {
      case CODE_POINTS.SOLIDUS: {
        this.state = State$1.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State$1.SCRIPT_DATA_ESCAPE_START;
        this._emitChars("<!");
        break;
      }
      default: {
        this._emitChars("<");
        this.state = State$1.SCRIPT_DATA;
        this._stateScriptData(cp);
      }
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(cp) {
    if (isAsciiLetter$1(cp)) {
      this.state = State$1.SCRIPT_DATA_END_TAG_NAME;
      this._stateScriptDataEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.SCRIPT_DATA_ESCAPE_START_DASH;
      this._emitChars("-");
    } else {
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.SCRIPT_DATA_ESCAPED_DASH_DASH;
      this._emitChars("-");
    } else {
      this.state = State$1.SCRIPT_DATA;
      this._stateScriptData(cp);
    }
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
    } else if (isAsciiLetter$1(cp)) {
      this._emitChars("<");
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPE_START;
      this._stateScriptDataDoubleEscapeStart(cp);
    } else {
      this._emitChars("<");
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(cp) {
    if (isAsciiLetter$1(cp)) {
      this.state = State$1.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
      this._stateScriptDataEscapedEndTagName(cp);
    } else {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(cp) {
    if (this.handleSpecialEndTag(cp)) {
      this._emitChars("</");
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i2 = 0; i2 < SEQUENCES.SCRIPT.length; i2++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State$1.SCRIPT_DATA_ESCAPED;
      this._stateScriptDataEscaped(cp);
    }
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
        this._emitChars("<");
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.SCRIPT_DATA;
        this._emitChars(">");
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitChars(REPLACEMENT_CHARACTER);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInScriptHtmlCommentLikeText);
        this._emitEOFToken();
        break;
      }
      default: {
        this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
        this._emitCodePoint(cp);
      }
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(cp) {
    if (cp === CODE_POINTS.SOLIDUS) {
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPE_END;
      this._emitChars("/");
    } else {
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(cp) {
    if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
      this._emitCodePoint(cp);
      for (let i2 = 0; i2 < SEQUENCES.SCRIPT.length; i2++) {
        this._emitCodePoint(this._consume());
      }
      this.state = State$1.SCRIPT_DATA_ESCAPED;
    } else if (!this._ensureHibernation()) {
      this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
      this._stateScriptDataDoubleEscaped(cp);
    }
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this.state = State$1.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
        this._createAttr("=");
        this.state = State$1.ATTRIBUTE_NAME;
        break;
      }
      default: {
        this._createAttr("");
        this.state = State$1.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED:
      case CODE_POINTS.SOLIDUS:
      case CODE_POINTS.GREATER_THAN_SIGN:
      case CODE_POINTS.EOF: {
        this._leaveAttrName();
        this.state = State$1.AFTER_ATTRIBUTE_NAME;
        this._stateAfterAttributeName(cp);
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this._leaveAttrName();
        this.state = State$1.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN: {
        this._err(ERR.unexpectedCharacterInAttributeName);
        this.currentAttr.name += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.name += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        this.currentAttr.name += String.fromCodePoint(isAsciiUpper$1(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this.state = State$1.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.EQUALS_SIGN: {
        this.state = State$1.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._createAttr("");
        this.state = State$1.ATTRIBUTE_NAME;
        this._stateAttributeName(cp);
      }
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingAttributeValue);
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      default: {
        this.state = State$1.ATTRIBUTE_VALUE_UNQUOTED;
        this._stateAttributeValueUnquoted(cp);
      }
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.AMPERSAND: {
        this.returnState = State$1.ATTRIBUTE_VALUE_UNQUOTED;
        this.state = State$1.CHARACTER_REFERENCE;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        this.currentAttr.value += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK:
      case CODE_POINTS.APOSTROPHE:
      case CODE_POINTS.LESS_THAN_SIGN:
      case CODE_POINTS.EQUALS_SIGN:
      case CODE_POINTS.GRAVE_ACCENT: {
        this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
        this.currentAttr.value += String.fromCodePoint(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this.currentAttr.value += String.fromCodePoint(cp);
      }
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this._leaveAttrValue();
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case CODE_POINTS.SOLIDUS: {
        this._leaveAttrValue();
        this.state = State$1.SELF_CLOSING_START_TAG;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._leaveAttrValue();
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBetweenAttributes);
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        const token = this.currentToken;
        token.selfClosing = true;
        this.state = State$1.DATA;
        this.emitCurrentTagToken();
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInTag);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedSolidusInTag);
        this.state = State$1.BEFORE_ATTRIBUTE_NAME;
        this._stateBeforeAttributeName(cp);
      }
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(cp) {
    if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
      this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
      this.state = State$1.COMMENT_START;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
      this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
      this.state = State$1.DOCTYPE;
    } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
      if (this.inForeignNode) {
        this.state = State$1.CDATA_SECTION;
      } else {
        this._err(ERR.cdataInHtmlContent);
        this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
        this.currentToken.data = "[CDATA[";
        this.state = State$1.BOGUS_COMMENT;
      }
    } else if (!this._ensureHibernation()) {
      this._err(ERR.incorrectlyOpenedComment);
      this._createCommentToken(2);
      this.state = State$1.BOGUS_COMMENT;
      this._stateBogusComment(cp);
    }
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(cp) {
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_START_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State$1.DATA;
        const token = this.currentToken;
        this.emitCurrentComment(token);
        break;
      }
      default: {
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_END;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptClosingOfEmptyComment);
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        this.state = State$1.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.data += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += String.fromCodePoint(cp);
      }
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.EXCLAMATION_MARK: {
        token.data += "!";
        this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case CODE_POINTS.LESS_THAN_SIGN: {
        token.data += "<";
        break;
      }
      default: {
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH;
    } else {
      this.state = State$1.COMMENT;
      this._stateComment(cp);
    }
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(cp) {
    if (cp === CODE_POINTS.HYPHEN_MINUS) {
      this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
    } else {
      this.state = State$1.COMMENT_END_DASH;
      this._stateCommentEndDash(cp);
    }
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(cp) {
    if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
      this._err(ERR.nestedComment);
    }
    this.state = State$1.COMMENT_END;
    this._stateCommentEnd(cp);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        this.state = State$1.COMMENT_END;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "-";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EXCLAMATION_MARK: {
        this.state = State$1.COMMENT_END_BANG;
        break;
      }
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "-";
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.HYPHEN_MINUS: {
        token.data += "--!";
        this.state = State$1.COMMENT_END_DASH;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.incorrectlyClosedComment);
        this.state = State$1.DATA;
        this.emitCurrentComment(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInComment);
        this.emitCurrentComment(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.data += "--!";
        this.state = State$1.COMMENT;
        this._stateComment(cp);
      }
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(cp) {
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        this._createDoctypeToken(null);
        const token = this.currentToken;
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingWhitespaceBeforeDoctypeName);
        this.state = State$1.BEFORE_DOCTYPE_NAME;
        this._stateBeforeDoctypeName(cp);
      }
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(cp) {
    if (isAsciiUpper$1(cp)) {
      this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
      this.state = State$1.DOCTYPE_NAME;
    } else
      switch (cp) {
        case CODE_POINTS.SPACE:
        case CODE_POINTS.LINE_FEED:
        case CODE_POINTS.TABULATION:
        case CODE_POINTS.FORM_FEED: {
          break;
        }
        case CODE_POINTS.NULL: {
          this._err(ERR.unexpectedNullCharacter);
          this._createDoctypeToken(REPLACEMENT_CHARACTER);
          this.state = State$1.DOCTYPE_NAME;
          break;
        }
        case CODE_POINTS.GREATER_THAN_SIGN: {
          this._err(ERR.missingDoctypeName);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this.state = State$1.DATA;
          break;
        }
        case CODE_POINTS.EOF: {
          this._err(ERR.eofInDoctype);
          this._createDoctypeToken(null);
          const token = this.currentToken;
          token.forceQuirks = true;
          this.emitCurrentDoctype(token);
          this._emitEOFToken();
          break;
        }
        default: {
          this._createDoctypeToken(String.fromCodePoint(cp));
          this.state = State$1.DOCTYPE_NAME;
        }
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.AFTER_DOCTYPE_NAME;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.name += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.name += String.fromCodePoint(isAsciiUpper$1(cp) ? toAsciiLower(cp) : cp);
      }
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
          this.state = State$1.AFTER_DOCTYPE_PUBLIC_KEYWORD;
        } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
          this.state = State$1.AFTER_DOCTYPE_SYSTEM_KEYWORD;
        } else if (!this._ensureHibernation()) {
          this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
          token.forceQuirks = true;
          this.state = State$1.BOGUS_DOCTYPE;
          this._stateBogusDoctype(cp);
        }
      }
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.publicId = "";
        this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.publicId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypePublicIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.publicId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        this.state = State$1.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.QUOTATION_MARK: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case CODE_POINTS.APOSTROPHE: {
        token.systemId = "";
        this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.missingDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.DATA;
        this.emitCurrentDoctype(token);
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.QUOTATION_MARK: {
        this.state = State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.APOSTROPHE: {
        this.state = State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        token.systemId += REPLACEMENT_CHARACTER;
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this._err(ERR.abruptDoctypeSystemIdentifier);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        token.systemId += String.fromCodePoint(cp);
      }
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.SPACE:
      case CODE_POINTS.LINE_FEED:
      case CODE_POINTS.TABULATION:
      case CODE_POINTS.FORM_FEED: {
        break;
      }
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInDoctype);
        token.forceQuirks = true;
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
      default: {
        this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
        this.state = State$1.BOGUS_DOCTYPE;
        this._stateBogusDoctype(cp);
      }
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(cp) {
    const token = this.currentToken;
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(token);
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.NULL: {
        this._err(ERR.unexpectedNullCharacter);
        break;
      }
      case CODE_POINTS.EOF: {
        this.emitCurrentDoctype(token);
        this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(cp) {
    switch (cp) {
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this.state = State$1.CDATA_SECTION_BRACKET;
        break;
      }
      case CODE_POINTS.EOF: {
        this._err(ERR.eofInCdata);
        this._emitEOFToken();
        break;
      }
      default: {
        this._emitCodePoint(cp);
      }
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(cp) {
    if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
      this.state = State$1.CDATA_SECTION_END;
    } else {
      this._emitChars("]");
      this.state = State$1.CDATA_SECTION;
      this._stateCdataSection(cp);
    }
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(cp) {
    switch (cp) {
      case CODE_POINTS.GREATER_THAN_SIGN: {
        this.state = State$1.DATA;
        break;
      }
      case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default: {
        this._emitChars("]]");
        this.state = State$1.CDATA_SECTION;
        this._stateCdataSection(cp);
      }
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(cp) {
    if (cp === CODE_POINTS.NUMBER_SIGN) {
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE;
    } else if (isAsciiAlphaNumeric$1(cp)) {
      this.state = State$1.NAMED_CHARACTER_REFERENCE;
      this._stateNamedCharacterReference(cp);
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(cp) {
    const matchResult = this._matchNamedCharacterReference(cp);
    if (this._ensureHibernation())
      ;
    else if (matchResult) {
      for (let i2 = 0; i2 < matchResult.length; i2++) {
        this._flushCodePointConsumedAsCharacterReference(matchResult[i2]);
      }
      this.state = this.returnState;
    } else {
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this.state = State$1.AMBIGUOUS_AMPERSAND;
    }
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(cp) {
    if (isAsciiAlphaNumeric$1(cp)) {
      this._flushCodePointConsumedAsCharacterReference(cp);
    } else {
      if (cp === CODE_POINTS.SEMICOLON) {
        this._err(ERR.unknownNamedCharacterReference);
      }
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(cp) {
    this.charRefCode = 0;
    if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
      this.state = State$1.HEXADEMICAL_CHARACTER_REFERENCE_START;
    } else if (isAsciiDigit$1(cp)) {
      this.state = State$1.DECIMAL_CHARACTER_REFERENCE;
      this._stateDecimalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._reconsumeInState(this.returnState, cp);
    }
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(cp) {
    if (isAsciiHexDigit(cp)) {
      this.state = State$1.HEXADEMICAL_CHARACTER_REFERENCE;
      this._stateHexademicalCharacterReference(cp);
    } else {
      this._err(ERR.absenceOfDigitsInNumericCharacterReference);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
      this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
      this._unconsume(2);
      this.state = this.returnState;
    }
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(cp) {
    if (isAsciiUpperHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 55;
    } else if (isAsciiLowerHexDigit(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 87;
    } else if (isAsciiDigit$1(cp)) {
      this.charRefCode = this.charRefCode * 16 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(cp) {
    if (isAsciiDigit$1(cp)) {
      this.charRefCode = this.charRefCode * 10 + cp - 48;
    } else if (cp === CODE_POINTS.SEMICOLON) {
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
    } else {
      this._err(ERR.missingSemicolonAfterCharacterReference);
      this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
      this._stateNumericCharacterReferenceEnd(cp);
    }
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(cp) {
    if (this.charRefCode === CODE_POINTS.NULL) {
      this._err(ERR.nullCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (this.charRefCode > 1114111) {
      this._err(ERR.characterReferenceOutsideUnicodeRange);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isSurrogate(this.charRefCode)) {
      this._err(ERR.surrogateCharacterReference);
      this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
    } else if (isUndefinedCodePoint(this.charRefCode)) {
      this._err(ERR.noncharacterCharacterReference);
    } else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
      this._err(ERR.controlCharacterReference);
      const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
      if (replacement !== void 0) {
        this.charRefCode = replacement;
      }
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
    this._reconsumeInState(this.returnState, cp);
  }
};
const IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
  ...IMPLICIT_END_TAG_REQUIRED,
  TAG_ID.CAPTION,
  TAG_ID.COLGROUP,
  TAG_ID.TBODY,
  TAG_ID.TD,
  TAG_ID.TFOOT,
  TAG_ID.TH,
  TAG_ID.THEAD,
  TAG_ID.TR
]);
const SCOPING_ELEMENT_NS = /* @__PURE__ */ new Map([
  [TAG_ID.APPLET, NS$6.HTML],
  [TAG_ID.CAPTION, NS$6.HTML],
  [TAG_ID.HTML, NS$6.HTML],
  [TAG_ID.MARQUEE, NS$6.HTML],
  [TAG_ID.OBJECT, NS$6.HTML],
  [TAG_ID.TABLE, NS$6.HTML],
  [TAG_ID.TD, NS$6.HTML],
  [TAG_ID.TEMPLATE, NS$6.HTML],
  [TAG_ID.TH, NS$6.HTML],
  [TAG_ID.ANNOTATION_XML, NS$6.MATHML],
  [TAG_ID.MI, NS$6.MATHML],
  [TAG_ID.MN, NS$6.MATHML],
  [TAG_ID.MO, NS$6.MATHML],
  [TAG_ID.MS, NS$6.MATHML],
  [TAG_ID.MTEXT, NS$6.MATHML],
  [TAG_ID.DESC, NS$6.SVG],
  [TAG_ID.FOREIGN_OBJECT, NS$6.SVG],
  [TAG_ID.TITLE, NS$6.SVG]
]);
const NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6];
const TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
const TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML];
const TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
const TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
let OpenElementStack$2 = class OpenElementStack {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(document, treeAdapter, handler) {
    this.treeAdapter = treeAdapter;
    this.handler = handler;
    this.items = [];
    this.tagIDs = [];
    this.stackTop = -1;
    this.tmplCount = 0;
    this.currentTagId = TAG_ID.UNKNOWN;
    this.current = document;
  }
  //Index of element
  _indexOf(element2) {
    return this.items.lastIndexOf(element2, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$6.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop];
    this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(element2, tagID) {
    this.stackTop++;
    this.items[this.stackTop] = element2;
    this.current = element2;
    this.tagIDs[this.stackTop] = tagID;
    this.currentTagId = tagID;
    if (this._isInTemplate()) {
      this.tmplCount++;
    }
    this.handler.onItemPush(element2, tagID, true);
  }
  pop() {
    const popped = this.current;
    if (this.tmplCount > 0 && this._isInTemplate()) {
      this.tmplCount--;
    }
    this.stackTop--;
    this._updateCurrentElement();
    this.handler.onItemPop(popped, true);
  }
  replace(oldElement, newElement) {
    const idx = this._indexOf(oldElement);
    this.items[idx] = newElement;
    if (idx === this.stackTop) {
      this.current = newElement;
    }
  }
  insertAfter(referenceElement, newElement, newElementID) {
    const insertionIdx = this._indexOf(referenceElement) + 1;
    this.items.splice(insertionIdx, 0, newElement);
    this.tagIDs.splice(insertionIdx, 0, newElementID);
    this.stackTop++;
    if (insertionIdx === this.stackTop) {
      this._updateCurrentElement();
    }
    this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
  }
  popUntilTagNamePopped(tagName) {
    let targetIdx = this.stackTop + 1;
    do {
      targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
    } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS$6.HTML);
    this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
  }
  shortenToLength(idx) {
    while (this.stackTop >= idx) {
      const popped = this.current;
      if (this.tmplCount > 0 && this._isInTemplate()) {
        this.tmplCount -= 1;
      }
      this.stackTop--;
      this._updateCurrentElement();
      this.handler.onItemPop(popped, this.stackTop < idx);
    }
  }
  popUntilElementPopped(element2) {
    const idx = this._indexOf(element2);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilPopped(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx < 0 ? 0 : idx);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(NAMED_HEADERS, NS$6.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(TABLE_CELLS, NS$6.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0;
    this.shortenToLength(1);
  }
  _indexOfTagNames(tagNames, namespace) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      if (tagNames.includes(this.tagIDs[i2]) && this.treeAdapter.getNamespaceURI(this.items[i2]) === namespace) {
        return i2;
      }
    }
    return -1;
  }
  clearBackTo(tagNames, targetNS) {
    const idx = this._indexOfTagNames(tagNames, targetNS);
    this.shortenToLength(idx + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(TABLE_CONTEXT, NS$6.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(TABLE_BODY_CONTEXT, NS$6.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(TABLE_ROW_CONTEXT, NS$6.HTML);
  }
  remove(element2) {
    const idx = this._indexOf(element2);
    if (idx >= 0) {
      if (idx === this.stackTop) {
        this.pop();
      } else {
        this.items.splice(idx, 1);
        this.tagIDs.splice(idx, 1);
        this.stackTop--;
        this._updateCurrentElement();
        this.handler.onItemPop(element2, false);
      }
    }
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
  }
  contains(element2) {
    return this._indexOf(element2) > -1;
  }
  getCommonAncestor(element2) {
    const elementIdx = this._indexOf(element2) - 1;
    return elementIdx >= 0 ? this.items[elementIdx] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
  }
  //Element in scope
  hasInScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (tn === tagName && ns === NS$6.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (isNumberedHeader(tn) && ns === NS$6.HTML) {
        return true;
      }
      if (SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInListItemScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (tn === tagName && ns === NS$6.HTML) {
        return true;
      }
      if ((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS$6.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInButtonScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (tn === tagName && ns === NS$6.HTML) {
        return true;
      }
      if (tn === TAG_ID.BUTTON && ns === NS$6.HTML || SCOPING_ELEMENT_NS.get(tn) === ns) {
        return false;
      }
    }
    return true;
  }
  hasInTableScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (ns !== NS$6.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (ns !== NS$6.HTML) {
        continue;
      }
      if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
        return true;
      }
      if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
        return false;
      }
    }
    return true;
  }
  hasInSelectScope(tagName) {
    for (let i2 = this.stackTop; i2 >= 0; i2--) {
      const tn = this.tagIDs[i2];
      const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
      if (ns !== NS$6.HTML) {
        continue;
      }
      if (tn === tagName) {
        return true;
      }
      if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
        return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsThoroughly() {
    while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
  generateImpliedEndTagsWithExclusion(exclusionId) {
    while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
      this.pop();
    }
  }
};
const NOAH_ARK_CAPACITY$1 = 3;
var EntryType;
(function(EntryType2) {
  EntryType2[EntryType2["Marker"] = 0] = "Marker";
  EntryType2[EntryType2["Element"] = 1] = "Element";
})(EntryType = EntryType || (EntryType = {}));
const MARKER = { type: EntryType.Marker };
let FormattingElementList$2 = class FormattingElementList {
  constructor(treeAdapter) {
    this.treeAdapter = treeAdapter;
    this.entries = [];
    this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(newElement, neAttrs) {
    const candidates = [];
    const neAttrsLength = neAttrs.length;
    const neTagName = this.treeAdapter.getTagName(newElement);
    const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (let i2 = 0; i2 < this.entries.length; i2++) {
      const entry = this.entries[i2];
      if (entry.type === EntryType.Marker) {
        break;
      }
      const { element: element2 } = entry;
      if (this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI) {
        const elementAttrs = this.treeAdapter.getAttrList(element2);
        if (elementAttrs.length === neAttrsLength) {
          candidates.push({ idx: i2, attrs: elementAttrs });
        }
      }
    }
    return candidates;
  }
  _ensureNoahArkCondition(newElement) {
    if (this.entries.length < NOAH_ARK_CAPACITY$1)
      return;
    const neAttrs = this.treeAdapter.getAttrList(newElement);
    const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
    if (candidates.length < NOAH_ARK_CAPACITY$1)
      return;
    const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
    let validCandidates = 0;
    for (let i2 = 0; i2 < candidates.length; i2++) {
      const candidate = candidates[i2];
      if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
        validCandidates += 1;
        if (validCandidates >= NOAH_ARK_CAPACITY$1) {
          this.entries.splice(candidate.idx, 1);
        }
      }
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(MARKER);
  }
  pushElement(element2, token) {
    this._ensureNoahArkCondition(element2);
    this.entries.unshift({
      type: EntryType.Element,
      element: element2,
      token
    });
  }
  insertElementAfterBookmark(element2, token) {
    const bookmarkIdx = this.entries.indexOf(this.bookmark);
    this.entries.splice(bookmarkIdx, 0, {
      type: EntryType.Element,
      element: element2,
      token
    });
  }
  removeEntry(entry) {
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex >= 0) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const markerIdx = this.entries.indexOf(MARKER);
    if (markerIdx >= 0) {
      this.entries.splice(0, markerIdx + 1);
    } else {
      this.entries.length = 0;
    }
  }
  //Search
  getElementEntryInScopeWithTagName(tagName) {
    const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
    return entry && entry.type === EntryType.Element ? entry : null;
  }
  getElementEntry(element2) {
    return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element2);
  }
};
function createTextNode$3(value) {
  return {
    nodeName: "#text",
    value,
    parentNode: null
  };
}
const defaultTreeAdapter$2 = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: DOCUMENT_MODE$3.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(tagName, namespaceURI, attrs) {
    return {
      nodeName: tagName,
      tagName,
      attrs,
      namespaceURI,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(data2) {
    return {
      nodeName: "#comment",
      data: data2,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    parentNode.childNodes.push(newNode);
    newNode.parentNode = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
    parentNode.childNodes.splice(insertionIdx, 0, newNode);
    newNode.parentNode = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    templateElement.content = contentElement;
  },
  getTemplateContent(templateElement) {
    return templateElement.content;
  },
  setDocumentType(document, name2, publicId, systemId) {
    const doctypeNode = document.childNodes.find((node2) => node2.nodeName === "#documentType");
    if (doctypeNode) {
      doctypeNode.name = name2;
      doctypeNode.publicId = publicId;
      doctypeNode.systemId = systemId;
    } else {
      const node2 = {
        nodeName: "#documentType",
        name: name2,
        publicId,
        systemId,
        parentNode: null
      };
      defaultTreeAdapter$2.appendChild(document, node2);
    }
  },
  setDocumentMode(document, mode) {
    document.mode = mode;
  },
  getDocumentMode(document) {
    return document.mode;
  },
  detachNode(node2) {
    if (node2.parentNode) {
      const idx = node2.parentNode.childNodes.indexOf(node2);
      node2.parentNode.childNodes.splice(idx, 1);
      node2.parentNode = null;
    }
  },
  insertText(parentNode, text2) {
    if (parentNode.childNodes.length > 0) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
      if (defaultTreeAdapter$2.isTextNode(prevNode)) {
        prevNode.value += text2;
        return;
      }
    }
    defaultTreeAdapter$2.appendChild(parentNode, createTextNode$3(text2));
  },
  insertTextBefore(parentNode, text2, referenceNode) {
    const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
    if (prevNode && defaultTreeAdapter$2.isTextNode(prevNode)) {
      prevNode.value += text2;
    } else {
      defaultTreeAdapter$2.insertBefore(parentNode, createTextNode$3(text2), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    const recipientAttrsMap = new Set(recipient.attrs.map((attr2) => attr2.name));
    for (let j2 = 0; j2 < attrs.length; j2++) {
      if (!recipientAttrsMap.has(attrs[j2].name)) {
        recipient.attrs.push(attrs[j2]);
      }
    }
  },
  //Tree traversing
  getFirstChild(node2) {
    return node2.childNodes[0];
  },
  getChildNodes(node2) {
    return node2.childNodes;
  },
  getParentNode(node2) {
    return node2.parentNode;
  },
  getAttrList(element2) {
    return element2.attrs;
  },
  //Node data
  getTagName(element2) {
    return element2.tagName;
  },
  getNamespaceURI(element2) {
    return element2.namespaceURI;
  },
  getTextNodeContent(textNode) {
    return textNode.value;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    return doctypeNode.name;
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    return doctypeNode.publicId;
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    return doctypeNode.systemId;
  },
  //Node types
  isTextNode(node2) {
    return node2.nodeName === "#text";
  },
  isCommentNode(node2) {
    return node2.nodeName === "#comment";
  },
  isDocumentTypeNode(node2) {
    return node2.nodeName === "#documentType";
  },
  isElementNode(node2) {
    return Object.prototype.hasOwnProperty.call(node2, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(node2, location) {
    node2.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node2) {
    return node2.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node2, endLocation) {
    node2.sourceCodeLocation = { ...node2.sourceCodeLocation, ...endLocation };
  }
};
const VALID_DOCTYPE_NAME$1 = "html";
const VALID_SYSTEM_ID = "about:legacy-compat";
const QUIRKS_MODE_SYSTEM_ID$1 = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
const QUIRKS_MODE_PUBLIC_ID_PREFIXES$1 = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES$1 = [
  ...QUIRKS_MODE_PUBLIC_ID_PREFIXES$1,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
const QUIRKS_MODE_PUBLIC_IDS$1 = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES$1 = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES$1 = [
  ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES$1,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function hasPrefix$1(publicId, prefixes) {
  return prefixes.some((prefix) => publicId.startsWith(prefix));
}
function isConforming(token) {
  return token.name === VALID_DOCTYPE_NAME$1 && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
}
function getDocumentMode(token) {
  if (token.name !== VALID_DOCTYPE_NAME$1) {
    return DOCUMENT_MODE$3.QUIRKS;
  }
  const { systemId } = token;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID$1) {
    return DOCUMENT_MODE$3.QUIRKS;
  }
  let { publicId } = token;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS$1.has(publicId)) {
      return DOCUMENT_MODE$3.QUIRKS;
    }
    let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES$1 : QUIRKS_MODE_PUBLIC_ID_PREFIXES$1;
    if (hasPrefix$1(publicId, prefixes)) {
      return DOCUMENT_MODE$3.QUIRKS;
    }
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES$1 : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES$1;
    if (hasPrefix$1(publicId, prefixes)) {
      return DOCUMENT_MODE$3.LIMITED_QUIRKS;
    }
  }
  return DOCUMENT_MODE$3.NO_QUIRKS;
}
const MIME_TYPES$1 = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
const DEFINITION_URL_ATTR$1 = "definitionurl";
const ADJUSTED_DEFINITION_URL_ATTR$1 = "definitionURL";
const SVG_ATTRS_ADJUSTMENT_MAP$1 = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((attr2) => [attr2.toLowerCase(), attr2]));
const XML_ATTRS_ADJUSTMENT_MAP$1 = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS$6.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS$6.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: NS$6.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: NS$6.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: NS$6.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: NS$6.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: NS$6.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: NS$6.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: NS$6.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: NS$6.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: NS$6.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS$6.XMLNS }]
]);
const SVG_TAG_NAMES_ADJUSTMENT_MAP$1 = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((tn) => [tn.toLowerCase(), tn]));
const EXITS_FOREIGN_CONTENT$1 = /* @__PURE__ */ new Set([
  TAG_ID.B,
  TAG_ID.BIG,
  TAG_ID.BLOCKQUOTE,
  TAG_ID.BODY,
  TAG_ID.BR,
  TAG_ID.CENTER,
  TAG_ID.CODE,
  TAG_ID.DD,
  TAG_ID.DIV,
  TAG_ID.DL,
  TAG_ID.DT,
  TAG_ID.EM,
  TAG_ID.EMBED,
  TAG_ID.H1,
  TAG_ID.H2,
  TAG_ID.H3,
  TAG_ID.H4,
  TAG_ID.H5,
  TAG_ID.H6,
  TAG_ID.HEAD,
  TAG_ID.HR,
  TAG_ID.I,
  TAG_ID.IMG,
  TAG_ID.LI,
  TAG_ID.LISTING,
  TAG_ID.MENU,
  TAG_ID.META,
  TAG_ID.NOBR,
  TAG_ID.OL,
  TAG_ID.P,
  TAG_ID.PRE,
  TAG_ID.RUBY,
  TAG_ID.S,
  TAG_ID.SMALL,
  TAG_ID.SPAN,
  TAG_ID.STRONG,
  TAG_ID.STRIKE,
  TAG_ID.SUB,
  TAG_ID.SUP,
  TAG_ID.TABLE,
  TAG_ID.TT,
  TAG_ID.U,
  TAG_ID.UL,
  TAG_ID.VAR
]);
function causesExit(startTagToken) {
  const tn = startTagToken.tagID;
  const isFontWithAttrs = tn === TAG_ID.FONT && startTagToken.attrs.some(({ name: name2 }) => name2 === ATTRS$2.COLOR || name2 === ATTRS$2.SIZE || name2 === ATTRS$2.FACE);
  return isFontWithAttrs || EXITS_FOREIGN_CONTENT$1.has(tn);
}
function adjustTokenMathMLAttrs(token) {
  for (let i2 = 0; i2 < token.attrs.length; i2++) {
    if (token.attrs[i2].name === DEFINITION_URL_ATTR$1) {
      token.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR$1;
      break;
    }
  }
}
function adjustTokenSVGAttrs(token) {
  for (let i2 = 0; i2 < token.attrs.length; i2++) {
    const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP$1.get(token.attrs[i2].name);
    if (adjustedAttrName != null) {
      token.attrs[i2].name = adjustedAttrName;
    }
  }
}
function adjustTokenXMLAttrs(token) {
  for (let i2 = 0; i2 < token.attrs.length; i2++) {
    const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP$1.get(token.attrs[i2].name);
    if (adjustedAttrEntry) {
      token.attrs[i2].prefix = adjustedAttrEntry.prefix;
      token.attrs[i2].name = adjustedAttrEntry.name;
      token.attrs[i2].namespace = adjustedAttrEntry.namespace;
    }
  }
}
function adjustTokenSVGTagName(token) {
  const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP$1.get(token.tagName);
  if (adjustedTagName != null) {
    token.tagName = adjustedTagName;
    token.tagID = getTagID(token.tagName);
  }
}
function isMathMLTextIntegrationPoint$1(tn, ns) {
  return ns === NS$6.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
}
function isHtmlIntegrationPoint$1(tn, ns, attrs) {
  if (ns === NS$6.MATHML && tn === TAG_ID.ANNOTATION_XML) {
    for (let i2 = 0; i2 < attrs.length; i2++) {
      if (attrs[i2].name === ATTRS$2.ENCODING) {
        const value = attrs[i2].value.toLowerCase();
        return value === MIME_TYPES$1.TEXT_HTML || value === MIME_TYPES$1.APPLICATION_XML;
      }
    }
  }
  return ns === NS$6.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
}
function isIntegrationPoint(tn, ns, attrs, foreignNS) {
  return (!foreignNS || foreignNS === NS$6.HTML) && isHtmlIntegrationPoint$1(tn, ns, attrs) || (!foreignNS || foreignNS === NS$6.MATHML) && isMathMLTextIntegrationPoint$1(tn, ns);
}
const HIDDEN_INPUT_TYPE$1 = "hidden";
const AA_OUTER_LOOP_ITER$1 = 8;
const AA_INNER_LOOP_ITER$1 = 3;
var InsertionMode;
(function(InsertionMode2) {
  InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
  InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
  InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
  InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
  InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
  InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
  InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
  InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
  InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
  InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
  InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
  InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
  InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
  InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
  InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
  InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
  InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
  InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
  InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
  InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
})(InsertionMode || (InsertionMode = {}));
const BASE_LOC = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
const TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
const defaultParserOptions = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: defaultTreeAdapter$2,
  onParseError: null
};
let Parser$5 = class Parser {
  constructor(options2, document, fragmentContext = null, scriptHandler = null) {
    this.fragmentContext = fragmentContext;
    this.scriptHandler = scriptHandler;
    this.currentToken = null;
    this.stopped = false;
    this.insertionMode = InsertionMode.INITIAL;
    this.originalInsertionMode = InsertionMode.INITIAL;
    this.headElement = null;
    this.formElement = null;
    this.currentNotInHTML = false;
    this.tmplInsertionModeStack = [];
    this.pendingCharacterTokens = [];
    this.hasNonWhitespacePendingCharacterToken = false;
    this.framesetOk = true;
    this.skipNextNewLine = false;
    this.fosterParentingEnabled = false;
    this.options = {
      ...defaultParserOptions,
      ...options2
    };
    this.treeAdapter = this.options.treeAdapter;
    this.onParseError = this.options.onParseError;
    if (this.onParseError) {
      this.options.sourceCodeLocationInfo = true;
    }
    this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
    this.tokenizer = new Tokenizer$a(this.options, this);
    this.activeFormattingElements = new FormattingElementList$2(this.treeAdapter);
    this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
    this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
    this.openElements = new OpenElementStack$2(this.document, this.treeAdapter, this);
  }
  // API
  static parse(html2, options2) {
    const parser2 = new this(options2);
    parser2.tokenizer.write(html2, true);
    return parser2.document;
  }
  static getFragmentParser(fragmentContext, options2) {
    const opts = {
      ...defaultParserOptions,
      ...options2
    };
    fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS$6.HTML, []);
    const documentMock = opts.treeAdapter.createElement("documentmock", NS$6.HTML, []);
    const parser2 = new this(opts, documentMock, fragmentContext);
    if (parser2.fragmentContextID === TAG_ID.TEMPLATE) {
      parser2.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
    }
    parser2._initTokenizerForFragmentParsing();
    parser2._insertFakeRootElement();
    parser2._resetInsertionMode();
    parser2._findFormInFragmentContext();
    return parser2;
  }
  getFragment() {
    const rootElement = this.treeAdapter.getFirstChild(this.document);
    const fragment = this.treeAdapter.createDocumentFragment();
    this._adoptNodes(rootElement, fragment);
    return fragment;
  }
  //Errors
  _err(token, code, beforeToken) {
    var _a2;
    if (!this.onParseError)
      return;
    const loc = (_a2 = token.location) !== null && _a2 !== void 0 ? _a2 : BASE_LOC;
    const err = {
      code,
      startLine: loc.startLine,
      startCol: loc.startCol,
      startOffset: loc.startOffset,
      endLine: beforeToken ? loc.startLine : loc.endLine,
      endCol: beforeToken ? loc.startCol : loc.endCol,
      endOffset: beforeToken ? loc.startOffset : loc.endOffset
    };
    this.onParseError(err);
  }
  //Stack events
  onItemPush(node2, tid, isTop) {
    var _a2, _b;
    (_b = (_a2 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a2, node2);
    if (isTop && this.openElements.stackTop > 0)
      this._setContextModes(node2, tid);
  }
  onItemPop(node2, isTop) {
    var _a2, _b;
    if (this.options.sourceCodeLocationInfo) {
      this._setEndLocation(node2, this.currentToken);
    }
    (_b = (_a2 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a2, node2, this.openElements.current);
    if (isTop) {
      let current;
      let currentTagId;
      if (this.openElements.stackTop === 0 && this.fragmentContext) {
        current = this.fragmentContext;
        currentTagId = this.fragmentContextID;
      } else {
        ({ current, currentTagId } = this.openElements);
      }
      this._setContextModes(current, currentTagId);
    }
  }
  _setContextModes(current, tid) {
    const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS$6.HTML;
    this.currentNotInHTML = !isHTML;
    this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
  }
  _switchToTextParsing(currentToken, nextTokenizerState) {
    this._insertElement(currentToken, NS$6.HTML);
    this.tokenizer.state = nextTokenizerState;
    this.originalInsertionMode = this.insertionMode;
    this.insertionMode = InsertionMode.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = InsertionMode.TEXT;
    this.originalInsertionMode = InsertionMode.IN_BODY;
    this.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let node2 = this.fragmentContext;
    while (node2) {
      if (this.treeAdapter.getTagName(node2) === TAG_NAMES.FORM) {
        this.formElement = node2;
        break;
      }
      node2 = this.treeAdapter.getParentNode(node2);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS$6.HTML) {
      return;
    }
    switch (this.fragmentContextID) {
      case TAG_ID.TITLE:
      case TAG_ID.TEXTAREA: {
        this.tokenizer.state = TokenizerMode.RCDATA;
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.XMP:
      case TAG_ID.IFRAME:
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES:
      case TAG_ID.NOSCRIPT: {
        this.tokenizer.state = TokenizerMode.RAWTEXT;
        break;
      }
      case TAG_ID.SCRIPT: {
        this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
        break;
      }
      case TAG_ID.PLAINTEXT: {
        this.tokenizer.state = TokenizerMode.PLAINTEXT;
        break;
      }
    }
  }
  //Tree mutation
  _setDocumentType(token) {
    const name2 = token.name || "";
    const publicId = token.publicId || "";
    const systemId = token.systemId || "";
    this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
    if (token.location) {
      const documentChildren = this.treeAdapter.getChildNodes(this.document);
      const docTypeNode = documentChildren.find((node2) => this.treeAdapter.isDocumentTypeNode(node2));
      if (docTypeNode) {
        this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
      }
    }
  }
  _attachElementToTree(element2, location) {
    if (this.options.sourceCodeLocationInfo) {
      const loc = location && {
        ...location,
        startTag: location
      };
      this.treeAdapter.setNodeSourceCodeLocation(element2, loc);
    }
    if (this._shouldFosterParentOnInsertion()) {
      this._fosterParentElement(element2);
    } else {
      const parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(parent2, element2);
    }
  }
  _appendElement(token, namespaceURI) {
    const element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element2, token.location);
  }
  _insertElement(token, namespaceURI) {
    const element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
    this._attachElementToTree(element2, token.location);
    this.openElements.push(element2, token.tagID);
  }
  _insertFakeElement(tagName, tagID) {
    const element2 = this.treeAdapter.createElement(tagName, NS$6.HTML, []);
    this._attachElementToTree(element2, null);
    this.openElements.push(element2, tagID);
  }
  _insertTemplate(token) {
    const tmpl = this.treeAdapter.createElement(token.tagName, NS$6.HTML, token.attrs);
    const content = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(tmpl, content);
    this._attachElementToTree(tmpl, token.location);
    this.openElements.push(tmpl, token.tagID);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(content, null);
  }
  _insertFakeRootElement() {
    const element2 = this.treeAdapter.createElement(TAG_NAMES.HTML, NS$6.HTML, []);
    if (this.options.sourceCodeLocationInfo)
      this.treeAdapter.setNodeSourceCodeLocation(element2, null);
    this.treeAdapter.appendChild(this.openElements.current, element2);
    this.openElements.push(element2, TAG_ID.HTML);
  }
  _appendCommentNode(token, parent2) {
    const commentNode = this.treeAdapter.createCommentNode(token.data);
    this.treeAdapter.appendChild(parent2, commentNode);
    if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
    }
  }
  _insertCharacters(token) {
    let parent2;
    let beforeElement;
    if (this._shouldFosterParentOnInsertion()) {
      ({ parent: parent2, beforeElement } = this._findFosterParentingLocation());
      if (beforeElement) {
        this.treeAdapter.insertTextBefore(parent2, token.chars, beforeElement);
      } else {
        this.treeAdapter.insertText(parent2, token.chars);
      }
    } else {
      parent2 = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.insertText(parent2, token.chars);
    }
    if (!token.location)
      return;
    const siblings2 = this.treeAdapter.getChildNodes(parent2);
    const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
    const textNode = siblings2[textNodeIdx - 1];
    const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
    if (tnLoc) {
      const { endLine, endCol, endOffset } = token.location;
      this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
    } else if (this.options.sourceCodeLocationInfo) {
      this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
    }
  }
  _adoptNodes(donor, recipient) {
    for (let child2 = this.treeAdapter.getFirstChild(donor); child2; child2 = this.treeAdapter.getFirstChild(donor)) {
      this.treeAdapter.detachNode(child2);
      this.treeAdapter.appendChild(recipient, child2);
    }
  }
  _setEndLocation(element2, closingToken) {
    if (this.treeAdapter.getNodeSourceCodeLocation(element2) && closingToken.location) {
      const ctLoc = closingToken.location;
      const tn = this.treeAdapter.getTagName(element2);
      const endLoc = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        closingToken.type === TokenType.END_TAG && tn === closingToken.tagName ? {
          endTag: { ...ctLoc },
          endLine: ctLoc.endLine,
          endCol: ctLoc.endCol,
          endOffset: ctLoc.endOffset
        } : {
          endLine: ctLoc.startLine,
          endCol: ctLoc.startCol,
          endOffset: ctLoc.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(element2, endLoc);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(token) {
    if (!this.currentNotInHTML)
      return false;
    let current;
    let currentTagId;
    if (this.openElements.stackTop === 0 && this.fragmentContext) {
      current = this.fragmentContext;
      currentTagId = this.fragmentContextID;
    } else {
      ({ current, currentTagId } = this.openElements);
    }
    if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS$6.MATHML) {
      return false;
    }
    return (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && !this._isIntegrationPoint(currentTagId, current, NS$6.HTML)
    );
  }
  _processToken(token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        this.onCharacter(token);
        break;
      }
      case TokenType.NULL_CHARACTER: {
        this.onNullCharacter(token);
        break;
      }
      case TokenType.COMMENT: {
        this.onComment(token);
        break;
      }
      case TokenType.DOCTYPE: {
        this.onDoctype(token);
        break;
      }
      case TokenType.START_TAG: {
        this._processStartTag(token);
        break;
      }
      case TokenType.END_TAG: {
        this.onEndTag(token);
        break;
      }
      case TokenType.EOF: {
        this.onEof(token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(token);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(tid, element2, foreignNS) {
    const ns = this.treeAdapter.getNamespaceURI(element2);
    const attrs = this.treeAdapter.getAttrList(element2);
    return isIntegrationPoint(tid, ns, attrs, foreignNS);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const listLength = this.activeFormattingElements.entries.length;
    if (listLength) {
      const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
      const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
      for (let i2 = unopenIdx; i2 >= 0; i2--) {
        const entry = this.activeFormattingElements.entries[i2];
        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
        entry.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags();
    this.openElements.popUntilTableCellPopped();
    this.activeFormattingElements.clearToLastMarker();
    this.insertionMode = InsertionMode.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
    this.openElements.popUntilTagNamePopped(TAG_ID.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
      switch (i2 === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i2]) {
        case TAG_ID.TR: {
          this.insertionMode = InsertionMode.IN_ROW;
          return;
        }
        case TAG_ID.TBODY:
        case TAG_ID.THEAD:
        case TAG_ID.TFOOT: {
          this.insertionMode = InsertionMode.IN_TABLE_BODY;
          return;
        }
        case TAG_ID.CAPTION: {
          this.insertionMode = InsertionMode.IN_CAPTION;
          return;
        }
        case TAG_ID.COLGROUP: {
          this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
          return;
        }
        case TAG_ID.TABLE: {
          this.insertionMode = InsertionMode.IN_TABLE;
          return;
        }
        case TAG_ID.BODY: {
          this.insertionMode = InsertionMode.IN_BODY;
          return;
        }
        case TAG_ID.FRAMESET: {
          this.insertionMode = InsertionMode.IN_FRAMESET;
          return;
        }
        case TAG_ID.SELECT: {
          this._resetInsertionModeForSelect(i2);
          return;
        }
        case TAG_ID.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case TAG_ID.HTML: {
          this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
          return;
        }
        case TAG_ID.TD:
        case TAG_ID.TH: {
          if (i2 > 0) {
            this.insertionMode = InsertionMode.IN_CELL;
            return;
          }
          break;
        }
        case TAG_ID.HEAD: {
          if (i2 > 0) {
            this.insertionMode = InsertionMode.IN_HEAD;
            return;
          }
          break;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_BODY;
  }
  _resetInsertionModeForSelect(selectIdx) {
    if (selectIdx > 0) {
      for (let i2 = selectIdx - 1; i2 > 0; i2--) {
        const tn = this.openElements.tagIDs[i2];
        if (tn === TAG_ID.TEMPLATE) {
          break;
        } else if (tn === TAG_ID.TABLE) {
          this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
          return;
        }
      }
    }
    this.insertionMode = InsertionMode.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(tn) {
    return TABLE_STRUCTURE_TAGS.has(tn);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
      const openElement = this.openElements.items[i2];
      switch (this.openElements.tagIDs[i2]) {
        case TAG_ID.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(openElement) === NS$6.HTML) {
            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
          }
          break;
        }
        case TAG_ID.TABLE: {
          const parent2 = this.treeAdapter.getParentNode(openElement);
          if (parent2) {
            return { parent: parent2, beforeElement: openElement };
          }
          return { parent: this.openElements.items[i2 - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(element2) {
    const location = this._findFosterParentingLocation();
    if (location.beforeElement) {
      this.treeAdapter.insertBefore(location.parent, element2, location.beforeElement);
    } else {
      this.treeAdapter.appendChild(location.parent, element2);
    }
  }
  //Special elements
  _isSpecialElement(element2, id) {
    const ns = this.treeAdapter.getNamespaceURI(element2);
    return SPECIAL_ELEMENTS$1[ns].has(id);
  }
  onCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      characterInForeignContent$1(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead$1(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE: {
        characterInBody$1(this, token);
        break;
      }
      case InsertionMode.TEXT:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        characterInTableText$1(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup$1(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody$1(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody$1(this, token);
        break;
      }
    }
  }
  onNullCharacter(token) {
    this.skipNextNewLine = false;
    if (this.tokenizer.inForeignNode) {
      nullCharacterInForeignContent$1(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead$1(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        tokenInColumnGroup$1(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        tokenAfterBody$1(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody$1(this, token);
        break;
      }
    }
  }
  onComment(token) {
    this.skipNextNewLine = false;
    if (this.currentNotInHTML) {
      appendComment$1(this, token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.INITIAL:
      case InsertionMode.BEFORE_HTML:
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        appendComment$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText$1(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        appendCommentToRootHtmlElement$1(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        appendCommentToDocument$1(this, token);
        break;
      }
    }
  }
  onDoctype(token) {
    this.skipNextNewLine = false;
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        doctypeInInitialMode$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD:
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD: {
        this._err(token, ERR.misplacedDoctype);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText$1(this, token);
        break;
      }
    }
  }
  onStartTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    this._processStartTag(token);
    if (token.selfClosing && !token.ackSelfClosing) {
      this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
    }
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(token) {
    if (this.shouldProcessStartTagTokenInForeignContent(token)) {
      startTagInForeignContent$1(this, token);
    } else {
      this._startTagOutsideForeignContent(token);
    }
  }
  _startTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        startTagBeforeHtml$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        startTagBeforeHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        startTagInHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        startTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        startTagAfterHead$1(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        startTagInBody$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        startTagInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText$1(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        startTagInCaption$1(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        startTagInColumnGroup$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        startTagInTableBody$1(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        startTagInRow$1(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        startTagInCell$1(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        startTagInSelect$1(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        startTagInSelectInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        startTagInTemplate$1(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        startTagAfterBody$1(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        startTagInFrameset$1(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        startTagAfterFrameset$1(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        startTagAfterAfterBody$1(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        startTagAfterAfterFrameset$1(this, token);
        break;
      }
    }
  }
  onEndTag(token) {
    this.skipNextNewLine = false;
    this.currentToken = token;
    if (this.currentNotInHTML) {
      endTagInForeignContent$1(this, token);
    } else {
      this._endTagOutsideForeignContent(token);
    }
  }
  _endTagOutsideForeignContent(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        endTagBeforeHtml$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        endTagBeforeHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        endTagInHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        endTagInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        endTagAfterHead$1(this, token);
        break;
      }
      case InsertionMode.IN_BODY: {
        endTagInBody$1(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        endTagInText$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE: {
        endTagInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText$1(this, token);
        break;
      }
      case InsertionMode.IN_CAPTION: {
        endTagInCaption$1(this, token);
        break;
      }
      case InsertionMode.IN_COLUMN_GROUP: {
        endTagInColumnGroup$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_BODY: {
        endTagInTableBody$1(this, token);
        break;
      }
      case InsertionMode.IN_ROW: {
        endTagInRow$1(this, token);
        break;
      }
      case InsertionMode.IN_CELL: {
        endTagInCell$1(this, token);
        break;
      }
      case InsertionMode.IN_SELECT: {
        endTagInSelect$1(this, token);
        break;
      }
      case InsertionMode.IN_SELECT_IN_TABLE: {
        endTagInSelectInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        endTagInTemplate$1(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY: {
        endTagAfterBody$1(this, token);
        break;
      }
      case InsertionMode.IN_FRAMESET: {
        endTagInFrameset$1(this, token);
        break;
      }
      case InsertionMode.AFTER_FRAMESET: {
        endTagAfterFrameset$1(this, token);
        break;
      }
      case InsertionMode.AFTER_AFTER_BODY: {
        tokenAfterAfterBody$1(this, token);
        break;
      }
    }
  }
  onEof(token) {
    switch (this.insertionMode) {
      case InsertionMode.INITIAL: {
        tokenInInitialMode$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HTML: {
        tokenBeforeHtml$1(this, token);
        break;
      }
      case InsertionMode.BEFORE_HEAD: {
        tokenBeforeHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD: {
        tokenInHead$1(this, token);
        break;
      }
      case InsertionMode.IN_HEAD_NO_SCRIPT: {
        tokenInHeadNoScript(this, token);
        break;
      }
      case InsertionMode.AFTER_HEAD: {
        tokenAfterHead$1(this, token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE: {
        eofInBody$1(this, token);
        break;
      }
      case InsertionMode.TEXT: {
        eofInText$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        tokenInTableText$1(this, token);
        break;
      }
      case InsertionMode.IN_TEMPLATE: {
        eofInTemplate$1(this, token);
        break;
      }
      case InsertionMode.AFTER_BODY:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        stopParsing$1(this, token);
        break;
      }
    }
  }
  onWhitespaceCharacter(token) {
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
        if (token.chars.length === 1) {
          return;
        }
        token.chars = token.chars.substr(1);
      }
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(token);
      return;
    }
    switch (this.insertionMode) {
      case InsertionMode.IN_HEAD:
      case InsertionMode.IN_HEAD_NO_SCRIPT:
      case InsertionMode.AFTER_HEAD:
      case InsertionMode.TEXT:
      case InsertionMode.IN_COLUMN_GROUP:
      case InsertionMode.IN_SELECT:
      case InsertionMode.IN_SELECT_IN_TABLE:
      case InsertionMode.IN_FRAMESET:
      case InsertionMode.AFTER_FRAMESET: {
        this._insertCharacters(token);
        break;
      }
      case InsertionMode.IN_BODY:
      case InsertionMode.IN_CAPTION:
      case InsertionMode.IN_CELL:
      case InsertionMode.IN_TEMPLATE:
      case InsertionMode.AFTER_BODY:
      case InsertionMode.AFTER_AFTER_BODY:
      case InsertionMode.AFTER_AFTER_FRAMESET: {
        whitespaceCharacterInBody$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE:
      case InsertionMode.IN_TABLE_BODY:
      case InsertionMode.IN_ROW: {
        characterInTable$1(this, token);
        break;
      }
      case InsertionMode.IN_TABLE_TEXT: {
        whitespaceCharacterInTableText$1(this, token);
        break;
      }
    }
  }
};
function aaObtainFormattingElementEntry$1(p, token) {
  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagID)) {
      formattingElementEntry = null;
    }
  } else {
    genericEndTagInBody$1(p, token);
  }
  return formattingElementEntry;
}
function aaObtainFurthestBlock$1(p, formattingElementEntry) {
  let furthestBlock = null;
  let idx = p.openElements.stackTop;
  for (; idx >= 0; idx--) {
    const element2 = p.openElements.items[idx];
    if (element2 === formattingElementEntry.element) {
      break;
    }
    if (p._isSpecialElement(element2, p.openElements.tagIDs[idx])) {
      furthestBlock = element2;
    }
  }
  if (!furthestBlock) {
    p.openElements.shortenToLength(idx < 0 ? 0 : idx);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop$1(p, furthestBlock, formattingElement) {
  let lastElement = furthestBlock;
  let nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (let i2 = 0, element2 = nextElement; element2 !== formattingElement; i2++, element2 = nextElement) {
    nextElement = p.openElements.getCommonAncestor(element2);
    const elementEntry = p.activeFormattingElements.getElementEntry(element2);
    const counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER$1;
    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow) {
        p.activeFormattingElements.removeEntry(elementEntry);
      }
      p.openElements.remove(element2);
    } else {
      element2 = aaRecreateElementFromEntry$1(p, elementEntry);
      if (lastElement === furthestBlock) {
        p.activeFormattingElements.bookmark = elementEntry;
      }
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element2, lastElement);
      lastElement = element2;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry$1(p, elementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor$1(p, commonAncestor, lastElement) {
  const tn = p.treeAdapter.getTagName(commonAncestor);
  const tid = getTagID(tn);
  if (p._isElementCausesFosterParenting(tid)) {
    p._fosterParentElement(lastElement);
  } else {
    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tid === TAG_ID.TEMPLATE && ns === NS$6.HTML) {
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    }
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement$1(p, furthestBlock, formattingElementEntry) {
  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
  const { token } = formattingElementEntry;
  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
}
function callAdoptionAgency$1(p, token) {
  for (let i2 = 0; i2 < AA_OUTER_LOOP_ITER$1; i2++) {
    const formattingElementEntry = aaObtainFormattingElementEntry$1(p, token);
    if (!formattingElementEntry) {
      break;
    }
    const furthestBlock = aaObtainFurthestBlock$1(p, formattingElementEntry);
    if (!furthestBlock) {
      break;
    }
    p.activeFormattingElements.bookmark = formattingElementEntry;
    const lastElement = aaInnerLoop$1(p, furthestBlock, formattingElementEntry.element);
    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    if (commonAncestor)
      aaInsertLastNodeInCommonAncestor$1(p, commonAncestor, lastElement);
    aaReplaceFormattingElement$1(p, furthestBlock, formattingElementEntry);
  }
}
function appendComment$1(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
}
function appendCommentToRootHtmlElement$1(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument$1(p, token) {
  p._appendCommentNode(token, p.document);
}
function stopParsing$1(p, token) {
  p.stopped = true;
  if (token.location) {
    const target2 = p.fragmentContext ? 0 : 2;
    for (let i2 = p.openElements.stackTop; i2 >= target2; i2--) {
      p._setEndLocation(p.openElements.items[i2], token);
    }
    if (!p.fragmentContext && p.openElements.stackTop >= 0) {
      const htmlElement = p.openElements.items[0];
      const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
      if (htmlLocation && !htmlLocation.endTag) {
        p._setEndLocation(htmlElement, token);
        if (p.openElements.stackTop >= 1) {
          const bodyElement = p.openElements.items[1];
          const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
          if (bodyLocation && !bodyLocation.endTag) {
            p._setEndLocation(bodyElement, token);
          }
        }
      }
    }
  }
}
function doctypeInInitialMode$1(p, token) {
  p._setDocumentType(token);
  const mode = token.forceQuirks ? DOCUMENT_MODE$3.QUIRKS : getDocumentMode(token);
  if (!isConforming(token)) {
    p._err(token, ERR.nonConformingDoctype);
  }
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = InsertionMode.BEFORE_HTML;
}
function tokenInInitialMode$1(p, token) {
  p._err(token, ERR.missingDoctype, true);
  p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE$3.QUIRKS);
  p.insertionMode = InsertionMode.BEFORE_HTML;
  p._processToken(token);
}
function startTagBeforeHtml$1(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p._insertElement(token, NS$6.HTML);
    p.insertionMode = InsertionMode.BEFORE_HEAD;
  } else {
    tokenBeforeHtml$1(p, token);
  }
}
function endTagBeforeHtml$1(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
    tokenBeforeHtml$1(p, token);
  }
}
function tokenBeforeHtml$1(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = InsertionMode.BEFORE_HEAD;
  p._processToken(token);
}
function startTagBeforeHead$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.HEAD: {
      p._insertElement(token, NS$6.HTML);
      p.headElement = p.openElements.current;
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    default: {
      tokenBeforeHead$1(p, token);
    }
  }
}
function endTagBeforeHead$1(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
    tokenBeforeHead$1(p, token);
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenBeforeHead$1(p, token) {
  p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagInHead$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META: {
      p._appendElement(token, NS$6.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TITLE: {
      p._switchToTextParsing(token, TokenizerMode.RCDATA);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      } else {
        p._insertElement(token, NS$6.HTML);
        p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
      }
      break;
    }
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
      break;
    }
    case TAG_ID.SCRIPT: {
      p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
      break;
    }
    case TAG_ID.TEMPLATE: {
      p._insertTemplate(token);
      p.activeFormattingElements.insertMarker();
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_TEMPLATE;
      p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenInHead$1(p, token);
    }
  }
}
function endTagInHead$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HEAD: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.AFTER_HEAD;
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.BR:
    case TAG_ID.HTML: {
      tokenInHead$1(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function templateEndTagInHead(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTagsThoroughly();
    if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
      p._err(token, ERR.closingOfElementWithOpenChildElements);
    }
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
  } else {
    p._err(token, ERR.endTagWithoutMatchingOpenElement);
  }
}
function tokenInHead$1(p, token) {
  p.openElements.pop();
  p.insertionMode = InsertionMode.AFTER_HEAD;
  p._processToken(token);
}
function startTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.HEAD:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.STYLE: {
      startTagInHead$1(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      p._err(token, ERR.nestedNoscriptInHead);
      break;
    }
    default: {
      tokenInHeadNoScript(p, token);
    }
  }
}
function endTagInHeadNoScript(p, token) {
  switch (token.tagID) {
    case TAG_ID.NOSCRIPT: {
      p.openElements.pop();
      p.insertionMode = InsertionMode.IN_HEAD;
      break;
    }
    case TAG_ID.BR: {
      tokenInHeadNoScript(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenInHeadNoScript(p, token) {
  const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
  p._err(token, errCode);
  p.openElements.pop();
  p.insertionMode = InsertionMode.IN_HEAD;
  p._processToken(token);
}
function startTagAfterHead$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.BODY: {
      p._insertElement(token, NS$6.HTML);
      p.framesetOk = false;
      p.insertionMode = InsertionMode.IN_BODY;
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS$6.HTML);
      p.insertionMode = InsertionMode.IN_FRAMESET;
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      p._err(token, ERR.abandonedHeadElementChild);
      p.openElements.push(p.headElement, TAG_ID.HEAD);
      startTagInHead$1(p, token);
      p.openElements.remove(p.headElement);
      break;
    }
    case TAG_ID.HEAD: {
      p._err(token, ERR.misplacedStartTagForHeadElement);
      break;
    }
    default: {
      tokenAfterHead$1(p, token);
    }
  }
}
function endTagAfterHead$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.BODY:
    case TAG_ID.HTML:
    case TAG_ID.BR: {
      tokenAfterHead$1(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      p._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
}
function tokenAfterHead$1(p, token) {
  p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function modeInBody(p, token) {
  switch (token.type) {
    case TokenType.CHARACTER: {
      characterInBody$1(p, token);
      break;
    }
    case TokenType.WHITESPACE_CHARACTER: {
      whitespaceCharacterInBody$1(p, token);
      break;
    }
    case TokenType.COMMENT: {
      appendComment$1(p, token);
      break;
    }
    case TokenType.START_TAG: {
      startTagInBody$1(p, token);
      break;
    }
    case TokenType.END_TAG: {
      endTagInBody$1(p, token);
      break;
    }
    case TokenType.EOF: {
      eofInBody$1(p, token);
      break;
    }
  }
}
function whitespaceCharacterInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody$1(p, token) {
  if (p.openElements.tmplCount === 0) {
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
  }
}
function bodyStartTagInBody$1(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody$1(p, token) {
  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS$6.HTML);
    p.insertionMode = InsertionMode.IN_FRAMESET;
  }
}
function addressStartTagInBody$1(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS$6.HTML);
}
function numberedHeaderStartTagInBody$1(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  if (isNumberedHeader(p.openElements.currentTagId)) {
    p.openElements.pop();
  }
  p._insertElement(token, NS$6.HTML);
}
function preStartTagInBody$1(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS$6.HTML);
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody$1(p, token) {
  const inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope(TAG_ID.P)) {
      p._closePElement();
    }
    p._insertElement(token, NS$6.HTML);
    if (!inTemplate) {
      p.formElement = p.openElements.current;
    }
  }
}
function listItemStartTagInBody$1(p, token) {
  p.framesetOk = false;
  const tn = token.tagID;
  for (let i2 = p.openElements.stackTop; i2 >= 0; i2--) {
    const elementId = p.openElements.tagIDs[i2];
    if (tn === TAG_ID.LI && elementId === TAG_ID.LI || (tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
      p.openElements.generateImpliedEndTagsWithExclusion(elementId);
      p.openElements.popUntilTagNamePopped(elementId);
      break;
    }
    if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p._isSpecialElement(p.openElements.items[i2], elementId)) {
      break;
    }
  }
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS$6.HTML);
}
function plaintextStartTagInBody$1(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS$6.HTML);
  p.tokenizer.state = TokenizerMode.PLAINTEXT;
}
function buttonStartTagInBody$1(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
  p.framesetOk = false;
}
function aStartTagInBody$1(p, token) {
  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
  if (activeElementEntry) {
    callAdoptionAgency$1(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope(TAG_ID.NOBR)) {
    callAdoptionAgency$1(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS$6.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody$1(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE$3.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._insertElement(token, NS$6.HTML);
  p.framesetOk = false;
  p.insertionMode = InsertionMode.IN_TABLE;
}
function areaStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS$6.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function isHiddenInput(token) {
  const inputType = getTokenAttr(token, ATTRS$2.TYPE);
  return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE$1;
}
function inputStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS$6.HTML);
  if (!isHiddenInput(token)) {
    p.framesetOk = false;
  }
  token.ackSelfClosing = true;
}
function paramStartTagInBody$1(p, token) {
  p._appendElement(token, NS$6.HTML);
  token.ackSelfClosing = true;
}
function hrStartTagInBody$1(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._appendElement(token, NS$6.HTML);
  p.framesetOk = false;
  token.ackSelfClosing = true;
}
function imageStartTagInBody$1(p, token) {
  token.tagName = TAG_NAMES.IMG;
  token.tagID = TAG_ID.IMG;
  areaStartTagInBody$1(p, token);
}
function textareaStartTagInBody$1(p, token) {
  p._insertElement(token, NS$6.HTML);
  p.skipNextNewLine = true;
  p.tokenizer.state = TokenizerMode.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = InsertionMode.TEXT;
}
function xmpStartTagInBody$1(p, token) {
  if (p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._closePElement();
  }
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function iframeStartTagInBody$1(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function noembedStartTagInBody$1(p, token) {
  p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
}
function selectStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
  p.framesetOk = false;
  p.insertionMode = p.insertionMode === InsertionMode.IN_TABLE || p.insertionMode === InsertionMode.IN_CAPTION || p.insertionMode === InsertionMode.IN_TABLE_BODY || p.insertionMode === InsertionMode.IN_ROW || p.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
}
function optgroupStartTagInBody$1(p, token) {
  if (p.openElements.currentTagId === TAG_ID.OPTION) {
    p.openElements.pop();
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
}
function rbStartTagInBody$1(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTags();
  }
  p._insertElement(token, NS$6.HTML);
}
function rtStartTagInBody$1(p, token) {
  if (p.openElements.hasInScope(TAG_ID.RUBY)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
  }
  p._insertElement(token, NS$6.HTML);
}
function mathStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenMathMLAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS$6.MATHML);
  } else {
    p._insertElement(token, NS$6.MATHML);
  }
  token.ackSelfClosing = true;
}
function svgStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  adjustTokenSVGAttrs(token);
  adjustTokenXMLAttrs(token);
  if (token.selfClosing) {
    p._appendElement(token, NS$6.SVG);
  } else {
    p._insertElement(token, NS$6.SVG);
  }
  token.ackSelfClosing = true;
}
function genericStartTagInBody$1(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$6.HTML);
}
function startTagInBody$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.B:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      bStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.A: {
      aStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.P:
    case TAG_ID.DL:
    case TAG_ID.OL:
    case TAG_ID.UL:
    case TAG_ID.DIV:
    case TAG_ID.DIR:
    case TAG_ID.NAV:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.DETAILS:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.LI:
    case TAG_ID.DD:
    case TAG_ID.DT: {
      listItemStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.BR:
    case TAG_ID.IMG:
    case TAG_ID.WBR:
    case TAG_ID.AREA:
    case TAG_ID.EMBED:
    case TAG_ID.KEYGEN: {
      areaStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.HR: {
      hrStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.RB:
    case TAG_ID.RTC: {
      rbStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.RT:
    case TAG_ID.RP: {
      rtStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.PRE:
    case TAG_ID.LISTING: {
      preStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.XMP: {
      xmpStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.SVG: {
      svgStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.BASE:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.STYLE:
    case TAG_ID.TITLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.BGSOUND:
    case TAG_ID.BASEFONT:
    case TAG_ID.TEMPLATE: {
      startTagInHead$1(p, token);
      break;
    }
    case TAG_ID.BODY: {
      bodyStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.NOBR: {
      nobrStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.MATH: {
      mathStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.PARAM:
    case TAG_ID.TRACK:
    case TAG_ID.SOURCE: {
      paramStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.IMAGE: {
      imageStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.BUTTON: {
      buttonStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.IFRAME: {
      iframeStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.SELECT: {
      selectStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.OPTION:
    case TAG_ID.OPTGROUP: {
      optgroupStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.NOEMBED: {
      noembedStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      framesetStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.TEXTAREA: {
      textareaStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.NOSCRIPT: {
      if (p.options.scriptingEnabled) {
        noembedStartTagInBody$1(p, token);
      } else {
        genericStartTagInBody$1(p, token);
      }
      break;
    }
    case TAG_ID.PLAINTEXT: {
      plaintextStartTagInBody$1(p, token);
      break;
    }
    case TAG_ID.COL:
    case TAG_ID.TH:
    case TAG_ID.TD:
    case TAG_ID.TR:
    case TAG_ID.HEAD:
    case TAG_ID.FRAME:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP: {
      break;
    }
    default: {
      genericStartTagInBody$1(p, token);
    }
  }
}
function bodyEndTagInBody$1(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    if (p.options.sourceCodeLocationInfo) {
      const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement) {
        p._setEndLocation(bodyElement, token);
      }
    }
  }
}
function htmlEndTagInBody$1(p, token) {
  if (p.openElements.hasInScope(TAG_ID.BODY)) {
    p.insertionMode = InsertionMode.AFTER_BODY;
    endTagAfterBody$1(p, token);
  }
}
function addressEndTagInBody$1(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody$1(p) {
  const inTemplate = p.openElements.tmplCount > 0;
  const { formElement } = p;
  if (!inTemplate) {
    p.formElement = null;
  }
  if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate) {
      p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
    } else if (formElement) {
      p.openElements.remove(formElement);
    }
  }
}
function pEndTagInBody$1(p) {
  if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
    p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
  }
  p._closePElement();
}
function liEndTagInBody$1(p) {
  if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
    p.openElements.popUntilTagNamePopped(TAG_ID.LI);
  }
}
function ddEndTagInBody$1(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody$1(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody$1(p, token) {
  const tn = token.tagID;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody$1(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody$1(p, token) {
  const tn = token.tagName;
  const tid = token.tagID;
  for (let i2 = p.openElements.stackTop; i2 > 0; i2--) {
    const element2 = p.openElements.items[i2];
    const elementId = p.openElements.tagIDs[i2];
    if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element2) === tn)) {
      p.openElements.generateImpliedEndTagsWithExclusion(tid);
      if (p.openElements.stackTop >= i2)
        p.openElements.shortenToLength(i2);
      break;
    }
    if (p._isSpecialElement(element2, elementId)) {
      break;
    }
  }
}
function endTagInBody$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.A:
    case TAG_ID.B:
    case TAG_ID.I:
    case TAG_ID.S:
    case TAG_ID.U:
    case TAG_ID.EM:
    case TAG_ID.TT:
    case TAG_ID.BIG:
    case TAG_ID.CODE:
    case TAG_ID.FONT:
    case TAG_ID.NOBR:
    case TAG_ID.SMALL:
    case TAG_ID.STRIKE:
    case TAG_ID.STRONG: {
      callAdoptionAgency$1(p, token);
      break;
    }
    case TAG_ID.P: {
      pEndTagInBody$1(p);
      break;
    }
    case TAG_ID.DL:
    case TAG_ID.UL:
    case TAG_ID.OL:
    case TAG_ID.DIR:
    case TAG_ID.DIV:
    case TAG_ID.NAV:
    case TAG_ID.PRE:
    case TAG_ID.MAIN:
    case TAG_ID.MENU:
    case TAG_ID.ASIDE:
    case TAG_ID.BUTTON:
    case TAG_ID.CENTER:
    case TAG_ID.FIGURE:
    case TAG_ID.FOOTER:
    case TAG_ID.HEADER:
    case TAG_ID.HGROUP:
    case TAG_ID.DIALOG:
    case TAG_ID.ADDRESS:
    case TAG_ID.ARTICLE:
    case TAG_ID.DETAILS:
    case TAG_ID.SECTION:
    case TAG_ID.SUMMARY:
    case TAG_ID.LISTING:
    case TAG_ID.FIELDSET:
    case TAG_ID.BLOCKQUOTE:
    case TAG_ID.FIGCAPTION: {
      addressEndTagInBody$1(p, token);
      break;
    }
    case TAG_ID.LI: {
      liEndTagInBody$1(p);
      break;
    }
    case TAG_ID.DD:
    case TAG_ID.DT: {
      ddEndTagInBody$1(p, token);
      break;
    }
    case TAG_ID.H1:
    case TAG_ID.H2:
    case TAG_ID.H3:
    case TAG_ID.H4:
    case TAG_ID.H5:
    case TAG_ID.H6: {
      numberedHeaderEndTagInBody$1(p);
      break;
    }
    case TAG_ID.BR: {
      brEndTagInBody$1(p);
      break;
    }
    case TAG_ID.BODY: {
      bodyEndTagInBody$1(p, token);
      break;
    }
    case TAG_ID.HTML: {
      htmlEndTagInBody$1(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formEndTagInBody$1(p);
      break;
    }
    case TAG_ID.APPLET:
    case TAG_ID.OBJECT:
    case TAG_ID.MARQUEE: {
      appletEndTagInBody$1(p, token);
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    default: {
      genericEndTagInBody$1(p, token);
    }
  }
}
function eofInBody$1(p, token) {
  if (p.tmplInsertionModeStack.length > 0) {
    eofInTemplate$1(p, token);
  } else {
    stopParsing$1(p, token);
  }
}
function endTagInText$1(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.SCRIPT) {
    (_a2 = p.scriptHandler) === null || _a2 === void 0 ? void 0 : _a2.call(p, p.openElements.current);
  }
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText$1(p, token) {
  p._err(token, ERR.eofInElementThatCanContainOnlyText);
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p.onEof(token);
}
function characterInTable$1(p, token) {
  if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
    p.pendingCharacterTokens.length = 0;
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = InsertionMode.IN_TABLE_TEXT;
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInTableText$1(p, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInTableText$1(p, token);
        break;
      }
    }
  } else {
    tokenInTable$1(p, token);
  }
}
function captionStartTagInTable$1(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS$6.HTML);
  p.insertionMode = InsertionMode.IN_CAPTION;
}
function colgroupStartTagInTable$1(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS$6.HTML);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
}
function colStartTagInTable$1(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
  p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  startTagInColumnGroup$1(p, token);
}
function tbodyStartTagInTable$1(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS$6.HTML);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
}
function tdStartTagInTable$1(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
  p.insertionMode = InsertionMode.IN_TABLE_BODY;
  startTagInTableBody$1(p, token);
}
function tableStartTagInTable$1(p, token) {
  if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
    p._resetInsertionMode();
    p._processStartTag(token);
  }
}
function inputStartTagInTable$1(p, token) {
  if (isHiddenInput(token)) {
    p._appendElement(token, NS$6.HTML);
  } else {
    tokenInTable$1(p, token);
  }
  token.ackSelfClosing = true;
}
function formStartTagInTable$1(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS$6.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      tdStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.STYLE:
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead$1(p, token);
      break;
    }
    case TAG_ID.COL: {
      colStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.FORM: {
      formStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.TABLE: {
      tableStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      tbodyStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.INPUT: {
      inputStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.CAPTION: {
      captionStartTagInTable$1(p, token);
      break;
    }
    case TAG_ID.COLGROUP: {
      colgroupStartTagInTable$1(p, token);
      break;
    }
    default: {
      tokenInTable$1(p, token);
    }
  }
}
function endTagInTable$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      tokenInTable$1(p, token);
    }
  }
}
function tokenInTable$1(p, token) {
  const savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  modeInBody(p, token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText$1(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText$1(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText$1(p, token) {
  let i2 = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i2 < p.pendingCharacterTokens.length; i2++) {
      tokenInTable$1(p, p.pendingCharacterTokens[i2]);
    }
  } else {
    for (; i2 < p.pendingCharacterTokens.length; i2++) {
      p._insertCharacters(p.pendingCharacterTokens[i2]);
    }
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
const TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
function startTagInCaption$1(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable$1(p, token);
    }
  } else {
    startTagInBody$1(p, token);
  }
}
function endTagInCaption$1(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.CAPTION:
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_TABLE;
        if (tn === TAG_ID.TABLE) {
          endTagInTable$1(p, token);
        }
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TBODY:
    case TAG_ID.TD:
    case TAG_ID.TFOOT:
    case TAG_ID.TH:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInBody$1(p, token);
    }
  }
}
function startTagInColumnGroup$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.COL: {
      p._appendElement(token, NS$6.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.TEMPLATE: {
      startTagInHead$1(p, token);
      break;
    }
    default: {
      tokenInColumnGroup$1(p, token);
    }
  }
}
function endTagInColumnGroup$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.COLGROUP: {
      if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
    case TAG_ID.COL: {
      break;
    }
    default: {
      tokenInColumnGroup$1(p, token);
    }
  }
}
function tokenInColumnGroup$1(p, token) {
  if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = InsertionMode.IN_TABLE;
    p._processToken(token);
  }
}
function startTagInTableBody$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      p.openElements.clearBackToTableBodyContext();
      p._insertElement(token, NS$6.HTML);
      p.insertionMode = InsertionMode.IN_ROW;
      break;
    }
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableBodyContext();
      p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow$1(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable$1(p, token);
      }
      break;
    }
    default: {
      startTagInTable$1(p, token);
    }
  }
}
function endTagInTableBody$1(p, token) {
  const tn = token.tagID;
  switch (token.tagID) {
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasTableBodyContextInTableScope()) {
        p.openElements.clearBackToTableBodyContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE;
        endTagInTable$1(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH:
    case TAG_ID.TR: {
      break;
    }
    default: {
      endTagInTable$1(p, token);
    }
  }
}
function startTagInRow$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.TH:
    case TAG_ID.TD: {
      p.openElements.clearBackToTableRowContext();
      p._insertElement(token, NS$6.HTML);
      p.insertionMode = InsertionMode.IN_CELL;
      p.activeFormattingElements.insertMarker();
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody$1(p, token);
      }
      break;
    }
    default: {
      startTagInTable$1(p, token);
    }
  }
}
function endTagInRow$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
      }
      break;
    }
    case TAG_ID.TABLE: {
      if (p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody$1(p, token);
      }
      break;
    }
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
        p.openElements.clearBackToTableRowContext();
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        endTagInTableBody$1(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML:
    case TAG_ID.TD:
    case TAG_ID.TH: {
      break;
    }
    default: {
      endTagInTable$1(p, token);
    }
  }
}
function startTagInCell$1(p, token) {
  const tn = token.tagID;
  if (TABLE_VOID_ELEMENTS.has(tn)) {
    if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
      p._closeTableCell();
      startTagInRow$1(p, token);
    }
  } else {
    startTagInBody$1(p, token);
  }
}
function endTagInCell$1(p, token) {
  const tn = token.tagID;
  switch (tn) {
    case TAG_ID.TD:
    case TAG_ID.TH: {
      if (p.openElements.hasInTableScope(tn)) {
        p.openElements.generateImpliedEndTags();
        p.openElements.popUntilTagNamePopped(tn);
        p.activeFormattingElements.clearToLastMarker();
        p.insertionMode = InsertionMode.IN_ROW;
      }
      break;
    }
    case TAG_ID.TABLE:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD:
    case TAG_ID.TR: {
      if (p.openElements.hasInTableScope(tn)) {
        p._closeTableCell();
        endTagInRow$1(p, token);
      }
      break;
    }
    case TAG_ID.BODY:
    case TAG_ID.CAPTION:
    case TAG_ID.COL:
    case TAG_ID.COLGROUP:
    case TAG_ID.HTML: {
      break;
    }
    default: {
      endTagInBody$1(p, token);
    }
  }
}
function startTagInSelect$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      p._insertElement(token, NS$6.HTML);
      break;
    }
    case TAG_ID.OPTGROUP: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      p._insertElement(token, NS$6.HTML);
      break;
    }
    case TAG_ID.INPUT:
    case TAG_ID.KEYGEN:
    case TAG_ID.TEXTAREA:
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
        if (token.tagID !== TAG_ID.SELECT) {
          p._processStartTag(token);
        }
      }
      break;
    }
    case TAG_ID.SCRIPT:
    case TAG_ID.TEMPLATE: {
      startTagInHead$1(p, token);
      break;
    }
  }
}
function endTagInSelect$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.OPTGROUP: {
      if (p.openElements.stackTop > 0 && p.openElements.currentTagId === TAG_ID.OPTION && p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.OPTION: {
      if (p.openElements.currentTagId === TAG_ID.OPTION) {
        p.openElements.pop();
      }
      break;
    }
    case TAG_ID.SELECT: {
      if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
        p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p._resetInsertionMode();
      }
      break;
    }
    case TAG_ID.TEMPLATE: {
      templateEndTagInHead(p, token);
      break;
    }
  }
}
function startTagInSelectInTable$1(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
    p._resetInsertionMode();
    p._processStartTag(token);
  } else {
    startTagInSelect$1(p, token);
  }
}
function endTagInSelectInTable$1(p, token) {
  const tn = token.tagID;
  if (tn === TAG_ID.CAPTION || tn === TAG_ID.TABLE || tn === TAG_ID.TBODY || tn === TAG_ID.TFOOT || tn === TAG_ID.THEAD || tn === TAG_ID.TR || tn === TAG_ID.TD || tn === TAG_ID.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p._resetInsertionMode();
      p.onEndTag(token);
    }
  } else {
    endTagInSelect$1(p, token);
  }
}
function startTagInTemplate$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.BASE:
    case TAG_ID.BASEFONT:
    case TAG_ID.BGSOUND:
    case TAG_ID.LINK:
    case TAG_ID.META:
    case TAG_ID.NOFRAMES:
    case TAG_ID.SCRIPT:
    case TAG_ID.STYLE:
    case TAG_ID.TEMPLATE:
    case TAG_ID.TITLE: {
      startTagInHead$1(p, token);
      break;
    }
    case TAG_ID.CAPTION:
    case TAG_ID.COLGROUP:
    case TAG_ID.TBODY:
    case TAG_ID.TFOOT:
    case TAG_ID.THEAD: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
      p.insertionMode = InsertionMode.IN_TABLE;
      startTagInTable$1(p, token);
      break;
    }
    case TAG_ID.COL: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
      p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
      startTagInColumnGroup$1(p, token);
      break;
    }
    case TAG_ID.TR: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
      p.insertionMode = InsertionMode.IN_TABLE_BODY;
      startTagInTableBody$1(p, token);
      break;
    }
    case TAG_ID.TD:
    case TAG_ID.TH: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
      p.insertionMode = InsertionMode.IN_ROW;
      startTagInRow$1(p, token);
      break;
    }
    default: {
      p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
      p.insertionMode = InsertionMode.IN_BODY;
      startTagInBody$1(p, token);
    }
  }
}
function endTagInTemplate$1(p, token) {
  if (token.tagID === TAG_ID.TEMPLATE) {
    templateEndTagInHead(p, token);
  }
}
function eofInTemplate$1(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p.tmplInsertionModeStack.shift();
    p._resetInsertionMode();
    p.onEof(token);
  } else {
    stopParsing$1(p, token);
  }
}
function startTagAfterBody$1(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody$1(p, token);
  } else {
    tokenAfterBody$1(p, token);
  }
}
function endTagAfterBody$1(p, token) {
  var _a2;
  if (token.tagID === TAG_ID.HTML) {
    if (!p.fragmentContext) {
      p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
    }
    if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
      p._setEndLocation(p.openElements.items[0], token);
      const bodyElement = p.openElements.items[1];
      if (bodyElement && !((_a2 = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a2 === void 0 ? void 0 : _a2.endTag)) {
        p._setEndLocation(bodyElement, token);
      }
    }
  } else {
    tokenAfterBody$1(p, token);
  }
}
function tokenAfterBody$1(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagInFrameset$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.FRAMESET: {
      p._insertElement(token, NS$6.HTML);
      break;
    }
    case TAG_ID.FRAME: {
      p._appendElement(token, NS$6.HTML);
      token.ackSelfClosing = true;
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead$1(p, token);
      break;
    }
  }
}
function endTagInFrameset$1(p, token) {
  if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
      p.insertionMode = InsertionMode.AFTER_FRAMESET;
    }
  }
}
function startTagAfterFrameset$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead$1(p, token);
      break;
    }
  }
}
function endTagAfterFrameset$1(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
  }
}
function startTagAfterAfterBody$1(p, token) {
  if (token.tagID === TAG_ID.HTML) {
    startTagInBody$1(p, token);
  } else {
    tokenAfterAfterBody$1(p, token);
  }
}
function tokenAfterAfterBody$1(p, token) {
  p.insertionMode = InsertionMode.IN_BODY;
  modeInBody(p, token);
}
function startTagAfterAfterFrameset$1(p, token) {
  switch (token.tagID) {
    case TAG_ID.HTML: {
      startTagInBody$1(p, token);
      break;
    }
    case TAG_ID.NOFRAMES: {
      startTagInHead$1(p, token);
      break;
    }
  }
}
function nullCharacterInForeignContent$1(p, token) {
  token.chars = REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent$1(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function popUntilHtmlOrIntegrationPoint(p) {
  while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS$6.HTML && !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
    p.openElements.pop();
  }
}
function startTagInForeignContent$1(p, token) {
  if (causesExit(token)) {
    popUntilHtmlOrIntegrationPoint(p);
    p._startTagOutsideForeignContent(token);
  } else {
    const current = p._getAdjustedCurrentElement();
    const currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS$6.MATHML) {
      adjustTokenMathMLAttrs(token);
    } else if (currentNs === NS$6.SVG) {
      adjustTokenSVGTagName(token);
      adjustTokenSVGAttrs(token);
    }
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p._appendElement(token, currentNs);
    } else {
      p._insertElement(token, currentNs);
    }
    token.ackSelfClosing = true;
  }
}
function endTagInForeignContent$1(p, token) {
  if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
    popUntilHtmlOrIntegrationPoint(p);
    p._endTagOutsideForeignContent(token);
    return;
  }
  for (let i2 = p.openElements.stackTop; i2 > 0; i2--) {
    const element2 = p.openElements.items[i2];
    if (p.treeAdapter.getNamespaceURI(element2) === NS$6.HTML) {
      p._endTagOutsideForeignContent(token);
      break;
    }
    const tagName = p.treeAdapter.getTagName(element2);
    if (tagName.toLowerCase() === token.tagName) {
      token.tagName = tagName;
      p.openElements.shortenToLength(i2);
      break;
    }
  }
}
const VOID_ELEMENTS = /* @__PURE__ */ new Set([
  TAG_NAMES.AREA,
  TAG_NAMES.BASE,
  TAG_NAMES.BASEFONT,
  TAG_NAMES.BGSOUND,
  TAG_NAMES.BR,
  TAG_NAMES.COL,
  TAG_NAMES.EMBED,
  TAG_NAMES.FRAME,
  TAG_NAMES.HR,
  TAG_NAMES.IMG,
  TAG_NAMES.INPUT,
  TAG_NAMES.KEYGEN,
  TAG_NAMES.LINK,
  TAG_NAMES.META,
  TAG_NAMES.PARAM,
  TAG_NAMES.SOURCE,
  TAG_NAMES.TRACK,
  TAG_NAMES.WBR
]);
function isVoidElement(node2, options2) {
  return options2.treeAdapter.isElementNode(node2) && options2.treeAdapter.getNamespaceURI(node2) === NS$6.HTML && VOID_ELEMENTS.has(options2.treeAdapter.getTagName(node2));
}
const defaultOpts$1 = { treeAdapter: defaultTreeAdapter$2, scriptingEnabled: true };
function serializeOuter(node2, options2) {
  const opts = { ...defaultOpts$1, ...options2 };
  return serializeNode(node2, opts);
}
function serializeChildNodes(parentNode, options2) {
  let html2 = "";
  const container = options2.treeAdapter.isElementNode(parentNode) && options2.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE && options2.treeAdapter.getNamespaceURI(parentNode) === NS$6.HTML ? options2.treeAdapter.getTemplateContent(parentNode) : parentNode;
  const childNodes = options2.treeAdapter.getChildNodes(container);
  if (childNodes) {
    for (const currentNode of childNodes) {
      html2 += serializeNode(currentNode, options2);
    }
  }
  return html2;
}
function serializeNode(node2, options2) {
  if (options2.treeAdapter.isElementNode(node2)) {
    return serializeElement(node2, options2);
  }
  if (options2.treeAdapter.isTextNode(node2)) {
    return serializeTextNode(node2, options2);
  }
  if (options2.treeAdapter.isCommentNode(node2)) {
    return serializeCommentNode(node2, options2);
  }
  if (options2.treeAdapter.isDocumentTypeNode(node2)) {
    return serializeDocumentTypeNode(node2, options2);
  }
  return "";
}
function serializeElement(node2, options2) {
  const tn = options2.treeAdapter.getTagName(node2);
  return `<${tn}${serializeAttributes(node2, options2)}>${isVoidElement(node2, options2) ? "" : `${serializeChildNodes(node2, options2)}</${tn}>`}`;
}
function serializeAttributes(node2, { treeAdapter }) {
  let html2 = "";
  for (const attr2 of treeAdapter.getAttrList(node2)) {
    html2 += " ";
    if (!attr2.namespace) {
      html2 += attr2.name;
    } else
      switch (attr2.namespace) {
        case NS$6.XML: {
          html2 += `xml:${attr2.name}`;
          break;
        }
        case NS$6.XMLNS: {
          if (attr2.name !== "xmlns") {
            html2 += "xmlns:";
          }
          html2 += attr2.name;
          break;
        }
        case NS$6.XLINK: {
          html2 += `xlink:${attr2.name}`;
          break;
        }
        default: {
          html2 += `${attr2.prefix}:${attr2.name}`;
        }
      }
    html2 += `="${escapeAttribute(attr2.value)}"`;
  }
  return html2;
}
function serializeTextNode(node2, options2) {
  const { treeAdapter } = options2;
  const content = treeAdapter.getTextNodeContent(node2);
  const parent2 = treeAdapter.getParentNode(node2);
  const parentTn = parent2 && treeAdapter.isElementNode(parent2) && treeAdapter.getTagName(parent2);
  return parentTn && treeAdapter.getNamespaceURI(parent2) === NS$6.HTML && hasUnescapedText(parentTn, options2.scriptingEnabled) ? content : escapeText(content);
}
function serializeCommentNode(node2, { treeAdapter }) {
  return `<!--${treeAdapter.getCommentNodeContent(node2)}-->`;
}
function serializeDocumentTypeNode(node2, { treeAdapter }) {
  return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node2)}>`;
}
function parse$8(html2, options2) {
  return Parser$5.parse(html2, options2);
}
function parseFragment(fragmentContext, html2, options2) {
  if (typeof fragmentContext === "string") {
    options2 = html2;
    html2 = fragmentContext;
    fragmentContext = null;
  }
  const parser2 = Parser$5.getFragmentParser(fragmentContext, options2);
  parser2.tokenizer.write(html2, true);
  return parser2.getFragment();
}
function createTextNode$2(value) {
  return new Text(value);
}
function enquoteDoctypeId$1(id) {
  const quote = id.includes('"') ? "'" : '"';
  return quote + id + quote;
}
function serializeDoctypeContent(name2, publicId, systemId) {
  let str = "!DOCTYPE ";
  if (name2) {
    str += name2;
  }
  if (publicId) {
    str += ` PUBLIC ${enquoteDoctypeId$1(publicId)}`;
  } else if (systemId) {
    str += " SYSTEM";
  }
  if (systemId) {
    str += ` ${enquoteDoctypeId$1(systemId)}`;
  }
  return str;
}
const adapter = {
  // Re-exports from domhandler
  isCommentNode: isComment,
  isElementNode: isTag$6,
  isTextNode: isText,
  //Node construction
  createDocument() {
    const node2 = new Document([]);
    node2["x-mode"] = DOCUMENT_MODE$3.NO_QUIRKS;
    return node2;
  },
  createDocumentFragment() {
    return new Document([]);
  },
  createElement(tagName, namespaceURI, attrs) {
    const attribs = /* @__PURE__ */ Object.create(null);
    const attribsNamespace = /* @__PURE__ */ Object.create(null);
    const attribsPrefix = /* @__PURE__ */ Object.create(null);
    for (let i2 = 0; i2 < attrs.length; i2++) {
      const attrName = attrs[i2].name;
      attribs[attrName] = attrs[i2].value;
      attribsNamespace[attrName] = attrs[i2].namespace;
      attribsPrefix[attrName] = attrs[i2].prefix;
    }
    const node2 = new Element$1(tagName, attribs, []);
    node2.namespace = namespaceURI;
    node2["x-attribsNamespace"] = attribsNamespace;
    node2["x-attribsPrefix"] = attribsPrefix;
    return node2;
  },
  createCommentNode(data2) {
    return new Comment(data2);
  },
  //Tree mutation
  appendChild(parentNode, newNode) {
    const prev2 = parentNode.children[parentNode.children.length - 1];
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    parentNode.children.push(newNode);
    newNode.parent = parentNode;
  },
  insertBefore(parentNode, newNode, referenceNode) {
    const insertionIdx = parentNode.children.indexOf(referenceNode);
    const { prev: prev2 } = referenceNode;
    if (prev2) {
      prev2.next = newNode;
      newNode.prev = prev2;
    }
    referenceNode.prev = newNode;
    newNode.next = referenceNode;
    parentNode.children.splice(insertionIdx, 0, newNode);
    newNode.parent = parentNode;
  },
  setTemplateContent(templateElement, contentElement) {
    adapter.appendChild(templateElement, contentElement);
  },
  getTemplateContent(templateElement) {
    return templateElement.children[0];
  },
  setDocumentType(document, name2, publicId, systemId) {
    const data2 = serializeDoctypeContent(name2, publicId, systemId);
    let doctypeNode = document.children.find((node2) => isDirective(node2) && node2.name === "!doctype");
    if (doctypeNode) {
      doctypeNode.data = data2 !== null && data2 !== void 0 ? data2 : null;
    } else {
      doctypeNode = new ProcessingInstruction("!doctype", data2);
      adapter.appendChild(document, doctypeNode);
    }
    doctypeNode["x-name"] = name2 !== null && name2 !== void 0 ? name2 : void 0;
    doctypeNode["x-publicId"] = publicId !== null && publicId !== void 0 ? publicId : void 0;
    doctypeNode["x-systemId"] = systemId !== null && systemId !== void 0 ? systemId : void 0;
  },
  setDocumentMode(document, mode) {
    document["x-mode"] = mode;
  },
  getDocumentMode(document) {
    return document["x-mode"];
  },
  detachNode(node2) {
    if (node2.parent) {
      const idx = node2.parent.children.indexOf(node2);
      const { prev: prev2, next: next2 } = node2;
      node2.prev = null;
      node2.next = null;
      if (prev2) {
        prev2.next = next2;
      }
      if (next2) {
        next2.prev = prev2;
      }
      node2.parent.children.splice(idx, 1);
      node2.parent = null;
    }
  },
  insertText(parentNode, text2) {
    const lastChild = parentNode.children[parentNode.children.length - 1];
    if (lastChild && isText(lastChild)) {
      lastChild.data += text2;
    } else {
      adapter.appendChild(parentNode, createTextNode$2(text2));
    }
  },
  insertTextBefore(parentNode, text2, referenceNode) {
    const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
    if (prevNode && isText(prevNode)) {
      prevNode.data += text2;
    } else {
      adapter.insertBefore(parentNode, createTextNode$2(text2), referenceNode);
    }
  },
  adoptAttributes(recipient, attrs) {
    for (let i2 = 0; i2 < attrs.length; i2++) {
      const attrName = attrs[i2].name;
      if (typeof recipient.attribs[attrName] === "undefined") {
        recipient.attribs[attrName] = attrs[i2].value;
        recipient["x-attribsNamespace"][attrName] = attrs[i2].namespace;
        recipient["x-attribsPrefix"][attrName] = attrs[i2].prefix;
      }
    }
  },
  //Tree traversing
  getFirstChild(node2) {
    return node2.children[0];
  },
  getChildNodes(node2) {
    return node2.children;
  },
  getParentNode(node2) {
    return node2.parent;
  },
  getAttrList(element2) {
    return element2.attributes;
  },
  //Node data
  getTagName(element2) {
    return element2.name;
  },
  getNamespaceURI(element2) {
    return element2.namespace;
  },
  getTextNodeContent(textNode) {
    return textNode.data;
  },
  getCommentNodeContent(commentNode) {
    return commentNode.data;
  },
  getDocumentTypeNodeName(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-name"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  getDocumentTypeNodePublicId(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-publicId"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  getDocumentTypeNodeSystemId(doctypeNode) {
    var _a2;
    return (_a2 = doctypeNode["x-systemId"]) !== null && _a2 !== void 0 ? _a2 : "";
  },
  //Node types
  isDocumentTypeNode(node2) {
    return isDirective(node2) && node2.name === "!doctype";
  },
  // Source code location
  setNodeSourceCodeLocation(node2, location) {
    if (location) {
      node2.startIndex = location.startOffset;
      node2.endIndex = location.endOffset;
    }
    node2.sourceCodeLocation = location;
  },
  getNodeSourceCodeLocation(node2) {
    return node2.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(node2, endLocation) {
    if (endLocation.endOffset != null)
      node2.endIndex = endLocation.endOffset;
    node2.sourceCodeLocation = {
      ...node2.sourceCodeLocation,
      ...endLocation
    };
  }
};
function parseWithParse5(content, options2, isDocument2, context) {
  const opts = {
    scriptingEnabled: typeof options2.scriptingEnabled === "boolean" ? options2.scriptingEnabled : true,
    treeAdapter: adapter,
    sourceCodeLocationInfo: options2.sourceCodeLocationInfo
  };
  return isDocument2 ? parse$8(content, opts) : parseFragment(context, content, opts);
}
const renderOpts = { treeAdapter: adapter };
function renderWithParse5(dom) {
  const nodes = "length" in dom ? dom : [dom];
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node2 = nodes[index2];
    if (isDocument(node2)) {
      Array.prototype.splice.call(nodes, index2, 1, ...node2.children);
    }
  }
  let result = "";
  for (let index2 = 0; index2 < nodes.length; index2 += 1) {
    const node2 = nodes[index2];
    result += serializeOuter(node2, renderOpts);
  }
  return result;
}
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
  CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
  CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
  CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
  CharCodes2[CharCodes2["Space"] = 32] = "Space";
  CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCodes2[CharCodes2["Number"] = 35] = "Number";
  CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
  CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
  CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
  CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
  CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
  CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
  CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
  CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
  CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
  CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
  CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
  CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
  CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
  CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
  CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
  CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
  CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
  CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
  CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
})(CharCodes || (CharCodes = {}));
var State;
(function(State2) {
  State2[State2["Text"] = 1] = "Text";
  State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
  State2[State2["InTagName"] = 3] = "InTagName";
  State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
  State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
  State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
  State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
  State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
  State2[State2["InAttributeName"] = 9] = "InAttributeName";
  State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
  State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
  State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
  State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
  State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
  State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
  State2[State2["InDeclaration"] = 16] = "InDeclaration";
  State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
  State2[State2["BeforeComment"] = 18] = "BeforeComment";
  State2[State2["CDATASequence"] = 19] = "CDATASequence";
  State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
  State2[State2["InCommentLike"] = 21] = "InCommentLike";
  State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
  State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
  State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
  State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
  State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
  State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
  State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
  State2[State2["InHexEntity"] = 29] = "InHexEntity";
})(State || (State = {}));
function isWhitespace$2(c) {
  return c === CharCodes.Space || c === CharCodes.NewLine || c === CharCodes.Tab || c === CharCodes.FormFeed || c === CharCodes.CarriageReturn;
}
function isEndOfTagSection(c) {
  return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace$2(c);
}
function isNumber(c) {
  return c >= CharCodes.Zero && c <= CharCodes.Nine;
}
function isASCIIAlpha(c) {
  return c >= CharCodes.LowerA && c <= CharCodes.LowerZ || c >= CharCodes.UpperA && c <= CharCodes.UpperZ;
}
function isHexDigit(c) {
  return c >= CharCodes.UpperA && c <= CharCodes.UpperF || c >= CharCodes.LowerA && c <= CharCodes.LowerF;
}
var QuoteType;
(function(QuoteType2) {
  QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
  QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
  QuoteType2[QuoteType2["Single"] = 2] = "Single";
  QuoteType2[QuoteType2["Double"] = 3] = "Double";
})(QuoteType || (QuoteType = {}));
const Sequences = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
let Tokenizer$9 = class Tokenizer2 {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = void 0;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = void 0;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c) {
    if (c === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      isEndOfTagSection(c)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (c | 32) === this.currentSequence[this.sequenceIndex]
    );
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(c) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c === CharCodes.Gt || isWhitespace$2(c)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c === CharCodes.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c === CharCodes.Lt);
    }
  }
  stateCDATASequence(c) {
    if (c === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c);
    }
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(c) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(c) {
    if (c === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(c) {
    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c) {
    if (c === CharCodes.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c)) {
      const lower = c | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c === CharCodes.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c);
    }
  }
  stateInTagName(c) {
    if (isEndOfTagSection(c)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateBeforeClosingTagName(c) {
    if (isWhitespace$2(c))
      ;
    else if (c === CharCodes.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c) {
    if (c === CharCodes.Gt || isWhitespace$2(c)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c);
    }
  }
  stateAfterClosingTagName(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c) {
    if (c === CharCodes.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace$2(c)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c) {
    if (c === CharCodes.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace$2(c)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    }
  }
  stateInAttributeName(c) {
    if (c === CharCodes.Eq || isEndOfTagSection(c)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c);
    }
  }
  stateAfterAttributeName(c) {
    if (c === CharCodes.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c === CharCodes.Slash || c === CharCodes.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (!isWhitespace$2(c)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c) {
    if (c === CharCodes.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c === CharCodes.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace$2(c)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c);
    }
  }
  handleInAttributeValue(c, quote) {
    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c) {
    this.handleInAttributeValue(c, CharCodes.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c) {
    if (isWhitespace$2(c) || c === CharCodes.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c);
    } else if (this.decodeEntities && c === CharCodes.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c) {
    if (c === CharCodes.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c) {
    if (c === CharCodes.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c) {
    if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c) {
    const lower = c | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c);
    }
  }
  stateBeforeEntity(c) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c === CharCodes.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c === CharCodes.Amp)
      ;
    else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c);
    }
  }
  stateInNamedEntity(c) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c) {
    if ((c | 32) === CharCodes.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c) {
    if (c === CharCodes.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber(c)) {
      this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c) {
    if (c === CharCodes.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber(c)) {
      this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c)) {
      this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    while (this.shouldContinue()) {
      const c = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName)
      ;
    else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
};
const formTags$1 = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]);
const pTag = /* @__PURE__ */ new Set(["p"]);
const tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
const ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
const rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
const openImpliesClose$1 = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", pTag],
  ["h1", pTag],
  ["h2", pTag],
  ["h3", pTag],
  ["h4", pTag],
  ["h5", pTag],
  ["h6", pTag],
  ["select", formTags$1],
  ["input", formTags$1],
  ["output", formTags$1],
  ["button", formTags$1],
  ["datalist", formTags$1],
  ["textarea", formTags$1],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", ddtTags],
  ["dt", ddtTags],
  ["address", pTag],
  ["article", pTag],
  ["aside", pTag],
  ["blockquote", pTag],
  ["details", pTag],
  ["div", pTag],
  ["dl", pTag],
  ["fieldset", pTag],
  ["figcaption", pTag],
  ["figure", pTag],
  ["footer", pTag],
  ["form", pTag],
  ["header", pTag],
  ["hr", pTag],
  ["main", pTag],
  ["nav", pTag],
  ["ol", pTag],
  ["pre", pTag],
  ["section", pTag],
  ["table", pTag],
  ["ul", pTag],
  ["rt", rtpTags],
  ["rp", rtpTags],
  ["tbody", tableSectionTags],
  ["tfoot", tableSectionTags]
]);
const voidElements$1 = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
const foreignContextElements$1 = /* @__PURE__ */ new Set(["math", "svg"]);
const htmlIntegrationElements$1 = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]);
const reNameEnd = /\s|\//;
let Parser$4 = class Parser2 {
  constructor(cbs, options2 = {}) {
    var _a2, _b, _c, _d, _e;
    this.options = options2;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
    this.lowerCaseTagNames = (_a2 = options2.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options2.xmlMode;
    this.lowerCaseAttributeNames = (_b = options2.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options2.xmlMode;
    this.tokenizer = new ((_c = options2.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer$9)(this.options, this);
    (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(start, endIndex) {
    var _a2, _b;
    const data2 = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, data2);
    this.startIndex = endIndex;
  }
  /** @internal */
  ontextentity(cp) {
    var _a2, _b;
    const index2 = this.tokenizer.getSectionStart();
    this.endIndex = index2 - 1;
    (_b = (_a2 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a2, fromCodePoint(cp));
    this.startIndex = index2;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements$1.has(name2);
  }
  /** @internal */
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a2, _b, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose$1.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element2 = this.stack.pop();
        (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, element2, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements$1.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements$1.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a2, _b;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b = (_a2 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a2, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  /** @internal */
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onclosetag(start, endIndex) {
    var _a2, _b, _c, _d, _e, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements$1.has(name2) || htmlIntegrationElements$1.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b = (_a2 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a2, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
      (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a2, _b;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b = (_a2 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a2, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  /** @internal */
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  /** @internal */
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  /** @internal */
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  /** @internal */
  onattribend(quote, endIndex) {
    var _a2, _b;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a2, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? void 0 : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index2 = value.search(reNameEnd);
    let name2 = index2 < 0 ? value : value.substr(0, index2);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  /** @internal */
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncomment(start, endIndex, offset) {
    var _a2, _b, _c, _d;
    this.endIndex = endIndex;
    (_b = (_a2 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  oncdata(start, endIndex, offset) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b = (_a2 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a2);
      (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
      (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  /** @internal */
  onend() {
    var _a2, _b;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
        ;
    }
    (_b = (_a2 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var _a2, _b, _c, _d;
    (_b = (_a2 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a2);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(data2) {
    this.reset();
    this.end(data2);
  }
  getSlice(start, end2) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice2 = this.buffers[0].slice(start - this.bufferOffset, end2 - this.bufferOffset);
    while (end2 - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice2 += this.buffers[0].slice(0, end2 - this.bufferOffset);
    }
    return slice2;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(chunk) {
    var _a2, _b;
    if (this.ended) {
      (_b = (_a2 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a2, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(chunk) {
    this.write(chunk);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(chunk) {
    this.end(chunk);
  }
};
function parseDocument(data2, options2) {
  const handler = new DomHandler$1(void 0, options2);
  new Parser$4(handler, options2).end(data2);
  return handler.root;
}
const parse$7 = getParse((content, options2, isDocument2, context) => options2.xmlMode || options2._useHtmlParser2 ? parseDocument(content, options2) : parseWithParse5(content, options2, isDocument2, context));
const load = getLoad(parse$7, (dom, options2) => options2.xmlMode || options2._useHtmlParser2 ? render$3(dom, options2) : renderWithParse5(dom));
load([]);
var lib$2 = {};
var cheerioExports$1 = {};
var cheerio$1 = {
  get exports() {
    return cheerioExports$1;
  },
  set exports(v) {
    cheerioExports$1 = v;
  }
};
var cheerioExports = {};
var cheerio = {
  get exports() {
    return cheerioExports;
  },
  set exports(v) {
    cheerioExports = v;
  }
};
var parseExports = {};
var parse$6 = {
  get exports() {
    return parseExports;
  },
  set exports(v) {
    parseExports = v;
  }
};
var libExports = {};
var lib$1 = {
  get exports() {
    return libExports;
  },
  set exports(v) {
    libExports = v;
  }
};
const require$$0$1 = {
  "0": 65533,
  "128": 8364,
  "130": 8218,
  "131": 402,
  "132": 8222,
  "133": 8230,
  "134": 8224,
  "135": 8225,
  "136": 710,
  "137": 8240,
  "138": 352,
  "139": 8249,
  "140": 338,
  "142": 381,
  "145": 8216,
  "146": 8217,
  "147": 8220,
  "148": 8221,
  "149": 8226,
  "150": 8211,
  "151": 8212,
  "152": 732,
  "153": 8482,
  "154": 353,
  "155": 8250,
  "156": 339,
  "158": 382,
  "159": 376
};
var decodeMap = require$$0$1;
var decode_codepoint = decodeCodePoint$2;
function decodeCodePoint$2(codePoint) {
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return "ï¿½";
  }
  if (codePoint in decodeMap) {
    codePoint = decodeMap[codePoint];
  }
  var output = "";
  if (codePoint > 65535) {
    codePoint -= 65536;
    output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
    codePoint = 56320 | codePoint & 1023;
  }
  output += String.fromCharCode(codePoint);
  return output;
}
const Aacute$1 = "Ã";
const aacute$1 = "Ã¡";
const Abreve = "Ä‚";
const abreve = "Äƒ";
const ac = "âˆ¾";
const acd = "âˆ¿";
const acE = "âˆ¾Ì³";
const Acirc$1 = "Ã‚";
const acirc$1 = "Ã¢";
const acute$1 = "Â´";
const Acy = "Ğ";
const acy = "Ğ°";
const AElig$1 = "Ã†";
const aelig$1 = "Ã¦";
const af = "â¡";
const Afr = "ğ”„";
const afr = "ğ”";
const Agrave$1 = "Ã€";
const agrave$1 = "Ã ";
const alefsym = "â„µ";
const aleph = "â„µ";
const Alpha = "Î‘";
const alpha = "Î±";
const Amacr = "Ä€";
const amacr = "Ä";
const amalg = "â¨¿";
const amp$2 = "&";
const AMP$1 = "&";
const andand = "â©•";
const And = "â©“";
const and = "âˆ§";
const andd = "â©œ";
const andslope = "â©˜";
const andv = "â©š";
const ang = "âˆ ";
const ange = "â¦¤";
const angle = "âˆ ";
const angmsdaa = "â¦¨";
const angmsdab = "â¦©";
const angmsdac = "â¦ª";
const angmsdad = "â¦«";
const angmsdae = "â¦¬";
const angmsdaf = "â¦­";
const angmsdag = "â¦®";
const angmsdah = "â¦¯";
const angmsd = "âˆ¡";
const angrt = "âˆŸ";
const angrtvb = "âŠ¾";
const angrtvbd = "â¦";
const angsph = "âˆ¢";
const angst = "Ã…";
const angzarr = "â¼";
const Aogon = "Ä„";
const aogon = "Ä…";
const Aopf = "ğ”¸";
const aopf = "ğ•’";
const apacir = "â©¯";
const ap = "â‰ˆ";
const apE = "â©°";
const ape = "â‰Š";
const apid = "â‰‹";
const apos$1 = "'";
const ApplyFunction = "â¡";
const approx = "â‰ˆ";
const approxeq = "â‰Š";
const Aring$1 = "Ã…";
const aring$1 = "Ã¥";
const Ascr = "ğ’œ";
const ascr = "ğ’¶";
const Assign = "â‰”";
const ast = "*";
const asymp = "â‰ˆ";
const asympeq = "â‰";
const Atilde$1 = "Ãƒ";
const atilde$1 = "Ã£";
const Auml$1 = "Ã„";
const auml$1 = "Ã¤";
const awconint = "âˆ³";
const awint = "â¨‘";
const backcong = "â‰Œ";
const backepsilon = "Ï¶";
const backprime = "â€µ";
const backsim = "âˆ½";
const backsimeq = "â‹";
const Backslash = "âˆ–";
const Barv = "â«§";
const barvee = "âŠ½";
const barwed = "âŒ…";
const Barwed = "âŒ†";
const barwedge = "âŒ…";
const bbrk = "âµ";
const bbrktbrk = "â¶";
const bcong = "â‰Œ";
const Bcy = "Ğ‘";
const bcy = "Ğ±";
const bdquo = "â€";
const becaus = "âˆµ";
const because = "âˆµ";
const Because = "âˆµ";
const bemptyv = "â¦°";
const bepsi = "Ï¶";
const bernou = "â„¬";
const Bernoullis = "â„¬";
const Beta = "Î’";
const beta = "Î²";
const beth = "â„¶";
const between = "â‰¬";
const Bfr = "ğ”…";
const bfr = "ğ”Ÿ";
const bigcap = "â‹‚";
const bigcirc = "â—¯";
const bigcup = "â‹ƒ";
const bigodot = "â¨€";
const bigoplus = "â¨";
const bigotimes = "â¨‚";
const bigsqcup = "â¨†";
const bigstar = "â˜…";
const bigtriangledown = "â–½";
const bigtriangleup = "â–³";
const biguplus = "â¨„";
const bigvee = "â‹";
const bigwedge = "â‹€";
const bkarow = "â¤";
const blacklozenge = "â§«";
const blacksquare = "â–ª";
const blacktriangle = "â–´";
const blacktriangledown = "â–¾";
const blacktriangleleft = "â—‚";
const blacktriangleright = "â–¸";
const blank = "â£";
const blk12 = "â–’";
const blk14 = "â–‘";
const blk34 = "â–“";
const block = "â–ˆ";
const bne = "=âƒ¥";
const bnequiv = "â‰¡âƒ¥";
const bNot = "â«­";
const bnot = "âŒ";
const Bopf = "ğ”¹";
const bopf = "ğ•“";
const bot = "âŠ¥";
const bottom = "âŠ¥";
const bowtie = "â‹ˆ";
const boxbox = "â§‰";
const boxdl = "â”";
const boxdL = "â••";
const boxDl = "â•–";
const boxDL = "â•—";
const boxdr = "â”Œ";
const boxdR = "â•’";
const boxDr = "â•“";
const boxDR = "â•”";
const boxh = "â”€";
const boxH = "â•";
const boxhd = "â”¬";
const boxHd = "â•¤";
const boxhD = "â•¥";
const boxHD = "â•¦";
const boxhu = "â”´";
const boxHu = "â•§";
const boxhU = "â•¨";
const boxHU = "â•©";
const boxminus = "âŠŸ";
const boxplus = "âŠ";
const boxtimes = "âŠ ";
const boxul = "â”˜";
const boxuL = "â•›";
const boxUl = "â•œ";
const boxUL = "â•";
const boxur = "â””";
const boxuR = "â•˜";
const boxUr = "â•™";
const boxUR = "â•š";
const boxv = "â”‚";
const boxV = "â•‘";
const boxvh = "â”¼";
const boxvH = "â•ª";
const boxVh = "â•«";
const boxVH = "â•¬";
const boxvl = "â”¤";
const boxvL = "â•¡";
const boxVl = "â•¢";
const boxVL = "â•£";
const boxvr = "â”œ";
const boxvR = "â•";
const boxVr = "â•Ÿ";
const boxVR = "â• ";
const bprime = "â€µ";
const breve = "Ë˜";
const Breve = "Ë˜";
const brvbar$1 = "Â¦";
const bscr = "ğ’·";
const Bscr = "â„¬";
const bsemi = "â";
const bsim = "âˆ½";
const bsime = "â‹";
const bsolb = "â§…";
const bsol = "\\";
const bsolhsub = "âŸˆ";
const bull = "â€¢";
const bullet = "â€¢";
const bump = "â‰";
const bumpE = "âª®";
const bumpe = "â‰";
const Bumpeq = "â‰";
const bumpeq = "â‰";
const Cacute = "Ä†";
const cacute = "Ä‡";
const capand = "â©„";
const capbrcup = "â©‰";
const capcap = "â©‹";
const cap = "âˆ©";
const Cap = "â‹’";
const capcup = "â©‡";
const capdot = "â©€";
const CapitalDifferentialD = "â……";
const caps = "âˆ©ï¸€";
const caret = "â";
const caron = "Ë‡";
const Cayleys = "â„­";
const ccaps = "â©";
const Ccaron = "ÄŒ";
const ccaron = "Ä";
const Ccedil$1 = "Ã‡";
const ccedil$1 = "Ã§";
const Ccirc = "Äˆ";
const ccirc = "Ä‰";
const Cconint = "âˆ°";
const ccups = "â©Œ";
const ccupssm = "â©";
const Cdot = "ÄŠ";
const cdot = "Ä‹";
const cedil$1 = "Â¸";
const Cedilla = "Â¸";
const cemptyv = "â¦²";
const cent$1 = "Â¢";
const centerdot = "Â·";
const CenterDot = "Â·";
const cfr = "ğ” ";
const Cfr = "â„­";
const CHcy = "Ğ§";
const chcy = "Ñ‡";
const check = "âœ“";
const checkmark = "âœ“";
const Chi = "Î§";
const chi = "Ï‡";
const circ = "Ë†";
const circeq = "â‰—";
const circlearrowleft = "â†º";
const circlearrowright = "â†»";
const circledast = "âŠ›";
const circledcirc = "âŠš";
const circleddash = "âŠ";
const CircleDot = "âŠ™";
const circledR = "Â®";
const circledS = "â“ˆ";
const CircleMinus = "âŠ–";
const CirclePlus = "âŠ•";
const CircleTimes = "âŠ—";
const cir = "â—‹";
const cirE = "â§ƒ";
const cire = "â‰—";
const cirfnint = "â¨";
const cirmid = "â«¯";
const cirscir = "â§‚";
const ClockwiseContourIntegral = "âˆ²";
const CloseCurlyDoubleQuote = "â€";
const CloseCurlyQuote = "â€™";
const clubs = "â™£";
const clubsuit = "â™£";
const colon = ":";
const Colon = "âˆ·";
const Colone = "â©´";
const colone = "â‰”";
const coloneq = "â‰”";
const comma = ",";
const commat = "@";
const comp = "âˆ";
const compfn = "âˆ˜";
const complement = "âˆ";
const complexes = "â„‚";
const cong = "â‰…";
const congdot = "â©­";
const Congruent = "â‰¡";
const conint = "âˆ®";
const Conint = "âˆ¯";
const ContourIntegral = "âˆ®";
const copf = "ğ•”";
const Copf = "â„‚";
const coprod = "âˆ";
const Coproduct = "âˆ";
const copy$1 = "Â©";
const COPY$1 = "Â©";
const copysr = "â„—";
const CounterClockwiseContourIntegral = "âˆ³";
const crarr = "â†µ";
const cross = "âœ—";
const Cross = "â¨¯";
const Cscr = "ğ’";
const cscr = "ğ’¸";
const csub = "â«";
const csube = "â«‘";
const csup = "â«";
const csupe = "â«’";
const ctdot = "â‹¯";
const cudarrl = "â¤¸";
const cudarrr = "â¤µ";
const cuepr = "â‹";
const cuesc = "â‹Ÿ";
const cularr = "â†¶";
const cularrp = "â¤½";
const cupbrcap = "â©ˆ";
const cupcap = "â©†";
const CupCap = "â‰";
const cup = "âˆª";
const Cup = "â‹“";
const cupcup = "â©Š";
const cupdot = "âŠ";
const cupor = "â©…";
const cups = "âˆªï¸€";
const curarr = "â†·";
const curarrm = "â¤¼";
const curlyeqprec = "â‹";
const curlyeqsucc = "â‹Ÿ";
const curlyvee = "â‹";
const curlywedge = "â‹";
const curren$1 = "Â¤";
const curvearrowleft = "â†¶";
const curvearrowright = "â†·";
const cuvee = "â‹";
const cuwed = "â‹";
const cwconint = "âˆ²";
const cwint = "âˆ±";
const cylcty = "âŒ­";
const dagger = "â€ ";
const Dagger = "â€¡";
const daleth = "â„¸";
const darr = "â†“";
const Darr = "â†¡";
const dArr = "â‡“";
const dash = "â€";
const Dashv = "â«¤";
const dashv = "âŠ£";
const dbkarow = "â¤";
const dblac = "Ë";
const Dcaron = "Ä";
const dcaron = "Ä";
const Dcy = "Ğ”";
const dcy = "Ğ´";
const ddagger = "â€¡";
const ddarr = "â‡Š";
const DD = "â……";
const dd = "â…†";
const DDotrahd = "â¤‘";
const ddotseq = "â©·";
const deg$1 = "Â°";
const Del = "âˆ‡";
const Delta = "Î”";
const delta = "Î´";
const demptyv = "â¦±";
const dfisht = "â¥¿";
const Dfr = "ğ”‡";
const dfr = "ğ”¡";
const dHar = "â¥¥";
const dharl = "â‡ƒ";
const dharr = "â‡‚";
const DiacriticalAcute = "Â´";
const DiacriticalDot = "Ë™";
const DiacriticalDoubleAcute = "Ë";
const DiacriticalGrave = "`";
const DiacriticalTilde = "Ëœ";
const diam = "â‹„";
const diamond = "â‹„";
const Diamond = "â‹„";
const diamondsuit = "â™¦";
const diams = "â™¦";
const die = "Â¨";
const DifferentialD = "â…†";
const digamma = "Ï";
const disin = "â‹²";
const div = "Ã·";
const divide$1 = "Ã·";
const divideontimes = "â‹‡";
const divonx = "â‹‡";
const DJcy = "Ğ‚";
const djcy = "Ñ’";
const dlcorn = "âŒ";
const dlcrop = "âŒ";
const dollar = "$";
const Dopf = "ğ”»";
const dopf = "ğ••";
const Dot = "Â¨";
const dot = "Ë™";
const DotDot = "âƒœ";
const doteq = "â‰";
const doteqdot = "â‰‘";
const DotEqual = "â‰";
const dotminus = "âˆ¸";
const dotplus = "âˆ”";
const dotsquare = "âŠ¡";
const doublebarwedge = "âŒ†";
const DoubleContourIntegral = "âˆ¯";
const DoubleDot = "Â¨";
const DoubleDownArrow = "â‡“";
const DoubleLeftArrow = "â‡";
const DoubleLeftRightArrow = "â‡”";
const DoubleLeftTee = "â«¤";
const DoubleLongLeftArrow = "âŸ¸";
const DoubleLongLeftRightArrow = "âŸº";
const DoubleLongRightArrow = "âŸ¹";
const DoubleRightArrow = "â‡’";
const DoubleRightTee = "âŠ¨";
const DoubleUpArrow = "â‡‘";
const DoubleUpDownArrow = "â‡•";
const DoubleVerticalBar = "âˆ¥";
const DownArrowBar = "â¤“";
const downarrow = "â†“";
const DownArrow = "â†“";
const Downarrow = "â‡“";
const DownArrowUpArrow = "â‡µ";
const DownBreve = "Ì‘";
const downdownarrows = "â‡Š";
const downharpoonleft = "â‡ƒ";
const downharpoonright = "â‡‚";
const DownLeftRightVector = "â¥";
const DownLeftTeeVector = "â¥";
const DownLeftVectorBar = "â¥–";
const DownLeftVector = "â†½";
const DownRightTeeVector = "â¥Ÿ";
const DownRightVectorBar = "â¥—";
const DownRightVector = "â‡";
const DownTeeArrow = "â†§";
const DownTee = "âŠ¤";
const drbkarow = "â¤";
const drcorn = "âŒŸ";
const drcrop = "âŒŒ";
const Dscr = "ğ’Ÿ";
const dscr = "ğ’¹";
const DScy = "Ğ…";
const dscy = "Ñ•";
const dsol = "â§¶";
const Dstrok = "Ä";
const dstrok = "Ä‘";
const dtdot = "â‹±";
const dtri = "â–¿";
const dtrif = "â–¾";
const duarr = "â‡µ";
const duhar = "â¥¯";
const dwangle = "â¦¦";
const DZcy = "Ğ";
const dzcy = "ÑŸ";
const dzigrarr = "âŸ¿";
const Eacute$1 = "Ã‰";
const eacute$1 = "Ã©";
const easter = "â©®";
const Ecaron = "Äš";
const ecaron = "Ä›";
const Ecirc$1 = "ÃŠ";
const ecirc$1 = "Ãª";
const ecir = "â‰–";
const ecolon = "â‰•";
const Ecy = "Ğ­";
const ecy = "Ñ";
const eDDot = "â©·";
const Edot = "Ä–";
const edot = "Ä—";
const eDot = "â‰‘";
const ee = "â…‡";
const efDot = "â‰’";
const Efr = "ğ”ˆ";
const efr = "ğ”¢";
const eg = "âªš";
const Egrave$1 = "Ãˆ";
const egrave$1 = "Ã¨";
const egs = "âª–";
const egsdot = "âª˜";
const el = "âª™";
const Element2 = "âˆˆ";
const elinters = "â§";
const ell = "â„“";
const els = "âª•";
const elsdot = "âª—";
const Emacr = "Ä’";
const emacr = "Ä“";
const empty = "âˆ…";
const emptyset = "âˆ…";
const EmptySmallSquare = "â—»";
const emptyv = "âˆ…";
const EmptyVerySmallSquare = "â–«";
const emsp13 = "â€„";
const emsp14 = "â€…";
const emsp = "â€ƒ";
const ENG = "ÅŠ";
const eng = "Å‹";
const ensp = "â€‚";
const Eogon = "Ä˜";
const eogon = "Ä™";
const Eopf = "ğ”¼";
const eopf = "ğ•–";
const epar = "â‹•";
const eparsl = "â§£";
const eplus = "â©±";
const epsi = "Îµ";
const Epsilon = "Î•";
const epsilon = "Îµ";
const epsiv = "Ïµ";
const eqcirc = "â‰–";
const eqcolon = "â‰•";
const eqsim = "â‰‚";
const eqslantgtr = "âª–";
const eqslantless = "âª•";
const Equal = "â©µ";
const equals = "=";
const EqualTilde = "â‰‚";
const equest = "â‰Ÿ";
const Equilibrium = "â‡Œ";
const equiv = "â‰¡";
const equivDD = "â©¸";
const eqvparsl = "â§¥";
const erarr = "â¥±";
const erDot = "â‰“";
const escr = "â„¯";
const Escr = "â„°";
const esdot = "â‰";
const Esim = "â©³";
const esim = "â‰‚";
const Eta = "Î—";
const eta = "Î·";
const ETH$1 = "Ã";
const eth$1 = "Ã°";
const Euml$1 = "Ã‹";
const euml$1 = "Ã«";
const euro = "â‚¬";
const excl = "!";
const exist = "âˆƒ";
const Exists = "âˆƒ";
const expectation = "â„°";
const exponentiale = "â…‡";
const ExponentialE = "â…‡";
const fallingdotseq = "â‰’";
const Fcy = "Ğ¤";
const fcy = "Ñ„";
const female = "â™€";
const ffilig = "ï¬ƒ";
const fflig = "ï¬€";
const ffllig = "ï¬„";
const Ffr = "ğ”‰";
const ffr = "ğ”£";
const filig = "ï¬";
const FilledSmallSquare = "â—¼";
const FilledVerySmallSquare = "â–ª";
const fjlig = "fj";
const flat = "â™­";
const fllig = "ï¬‚";
const fltns = "â–±";
const fnof = "Æ’";
const Fopf = "ğ”½";
const fopf = "ğ•—";
const forall = "âˆ€";
const ForAll = "âˆ€";
const fork = "â‹”";
const forkv = "â«™";
const Fouriertrf = "â„±";
const fpartint = "â¨";
const frac12$1 = "Â½";
const frac13 = "â…“";
const frac14$1 = "Â¼";
const frac15 = "â…•";
const frac16 = "â…™";
const frac18 = "â…›";
const frac23 = "â…”";
const frac25 = "â…–";
const frac34$1 = "Â¾";
const frac35 = "â…—";
const frac38 = "â…œ";
const frac45 = "â…˜";
const frac56 = "â…š";
const frac58 = "â…";
const frac78 = "â…";
const frasl = "â„";
const frown = "âŒ¢";
const fscr = "ğ’»";
const Fscr = "â„±";
const gacute = "Çµ";
const Gamma = "Î“";
const gamma = "Î³";
const Gammad = "Ïœ";
const gammad = "Ï";
const gap = "âª†";
const Gbreve = "Ä";
const gbreve = "ÄŸ";
const Gcedil = "Ä¢";
const Gcirc = "Äœ";
const gcirc = "Ä";
const Gcy = "Ğ“";
const gcy = "Ğ³";
const Gdot = "Ä ";
const gdot = "Ä¡";
const ge = "â‰¥";
const gE = "â‰§";
const gEl = "âªŒ";
const gel = "â‹›";
const geq = "â‰¥";
const geqq = "â‰§";
const geqslant = "â©¾";
const gescc = "âª©";
const ges = "â©¾";
const gesdot = "âª€";
const gesdoto = "âª‚";
const gesdotol = "âª„";
const gesl = "â‹›ï¸€";
const gesles = "âª”";
const Gfr = "ğ”Š";
const gfr = "ğ”¤";
const gg = "â‰«";
const Gg = "â‹™";
const ggg = "â‹™";
const gimel = "â„·";
const GJcy = "Ğƒ";
const gjcy = "Ñ“";
const gla = "âª¥";
const gl = "â‰·";
const glE = "âª’";
const glj = "âª¤";
const gnap = "âªŠ";
const gnapprox = "âªŠ";
const gne = "âªˆ";
const gnE = "â‰©";
const gneq = "âªˆ";
const gneqq = "â‰©";
const gnsim = "â‹§";
const Gopf = "ğ”¾";
const gopf = "ğ•˜";
const grave = "`";
const GreaterEqual = "â‰¥";
const GreaterEqualLess = "â‹›";
const GreaterFullEqual = "â‰§";
const GreaterGreater = "âª¢";
const GreaterLess = "â‰·";
const GreaterSlantEqual = "â©¾";
const GreaterTilde = "â‰³";
const Gscr = "ğ’¢";
const gscr = "â„Š";
const gsim = "â‰³";
const gsime = "âª";
const gsiml = "âª";
const gtcc = "âª§";
const gtcir = "â©º";
const gt$2 = ">";
const GT$1 = ">";
const Gt = "â‰«";
const gtdot = "â‹—";
const gtlPar = "â¦•";
const gtquest = "â©¼";
const gtrapprox = "âª†";
const gtrarr = "â¥¸";
const gtrdot = "â‹—";
const gtreqless = "â‹›";
const gtreqqless = "âªŒ";
const gtrless = "â‰·";
const gtrsim = "â‰³";
const gvertneqq = "â‰©ï¸€";
const gvnE = "â‰©ï¸€";
const Hacek = "Ë‡";
const hairsp = "â€Š";
const half = "Â½";
const hamilt = "â„‹";
const HARDcy = "Ğª";
const hardcy = "ÑŠ";
const harrcir = "â¥ˆ";
const harr = "â†”";
const hArr = "â‡”";
const harrw = "â†­";
const Hat = "^";
const hbar = "â„";
const Hcirc = "Ä¤";
const hcirc = "Ä¥";
const hearts = "â™¥";
const heartsuit = "â™¥";
const hellip = "â€¦";
const hercon = "âŠ¹";
const hfr = "ğ”¥";
const Hfr = "â„Œ";
const HilbertSpace = "â„‹";
const hksearow = "â¤¥";
const hkswarow = "â¤¦";
const hoarr = "â‡¿";
const homtht = "âˆ»";
const hookleftarrow = "â†©";
const hookrightarrow = "â†ª";
const hopf = "ğ•™";
const Hopf = "â„";
const horbar = "â€•";
const HorizontalLine = "â”€";
const hscr = "ğ’½";
const Hscr = "â„‹";
const hslash = "â„";
const Hstrok = "Ä¦";
const hstrok = "Ä§";
const HumpDownHump = "â‰";
const HumpEqual = "â‰";
const hybull = "âƒ";
const hyphen = "â€";
const Iacute$1 = "Ã";
const iacute$1 = "Ã­";
const ic = "â£";
const Icirc$1 = "Ã";
const icirc$1 = "Ã®";
const Icy = "Ğ˜";
const icy = "Ğ¸";
const Idot = "Ä°";
const IEcy = "Ğ•";
const iecy = "Ğµ";
const iexcl$1 = "Â¡";
const iff = "â‡”";
const ifr = "ğ”¦";
const Ifr = "â„‘";
const Igrave$1 = "ÃŒ";
const igrave$1 = "Ã¬";
const ii = "â…ˆ";
const iiiint = "â¨Œ";
const iiint = "âˆ­";
const iinfin = "â§œ";
const iiota = "â„©";
const IJlig = "Ä²";
const ijlig = "Ä³";
const Imacr = "Äª";
const imacr = "Ä«";
const image = "â„‘";
const ImaginaryI = "â…ˆ";
const imagline = "â„";
const imagpart = "â„‘";
const imath = "Ä±";
const Im = "â„‘";
const imof = "âŠ·";
const imped = "Æµ";
const Implies = "â‡’";
const incare = "â„…";
const infin = "âˆ";
const infintie = "â§";
const inodot = "Ä±";
const intcal = "âŠº";
const int = "âˆ«";
const Int = "âˆ¬";
const integers = "â„¤";
const Integral = "âˆ«";
const intercal = "âŠº";
const Intersection = "â‹‚";
const intlarhk = "â¨—";
const intprod = "â¨¼";
const InvisibleComma = "â£";
const InvisibleTimes = "â¢";
const IOcy = "Ğ";
const iocy = "Ñ‘";
const Iogon = "Ä®";
const iogon = "Ä¯";
const Iopf = "ğ•€";
const iopf = "ğ•š";
const Iota = "Î™";
const iota = "Î¹";
const iprod = "â¨¼";
const iquest$1 = "Â¿";
const iscr = "ğ’¾";
const Iscr = "â„";
const isin = "âˆˆ";
const isindot = "â‹µ";
const isinE = "â‹¹";
const isins = "â‹´";
const isinsv = "â‹³";
const isinv = "âˆˆ";
const it = "â¢";
const Itilde = "Ä¨";
const itilde = "Ä©";
const Iukcy = "Ğ†";
const iukcy = "Ñ–";
const Iuml$1 = "Ã";
const iuml$1 = "Ã¯";
const Jcirc = "Ä´";
const jcirc = "Äµ";
const Jcy = "Ğ™";
const jcy = "Ğ¹";
const Jfr = "ğ”";
const jfr = "ğ”§";
const jmath = "È·";
const Jopf = "ğ•";
const jopf = "ğ•›";
const Jscr = "ğ’¥";
const jscr = "ğ’¿";
const Jsercy = "Ğˆ";
const jsercy = "Ñ˜";
const Jukcy = "Ğ„";
const jukcy = "Ñ”";
const Kappa = "Îš";
const kappa = "Îº";
const kappav = "Ï°";
const Kcedil = "Ä¶";
const kcedil = "Ä·";
const Kcy = "Ğš";
const kcy = "Ğº";
const Kfr = "ğ”";
const kfr = "ğ”¨";
const kgreen = "Ä¸";
const KHcy = "Ğ¥";
const khcy = "Ñ…";
const KJcy = "ĞŒ";
const kjcy = "Ñœ";
const Kopf = "ğ•‚";
const kopf = "ğ•œ";
const Kscr = "ğ’¦";
const kscr = "ğ“€";
const lAarr = "â‡š";
const Lacute = "Ä¹";
const lacute = "Äº";
const laemptyv = "â¦´";
const lagran = "â„’";
const Lambda = "Î›";
const lambda = "Î»";
const lang = "âŸ¨";
const Lang = "âŸª";
const langd = "â¦‘";
const langle = "âŸ¨";
const lap = "âª…";
const Laplacetrf = "â„’";
const laquo$1 = "Â«";
const larrb = "â‡¤";
const larrbfs = "â¤Ÿ";
const larr = "â†";
const Larr = "â†";
const lArr = "â‡";
const larrfs = "â¤";
const larrhk = "â†©";
const larrlp = "â†«";
const larrpl = "â¤¹";
const larrsim = "â¥³";
const larrtl = "â†¢";
const latail = "â¤™";
const lAtail = "â¤›";
const lat = "âª«";
const late = "âª­";
const lates = "âª­ï¸€";
const lbarr = "â¤Œ";
const lBarr = "â¤";
const lbbrk = "â²";
const lbrace = "{";
const lbrack = "[";
const lbrke = "â¦‹";
const lbrksld = "â¦";
const lbrkslu = "â¦";
const Lcaron = "Ä½";
const lcaron = "Ä¾";
const Lcedil = "Ä»";
const lcedil = "Ä¼";
const lceil = "âŒˆ";
const lcub = "{";
const Lcy = "Ğ›";
const lcy = "Ğ»";
const ldca = "â¤¶";
const ldquo = "â€œ";
const ldquor = "â€";
const ldrdhar = "â¥§";
const ldrushar = "â¥‹";
const ldsh = "â†²";
const le = "â‰¤";
const lE = "â‰¦";
const LeftAngleBracket = "âŸ¨";
const LeftArrowBar = "â‡¤";
const leftarrow = "â†";
const LeftArrow = "â†";
const Leftarrow = "â‡";
const LeftArrowRightArrow = "â‡†";
const leftarrowtail = "â†¢";
const LeftCeiling = "âŒˆ";
const LeftDoubleBracket = "âŸ¦";
const LeftDownTeeVector = "â¥¡";
const LeftDownVectorBar = "â¥™";
const LeftDownVector = "â‡ƒ";
const LeftFloor = "âŒŠ";
const leftharpoondown = "â†½";
const leftharpoonup = "â†¼";
const leftleftarrows = "â‡‡";
const leftrightarrow = "â†”";
const LeftRightArrow = "â†”";
const Leftrightarrow = "â‡”";
const leftrightarrows = "â‡†";
const leftrightharpoons = "â‡‹";
const leftrightsquigarrow = "â†­";
const LeftRightVector = "â¥";
const LeftTeeArrow = "â†¤";
const LeftTee = "âŠ£";
const LeftTeeVector = "â¥š";
const leftthreetimes = "â‹‹";
const LeftTriangleBar = "â§";
const LeftTriangle = "âŠ²";
const LeftTriangleEqual = "âŠ´";
const LeftUpDownVector = "â¥‘";
const LeftUpTeeVector = "â¥ ";
const LeftUpVectorBar = "â¥˜";
const LeftUpVector = "â†¿";
const LeftVectorBar = "â¥’";
const LeftVector = "â†¼";
const lEg = "âª‹";
const leg = "â‹š";
const leq = "â‰¤";
const leqq = "â‰¦";
const leqslant = "â©½";
const lescc = "âª¨";
const les = "â©½";
const lesdot = "â©¿";
const lesdoto = "âª";
const lesdotor = "âªƒ";
const lesg = "â‹šï¸€";
const lesges = "âª“";
const lessapprox = "âª…";
const lessdot = "â‹–";
const lesseqgtr = "â‹š";
const lesseqqgtr = "âª‹";
const LessEqualGreater = "â‹š";
const LessFullEqual = "â‰¦";
const LessGreater = "â‰¶";
const lessgtr = "â‰¶";
const LessLess = "âª¡";
const lesssim = "â‰²";
const LessSlantEqual = "â©½";
const LessTilde = "â‰²";
const lfisht = "â¥¼";
const lfloor = "âŒŠ";
const Lfr = "ğ”";
const lfr = "ğ”©";
const lg = "â‰¶";
const lgE = "âª‘";
const lHar = "â¥¢";
const lhard = "â†½";
const lharu = "â†¼";
const lharul = "â¥ª";
const lhblk = "â–„";
const LJcy = "Ğ‰";
const ljcy = "Ñ™";
const llarr = "â‡‡";
const ll = "â‰ª";
const Ll = "â‹˜";
const llcorner = "âŒ";
const Lleftarrow = "â‡š";
const llhard = "â¥«";
const lltri = "â—º";
const Lmidot = "Ä¿";
const lmidot = "Å€";
const lmoustache = "â°";
const lmoust = "â°";
const lnap = "âª‰";
const lnapprox = "âª‰";
const lne = "âª‡";
const lnE = "â‰¨";
const lneq = "âª‡";
const lneqq = "â‰¨";
const lnsim = "â‹¦";
const loang = "âŸ¬";
const loarr = "â‡½";
const lobrk = "âŸ¦";
const longleftarrow = "âŸµ";
const LongLeftArrow = "âŸµ";
const Longleftarrow = "âŸ¸";
const longleftrightarrow = "âŸ·";
const LongLeftRightArrow = "âŸ·";
const Longleftrightarrow = "âŸº";
const longmapsto = "âŸ¼";
const longrightarrow = "âŸ¶";
const LongRightArrow = "âŸ¶";
const Longrightarrow = "âŸ¹";
const looparrowleft = "â†«";
const looparrowright = "â†¬";
const lopar = "â¦…";
const Lopf = "ğ•ƒ";
const lopf = "ğ•";
const loplus = "â¨­";
const lotimes = "â¨´";
const lowast = "âˆ—";
const lowbar = "_";
const LowerLeftArrow = "â†™";
const LowerRightArrow = "â†˜";
const loz = "â—Š";
const lozenge = "â—Š";
const lozf = "â§«";
const lpar = "(";
const lparlt = "â¦“";
const lrarr = "â‡†";
const lrcorner = "âŒŸ";
const lrhar = "â‡‹";
const lrhard = "â¥­";
const lrm = "â€";
const lrtri = "âŠ¿";
const lsaquo = "â€¹";
const lscr = "ğ“";
const Lscr = "â„’";
const lsh = "â†°";
const Lsh = "â†°";
const lsim = "â‰²";
const lsime = "âª";
const lsimg = "âª";
const lsqb = "[";
const lsquo = "â€˜";
const lsquor = "â€š";
const Lstrok = "Å";
const lstrok = "Å‚";
const ltcc = "âª¦";
const ltcir = "â©¹";
const lt$2 = "<";
const LT$1 = "<";
const Lt = "â‰ª";
const ltdot = "â‹–";
const lthree = "â‹‹";
const ltimes = "â‹‰";
const ltlarr = "â¥¶";
const ltquest = "â©»";
const ltri = "â—ƒ";
const ltrie = "âŠ´";
const ltrif = "â—‚";
const ltrPar = "â¦–";
const lurdshar = "â¥Š";
const luruhar = "â¥¦";
const lvertneqq = "â‰¨ï¸€";
const lvnE = "â‰¨ï¸€";
const macr$1 = "Â¯";
const male = "â™‚";
const malt = "âœ ";
const maltese = "âœ ";
const map$1 = "â†¦";
const mapsto = "â†¦";
const mapstodown = "â†§";
const mapstoleft = "â†¤";
const mapstoup = "â†¥";
const marker = "â–®";
const mcomma = "â¨©";
const Mcy = "Ğœ";
const mcy = "Ğ¼";
const mdash = "â€”";
const mDDot = "âˆº";
const measuredangle = "âˆ¡";
const MediumSpace = "âŸ";
const Mellintrf = "â„³";
const Mfr = "ğ”";
const mfr = "ğ”ª";
const mho = "â„§";
const micro$1 = "Âµ";
const midast = "*";
const midcir = "â«°";
const mid = "âˆ£";
const middot$1 = "Â·";
const minusb = "âŠŸ";
const minus = "âˆ’";
const minusd = "âˆ¸";
const minusdu = "â¨ª";
const MinusPlus = "âˆ“";
const mlcp = "â«›";
const mldr = "â€¦";
const mnplus = "âˆ“";
const models = "âŠ§";
const Mopf = "ğ•„";
const mopf = "ğ•";
const mp = "âˆ“";
const mscr = "ğ“‚";
const Mscr = "â„³";
const mstpos = "âˆ¾";
const Mu = "Îœ";
const mu = "Î¼";
const multimap = "âŠ¸";
const mumap = "âŠ¸";
const nabla = "âˆ‡";
const Nacute = "Åƒ";
const nacute = "Å„";
const nang = "âˆ âƒ’";
const nap = "â‰‰";
const napE = "â©°Ì¸";
const napid = "â‰‹Ì¸";
const napos = "Å‰";
const napprox = "â‰‰";
const natural = "â™®";
const naturals = "â„•";
const natur = "â™®";
const nbsp$1 = "Â ";
const nbump = "â‰Ì¸";
const nbumpe = "â‰Ì¸";
const ncap = "â©ƒ";
const Ncaron = "Å‡";
const ncaron = "Åˆ";
const Ncedil = "Å…";
const ncedil = "Å†";
const ncong = "â‰‡";
const ncongdot = "â©­Ì¸";
const ncup = "â©‚";
const Ncy = "Ğ";
const ncy = "Ğ½";
const ndash = "â€“";
const nearhk = "â¤¤";
const nearr = "â†—";
const neArr = "â‡—";
const nearrow = "â†—";
const ne = "â‰ ";
const nedot = "â‰Ì¸";
const NegativeMediumSpace = "â€‹";
const NegativeThickSpace = "â€‹";
const NegativeThinSpace = "â€‹";
const NegativeVeryThinSpace = "â€‹";
const nequiv = "â‰¢";
const nesear = "â¤¨";
const nesim = "â‰‚Ì¸";
const NestedGreaterGreater = "â‰«";
const NestedLessLess = "â‰ª";
const NewLine = "\n";
const nexist = "âˆ„";
const nexists = "âˆ„";
const Nfr = "ğ”‘";
const nfr = "ğ”«";
const ngE = "â‰§Ì¸";
const nge = "â‰±";
const ngeq = "â‰±";
const ngeqq = "â‰§Ì¸";
const ngeqslant = "â©¾Ì¸";
const nges = "â©¾Ì¸";
const nGg = "â‹™Ì¸";
const ngsim = "â‰µ";
const nGt = "â‰«âƒ’";
const ngt = "â‰¯";
const ngtr = "â‰¯";
const nGtv = "â‰«Ì¸";
const nharr = "â†®";
const nhArr = "â‡";
const nhpar = "â«²";
const ni = "âˆ‹";
const nis = "â‹¼";
const nisd = "â‹º";
const niv = "âˆ‹";
const NJcy = "ĞŠ";
const njcy = "Ñš";
const nlarr = "â†š";
const nlArr = "â‡";
const nldr = "â€¥";
const nlE = "â‰¦Ì¸";
const nle = "â‰°";
const nleftarrow = "â†š";
const nLeftarrow = "â‡";
const nleftrightarrow = "â†®";
const nLeftrightarrow = "â‡";
const nleq = "â‰°";
const nleqq = "â‰¦Ì¸";
const nleqslant = "â©½Ì¸";
const nles = "â©½Ì¸";
const nless = "â‰®";
const nLl = "â‹˜Ì¸";
const nlsim = "â‰´";
const nLt = "â‰ªâƒ’";
const nlt = "â‰®";
const nltri = "â‹ª";
const nltrie = "â‹¬";
const nLtv = "â‰ªÌ¸";
const nmid = "âˆ¤";
const NoBreak = "â ";
const NonBreakingSpace = "Â ";
const nopf = "ğ•Ÿ";
const Nopf = "â„•";
const Not = "â«¬";
const not$1 = "Â¬";
const NotCongruent = "â‰¢";
const NotCupCap = "â‰­";
const NotDoubleVerticalBar = "âˆ¦";
const NotElement = "âˆ‰";
const NotEqual = "â‰ ";
const NotEqualTilde = "â‰‚Ì¸";
const NotExists = "âˆ„";
const NotGreater = "â‰¯";
const NotGreaterEqual = "â‰±";
const NotGreaterFullEqual = "â‰§Ì¸";
const NotGreaterGreater = "â‰«Ì¸";
const NotGreaterLess = "â‰¹";
const NotGreaterSlantEqual = "â©¾Ì¸";
const NotGreaterTilde = "â‰µ";
const NotHumpDownHump = "â‰Ì¸";
const NotHumpEqual = "â‰Ì¸";
const notin = "âˆ‰";
const notindot = "â‹µÌ¸";
const notinE = "â‹¹Ì¸";
const notinva = "âˆ‰";
const notinvb = "â‹·";
const notinvc = "â‹¶";
const NotLeftTriangleBar = "â§Ì¸";
const NotLeftTriangle = "â‹ª";
const NotLeftTriangleEqual = "â‹¬";
const NotLess = "â‰®";
const NotLessEqual = "â‰°";
const NotLessGreater = "â‰¸";
const NotLessLess = "â‰ªÌ¸";
const NotLessSlantEqual = "â©½Ì¸";
const NotLessTilde = "â‰´";
const NotNestedGreaterGreater = "âª¢Ì¸";
const NotNestedLessLess = "âª¡Ì¸";
const notni = "âˆŒ";
const notniva = "âˆŒ";
const notnivb = "â‹¾";
const notnivc = "â‹½";
const NotPrecedes = "âŠ€";
const NotPrecedesEqual = "âª¯Ì¸";
const NotPrecedesSlantEqual = "â‹ ";
const NotReverseElement = "âˆŒ";
const NotRightTriangleBar = "â§Ì¸";
const NotRightTriangle = "â‹«";
const NotRightTriangleEqual = "â‹­";
const NotSquareSubset = "âŠÌ¸";
const NotSquareSubsetEqual = "â‹¢";
const NotSquareSuperset = "âŠÌ¸";
const NotSquareSupersetEqual = "â‹£";
const NotSubset = "âŠ‚âƒ’";
const NotSubsetEqual = "âŠˆ";
const NotSucceeds = "âŠ";
const NotSucceedsEqual = "âª°Ì¸";
const NotSucceedsSlantEqual = "â‹¡";
const NotSucceedsTilde = "â‰¿Ì¸";
const NotSuperset = "âŠƒâƒ’";
const NotSupersetEqual = "âŠ‰";
const NotTilde = "â‰";
const NotTildeEqual = "â‰„";
const NotTildeFullEqual = "â‰‡";
const NotTildeTilde = "â‰‰";
const NotVerticalBar = "âˆ¤";
const nparallel = "âˆ¦";
const npar = "âˆ¦";
const nparsl = "â«½âƒ¥";
const npart = "âˆ‚Ì¸";
const npolint = "â¨”";
const npr = "âŠ€";
const nprcue = "â‹ ";
const nprec = "âŠ€";
const npreceq = "âª¯Ì¸";
const npre = "âª¯Ì¸";
const nrarrc = "â¤³Ì¸";
const nrarr = "â†›";
const nrArr = "â‡";
const nrarrw = "â†Ì¸";
const nrightarrow = "â†›";
const nRightarrow = "â‡";
const nrtri = "â‹«";
const nrtrie = "â‹­";
const nsc = "âŠ";
const nsccue = "â‹¡";
const nsce = "âª°Ì¸";
const Nscr = "ğ’©";
const nscr = "ğ“ƒ";
const nshortmid = "âˆ¤";
const nshortparallel = "âˆ¦";
const nsim = "â‰";
const nsime = "â‰„";
const nsimeq = "â‰„";
const nsmid = "âˆ¤";
const nspar = "âˆ¦";
const nsqsube = "â‹¢";
const nsqsupe = "â‹£";
const nsub = "âŠ„";
const nsubE = "â«…Ì¸";
const nsube = "âŠˆ";
const nsubset = "âŠ‚âƒ’";
const nsubseteq = "âŠˆ";
const nsubseteqq = "â«…Ì¸";
const nsucc = "âŠ";
const nsucceq = "âª°Ì¸";
const nsup = "âŠ…";
const nsupE = "â«†Ì¸";
const nsupe = "âŠ‰";
const nsupset = "âŠƒâƒ’";
const nsupseteq = "âŠ‰";
const nsupseteqq = "â«†Ì¸";
const ntgl = "â‰¹";
const Ntilde$1 = "Ã‘";
const ntilde$1 = "Ã±";
const ntlg = "â‰¸";
const ntriangleleft = "â‹ª";
const ntrianglelefteq = "â‹¬";
const ntriangleright = "â‹«";
const ntrianglerighteq = "â‹­";
const Nu = "Î";
const nu = "Î½";
const num = "#";
const numero = "â„–";
const numsp = "â€‡";
const nvap = "â‰âƒ’";
const nvdash = "âŠ¬";
const nvDash = "âŠ­";
const nVdash = "âŠ®";
const nVDash = "âŠ¯";
const nvge = "â‰¥âƒ’";
const nvgt = ">âƒ’";
const nvHarr = "â¤„";
const nvinfin = "â§";
const nvlArr = "â¤‚";
const nvle = "â‰¤âƒ’";
const nvlt = "<âƒ’";
const nvltrie = "âŠ´âƒ’";
const nvrArr = "â¤ƒ";
const nvrtrie = "âŠµâƒ’";
const nvsim = "âˆ¼âƒ’";
const nwarhk = "â¤£";
const nwarr = "â†–";
const nwArr = "â‡–";
const nwarrow = "â†–";
const nwnear = "â¤§";
const Oacute$1 = "Ã“";
const oacute$1 = "Ã³";
const oast = "âŠ›";
const Ocirc$1 = "Ã”";
const ocirc$1 = "Ã´";
const ocir = "âŠš";
const Ocy = "Ğ";
const ocy = "Ğ¾";
const odash = "âŠ";
const Odblac = "Å";
const odblac = "Å‘";
const odiv = "â¨¸";
const odot = "âŠ™";
const odsold = "â¦¼";
const OElig = "Å’";
const oelig = "Å“";
const ofcir = "â¦¿";
const Ofr = "ğ”’";
const ofr = "ğ”¬";
const ogon = "Ë›";
const Ograve$1 = "Ã’";
const ograve$1 = "Ã²";
const ogt = "â§";
const ohbar = "â¦µ";
const ohm = "Î©";
const oint = "âˆ®";
const olarr = "â†º";
const olcir = "â¦¾";
const olcross = "â¦»";
const oline = "â€¾";
const olt = "â§€";
const Omacr = "ÅŒ";
const omacr = "Å";
const Omega = "Î©";
const omega = "Ï‰";
const Omicron = "ÎŸ";
const omicron = "Î¿";
const omid = "â¦¶";
const ominus = "âŠ–";
const Oopf = "ğ•†";
const oopf = "ğ• ";
const opar = "â¦·";
const OpenCurlyDoubleQuote = "â€œ";
const OpenCurlyQuote = "â€˜";
const operp = "â¦¹";
const oplus = "âŠ•";
const orarr = "â†»";
const Or = "â©”";
const or = "âˆ¨";
const ord = "â©";
const order = "â„´";
const orderof = "â„´";
const ordf$1 = "Âª";
const ordm$1 = "Âº";
const origof = "âŠ¶";
const oror = "â©–";
const orslope = "â©—";
const orv = "â©›";
const oS = "â“ˆ";
const Oscr = "ğ’ª";
const oscr = "â„´";
const Oslash$1 = "Ã˜";
const oslash$1 = "Ã¸";
const osol = "âŠ˜";
const Otilde$1 = "Ã•";
const otilde$1 = "Ãµ";
const otimesas = "â¨¶";
const Otimes = "â¨·";
const otimes = "âŠ—";
const Ouml$1 = "Ã–";
const ouml$1 = "Ã¶";
const ovbar = "âŒ½";
const OverBar = "â€¾";
const OverBrace = "â";
const OverBracket = "â´";
const OverParenthesis = "âœ";
const para$1 = "Â¶";
const parallel = "âˆ¥";
const par = "âˆ¥";
const parsim = "â«³";
const parsl = "â«½";
const part = "âˆ‚";
const PartialD = "âˆ‚";
const Pcy = "ĞŸ";
const pcy = "Ğ¿";
const percnt = "%";
const period = ".";
const permil = "â€°";
const perp = "âŠ¥";
const pertenk = "â€±";
const Pfr = "ğ”“";
const pfr = "ğ”­";
const Phi = "Î¦";
const phi = "Ï†";
const phiv = "Ï•";
const phmmat = "â„³";
const phone = "â˜";
const Pi = "Î ";
const pi = "Ï€";
const pitchfork = "â‹”";
const piv = "Ï–";
const planck = "â„";
const planckh = "â„";
const plankv = "â„";
const plusacir = "â¨£";
const plusb = "âŠ";
const pluscir = "â¨¢";
const plus = "+";
const plusdo = "âˆ”";
const plusdu = "â¨¥";
const pluse = "â©²";
const PlusMinus = "Â±";
const plusmn$1 = "Â±";
const plussim = "â¨¦";
const plustwo = "â¨§";
const pm = "Â±";
const Poincareplane = "â„Œ";
const pointint = "â¨•";
const popf = "ğ•¡";
const Popf = "â„™";
const pound$1 = "Â£";
const prap = "âª·";
const Pr = "âª»";
const pr = "â‰º";
const prcue = "â‰¼";
const precapprox = "âª·";
const prec = "â‰º";
const preccurlyeq = "â‰¼";
const Precedes = "â‰º";
const PrecedesEqual = "âª¯";
const PrecedesSlantEqual = "â‰¼";
const PrecedesTilde = "â‰¾";
const preceq = "âª¯";
const precnapprox = "âª¹";
const precneqq = "âªµ";
const precnsim = "â‹¨";
const pre = "âª¯";
const prE = "âª³";
const precsim = "â‰¾";
const prime = "â€²";
const Prime = "â€³";
const primes = "â„™";
const prnap = "âª¹";
const prnE = "âªµ";
const prnsim = "â‹¨";
const prod = "âˆ";
const Product = "âˆ";
const profalar = "âŒ®";
const profline = "âŒ’";
const profsurf = "âŒ“";
const prop = "âˆ";
const Proportional = "âˆ";
const Proportion = "âˆ·";
const propto = "âˆ";
const prsim = "â‰¾";
const prurel = "âŠ°";
const Pscr = "ğ’«";
const pscr = "ğ“…";
const Psi = "Î¨";
const psi = "Ïˆ";
const puncsp = "â€ˆ";
const Qfr = "ğ””";
const qfr = "ğ”®";
const qint = "â¨Œ";
const qopf = "ğ•¢";
const Qopf = "â„š";
const qprime = "â—";
const Qscr = "ğ’¬";
const qscr = "ğ“†";
const quaternions = "â„";
const quatint = "â¨–";
const quest = "?";
const questeq = "â‰Ÿ";
const quot$2 = '"';
const QUOT$1 = '"';
const rAarr = "â‡›";
const race = "âˆ½Ì±";
const Racute = "Å”";
const racute = "Å•";
const radic = "âˆš";
const raemptyv = "â¦³";
const rang = "âŸ©";
const Rang = "âŸ«";
const rangd = "â¦’";
const range = "â¦¥";
const rangle = "âŸ©";
const raquo$1 = "Â»";
const rarrap = "â¥µ";
const rarrb = "â‡¥";
const rarrbfs = "â¤ ";
const rarrc = "â¤³";
const rarr = "â†’";
const Rarr = "â† ";
const rArr = "â‡’";
const rarrfs = "â¤";
const rarrhk = "â†ª";
const rarrlp = "â†¬";
const rarrpl = "â¥…";
const rarrsim = "â¥´";
const Rarrtl = "â¤–";
const rarrtl = "â†£";
const rarrw = "â†";
const ratail = "â¤š";
const rAtail = "â¤œ";
const ratio = "âˆ¶";
const rationals = "â„š";
const rbarr = "â¤";
const rBarr = "â¤";
const RBarr = "â¤";
const rbbrk = "â³";
const rbrace = "}";
const rbrack = "]";
const rbrke = "â¦Œ";
const rbrksld = "â¦";
const rbrkslu = "â¦";
const Rcaron = "Å˜";
const rcaron = "Å™";
const Rcedil = "Å–";
const rcedil = "Å—";
const rceil = "âŒ‰";
const rcub = "}";
const Rcy = "Ğ ";
const rcy = "Ñ€";
const rdca = "â¤·";
const rdldhar = "â¥©";
const rdquo = "â€";
const rdquor = "â€";
const rdsh = "â†³";
const real = "â„œ";
const realine = "â„›";
const realpart = "â„œ";
const reals = "â„";
const Re = "â„œ";
const rect = "â–­";
const reg$1 = "Â®";
const REG$1 = "Â®";
const ReverseElement = "âˆ‹";
const ReverseEquilibrium = "â‡‹";
const ReverseUpEquilibrium = "â¥¯";
const rfisht = "â¥½";
const rfloor = "âŒ‹";
const rfr = "ğ”¯";
const Rfr = "â„œ";
const rHar = "â¥¤";
const rhard = "â‡";
const rharu = "â‡€";
const rharul = "â¥¬";
const Rho = "Î¡";
const rho = "Ï";
const rhov = "Ï±";
const RightAngleBracket = "âŸ©";
const RightArrowBar = "â‡¥";
const rightarrow = "â†’";
const RightArrow = "â†’";
const Rightarrow = "â‡’";
const RightArrowLeftArrow = "â‡„";
const rightarrowtail = "â†£";
const RightCeiling = "âŒ‰";
const RightDoubleBracket = "âŸ§";
const RightDownTeeVector = "â¥";
const RightDownVectorBar = "â¥•";
const RightDownVector = "â‡‚";
const RightFloor = "âŒ‹";
const rightharpoondown = "â‡";
const rightharpoonup = "â‡€";
const rightleftarrows = "â‡„";
const rightleftharpoons = "â‡Œ";
const rightrightarrows = "â‡‰";
const rightsquigarrow = "â†";
const RightTeeArrow = "â†¦";
const RightTee = "âŠ¢";
const RightTeeVector = "â¥›";
const rightthreetimes = "â‹Œ";
const RightTriangleBar = "â§";
const RightTriangle = "âŠ³";
const RightTriangleEqual = "âŠµ";
const RightUpDownVector = "â¥";
const RightUpTeeVector = "â¥œ";
const RightUpVectorBar = "â¥”";
const RightUpVector = "â†¾";
const RightVectorBar = "â¥“";
const RightVector = "â‡€";
const ring = "Ëš";
const risingdotseq = "â‰“";
const rlarr = "â‡„";
const rlhar = "â‡Œ";
const rlm = "â€";
const rmoustache = "â±";
const rmoust = "â±";
const rnmid = "â«®";
const roang = "âŸ­";
const roarr = "â‡¾";
const robrk = "âŸ§";
const ropar = "â¦†";
const ropf = "ğ•£";
const Ropf = "â„";
const roplus = "â¨®";
const rotimes = "â¨µ";
const RoundImplies = "â¥°";
const rpar = ")";
const rpargt = "â¦”";
const rppolint = "â¨’";
const rrarr = "â‡‰";
const Rrightarrow = "â‡›";
const rsaquo = "â€º";
const rscr = "ğ“‡";
const Rscr = "â„›";
const rsh = "â†±";
const Rsh = "â†±";
const rsqb = "]";
const rsquo = "â€™";
const rsquor = "â€™";
const rthree = "â‹Œ";
const rtimes = "â‹Š";
const rtri = "â–¹";
const rtrie = "âŠµ";
const rtrif = "â–¸";
const rtriltri = "â§";
const RuleDelayed = "â§´";
const ruluhar = "â¥¨";
const rx = "â„";
const Sacute = "Åš";
const sacute = "Å›";
const sbquo = "â€š";
const scap = "âª¸";
const Scaron = "Å ";
const scaron = "Å¡";
const Sc = "âª¼";
const sc = "â‰»";
const sccue = "â‰½";
const sce = "âª°";
const scE = "âª´";
const Scedil = "Å";
const scedil = "ÅŸ";
const Scirc = "Åœ";
const scirc = "Å";
const scnap = "âªº";
const scnE = "âª¶";
const scnsim = "â‹©";
const scpolint = "â¨“";
const scsim = "â‰¿";
const Scy = "Ğ¡";
const scy = "Ñ";
const sdotb = "âŠ¡";
const sdot = "â‹…";
const sdote = "â©¦";
const searhk = "â¤¥";
const searr = "â†˜";
const seArr = "â‡˜";
const searrow = "â†˜";
const sect$1 = "Â§";
const semi = ";";
const seswar = "â¤©";
const setminus = "âˆ–";
const setmn = "âˆ–";
const sext = "âœ¶";
const Sfr = "ğ”–";
const sfr = "ğ”°";
const sfrown = "âŒ¢";
const sharp = "â™¯";
const SHCHcy = "Ğ©";
const shchcy = "Ñ‰";
const SHcy = "Ğ¨";
const shcy = "Ñˆ";
const ShortDownArrow = "â†“";
const ShortLeftArrow = "â†";
const shortmid = "âˆ£";
const shortparallel = "âˆ¥";
const ShortRightArrow = "â†’";
const ShortUpArrow = "â†‘";
const shy$1 = "Â­";
const Sigma = "Î£";
const sigma = "Ïƒ";
const sigmaf = "Ï‚";
const sigmav = "Ï‚";
const sim = "âˆ¼";
const simdot = "â©ª";
const sime = "â‰ƒ";
const simeq = "â‰ƒ";
const simg = "âª";
const simgE = "âª ";
const siml = "âª";
const simlE = "âªŸ";
const simne = "â‰†";
const simplus = "â¨¤";
const simrarr = "â¥²";
const slarr = "â†";
const SmallCircle = "âˆ˜";
const smallsetminus = "âˆ–";
const smashp = "â¨³";
const smeparsl = "â§¤";
const smid = "âˆ£";
const smile = "âŒ£";
const smt = "âªª";
const smte = "âª¬";
const smtes = "âª¬ï¸€";
const SOFTcy = "Ğ¬";
const softcy = "ÑŒ";
const solbar = "âŒ¿";
const solb = "â§„";
const sol = "/";
const Sopf = "ğ•Š";
const sopf = "ğ•¤";
const spades = "â™ ";
const spadesuit = "â™ ";
const spar = "âˆ¥";
const sqcap = "âŠ“";
const sqcaps = "âŠ“ï¸€";
const sqcup = "âŠ”";
const sqcups = "âŠ”ï¸€";
const Sqrt = "âˆš";
const sqsub = "âŠ";
const sqsube = "âŠ‘";
const sqsubset = "âŠ";
const sqsubseteq = "âŠ‘";
const sqsup = "âŠ";
const sqsupe = "âŠ’";
const sqsupset = "âŠ";
const sqsupseteq = "âŠ’";
const square = "â–¡";
const Square = "â–¡";
const SquareIntersection = "âŠ“";
const SquareSubset = "âŠ";
const SquareSubsetEqual = "âŠ‘";
const SquareSuperset = "âŠ";
const SquareSupersetEqual = "âŠ’";
const SquareUnion = "âŠ”";
const squarf = "â–ª";
const squ = "â–¡";
const squf = "â–ª";
const srarr = "â†’";
const Sscr = "ğ’®";
const sscr = "ğ“ˆ";
const ssetmn = "âˆ–";
const ssmile = "âŒ£";
const sstarf = "â‹†";
const Star = "â‹†";
const star = "â˜†";
const starf = "â˜…";
const straightepsilon = "Ïµ";
const straightphi = "Ï•";
const strns = "Â¯";
const sub = "âŠ‚";
const Sub = "â‹";
const subdot = "âª½";
const subE = "â«…";
const sube = "âŠ†";
const subedot = "â«ƒ";
const submult = "â«";
const subnE = "â«‹";
const subne = "âŠŠ";
const subplus = "âª¿";
const subrarr = "â¥¹";
const subset = "âŠ‚";
const Subset = "â‹";
const subseteq = "âŠ†";
const subseteqq = "â«…";
const SubsetEqual = "âŠ†";
const subsetneq = "âŠŠ";
const subsetneqq = "â«‹";
const subsim = "â«‡";
const subsub = "â«•";
const subsup = "â«“";
const succapprox = "âª¸";
const succ = "â‰»";
const succcurlyeq = "â‰½";
const Succeeds = "â‰»";
const SucceedsEqual = "âª°";
const SucceedsSlantEqual = "â‰½";
const SucceedsTilde = "â‰¿";
const succeq = "âª°";
const succnapprox = "âªº";
const succneqq = "âª¶";
const succnsim = "â‹©";
const succsim = "â‰¿";
const SuchThat = "âˆ‹";
const sum = "âˆ‘";
const Sum = "âˆ‘";
const sung = "â™ª";
const sup1$1 = "Â¹";
const sup2$1 = "Â²";
const sup3$1 = "Â³";
const sup = "âŠƒ";
const Sup = "â‹‘";
const supdot = "âª¾";
const supdsub = "â«˜";
const supE = "â«†";
const supe = "âŠ‡";
const supedot = "â«„";
const Superset = "âŠƒ";
const SupersetEqual = "âŠ‡";
const suphsol = "âŸ‰";
const suphsub = "â«—";
const suplarr = "â¥»";
const supmult = "â«‚";
const supnE = "â«Œ";
const supne = "âŠ‹";
const supplus = "â«€";
const supset = "âŠƒ";
const Supset = "â‹‘";
const supseteq = "âŠ‡";
const supseteqq = "â«†";
const supsetneq = "âŠ‹";
const supsetneqq = "â«Œ";
const supsim = "â«ˆ";
const supsub = "â«”";
const supsup = "â«–";
const swarhk = "â¤¦";
const swarr = "â†™";
const swArr = "â‡™";
const swarrow = "â†™";
const swnwar = "â¤ª";
const szlig$1 = "ÃŸ";
const Tab = "	";
const target = "âŒ–";
const Tau = "Î¤";
const tau = "Ï„";
const tbrk = "â´";
const Tcaron = "Å¤";
const tcaron = "Å¥";
const Tcedil = "Å¢";
const tcedil = "Å£";
const Tcy = "Ğ¢";
const tcy = "Ñ‚";
const tdot = "âƒ›";
const telrec = "âŒ•";
const Tfr = "ğ”—";
const tfr = "ğ”±";
const there4 = "âˆ´";
const therefore = "âˆ´";
const Therefore = "âˆ´";
const Theta = "Î˜";
const theta = "Î¸";
const thetasym = "Ï‘";
const thetav = "Ï‘";
const thickapprox = "â‰ˆ";
const thicksim = "âˆ¼";
const ThickSpace = "âŸâ€Š";
const ThinSpace = "â€‰";
const thinsp = "â€‰";
const thkap = "â‰ˆ";
const thksim = "âˆ¼";
const THORN$1 = "Ã";
const thorn$1 = "Ã¾";
const tilde = "Ëœ";
const Tilde = "âˆ¼";
const TildeEqual = "â‰ƒ";
const TildeFullEqual = "â‰…";
const TildeTilde = "â‰ˆ";
const timesbar = "â¨±";
const timesb = "âŠ ";
const times$1 = "Ã—";
const timesd = "â¨°";
const tint = "âˆ­";
const toea = "â¤¨";
const topbot = "âŒ¶";
const topcir = "â«±";
const top = "âŠ¤";
const Topf = "ğ•‹";
const topf = "ğ•¥";
const topfork = "â«š";
const tosa = "â¤©";
const tprime = "â€´";
const trade = "â„¢";
const TRADE = "â„¢";
const triangle = "â–µ";
const triangledown = "â–¿";
const triangleleft = "â—ƒ";
const trianglelefteq = "âŠ´";
const triangleq = "â‰œ";
const triangleright = "â–¹";
const trianglerighteq = "âŠµ";
const tridot = "â—¬";
const trie = "â‰œ";
const triminus = "â¨º";
const TripleDot = "âƒ›";
const triplus = "â¨¹";
const trisb = "â§";
const tritime = "â¨»";
const trpezium = "â¢";
const Tscr = "ğ’¯";
const tscr = "ğ“‰";
const TScy = "Ğ¦";
const tscy = "Ñ†";
const TSHcy = "Ğ‹";
const tshcy = "Ñ›";
const Tstrok = "Å¦";
const tstrok = "Å§";
const twixt = "â‰¬";
const twoheadleftarrow = "â†";
const twoheadrightarrow = "â† ";
const Uacute$1 = "Ãš";
const uacute$1 = "Ãº";
const uarr = "â†‘";
const Uarr = "â†Ÿ";
const uArr = "â‡‘";
const Uarrocir = "â¥‰";
const Ubrcy = "Ğ";
const ubrcy = "Ñ";
const Ubreve = "Å¬";
const ubreve = "Å­";
const Ucirc$1 = "Ã›";
const ucirc$1 = "Ã»";
const Ucy = "Ğ£";
const ucy = "Ñƒ";
const udarr = "â‡…";
const Udblac = "Å°";
const udblac = "Å±";
const udhar = "â¥®";
const ufisht = "â¥¾";
const Ufr = "ğ”˜";
const ufr = "ğ”²";
const Ugrave$1 = "Ã™";
const ugrave$1 = "Ã¹";
const uHar = "â¥£";
const uharl = "â†¿";
const uharr = "â†¾";
const uhblk = "â–€";
const ulcorn = "âŒœ";
const ulcorner = "âŒœ";
const ulcrop = "âŒ";
const ultri = "â—¸";
const Umacr = "Åª";
const umacr = "Å«";
const uml$1 = "Â¨";
const UnderBar = "_";
const UnderBrace = "âŸ";
const UnderBracket = "âµ";
const UnderParenthesis = "â";
const Union = "â‹ƒ";
const UnionPlus = "âŠ";
const Uogon = "Å²";
const uogon = "Å³";
const Uopf = "ğ•Œ";
const uopf = "ğ•¦";
const UpArrowBar = "â¤’";
const uparrow = "â†‘";
const UpArrow = "â†‘";
const Uparrow = "â‡‘";
const UpArrowDownArrow = "â‡…";
const updownarrow = "â†•";
const UpDownArrow = "â†•";
const Updownarrow = "â‡•";
const UpEquilibrium = "â¥®";
const upharpoonleft = "â†¿";
const upharpoonright = "â†¾";
const uplus = "âŠ";
const UpperLeftArrow = "â†–";
const UpperRightArrow = "â†—";
const upsi = "Ï…";
const Upsi = "Ï’";
const upsih = "Ï’";
const Upsilon = "Î¥";
const upsilon = "Ï…";
const UpTeeArrow = "â†¥";
const UpTee = "âŠ¥";
const upuparrows = "â‡ˆ";
const urcorn = "âŒ";
const urcorner = "âŒ";
const urcrop = "âŒ";
const Uring = "Å®";
const uring = "Å¯";
const urtri = "â—¹";
const Uscr = "ğ’°";
const uscr = "ğ“Š";
const utdot = "â‹°";
const Utilde = "Å¨";
const utilde = "Å©";
const utri = "â–µ";
const utrif = "â–´";
const uuarr = "â‡ˆ";
const Uuml$1 = "Ãœ";
const uuml$1 = "Ã¼";
const uwangle = "â¦§";
const vangrt = "â¦œ";
const varepsilon = "Ïµ";
const varkappa = "Ï°";
const varnothing = "âˆ…";
const varphi = "Ï•";
const varpi = "Ï–";
const varpropto = "âˆ";
const varr = "â†•";
const vArr = "â‡•";
const varrho = "Ï±";
const varsigma = "Ï‚";
const varsubsetneq = "âŠŠï¸€";
const varsubsetneqq = "â«‹ï¸€";
const varsupsetneq = "âŠ‹ï¸€";
const varsupsetneqq = "â«Œï¸€";
const vartheta = "Ï‘";
const vartriangleleft = "âŠ²";
const vartriangleright = "âŠ³";
const vBar = "â«¨";
const Vbar = "â««";
const vBarv = "â«©";
const Vcy = "Ğ’";
const vcy = "Ğ²";
const vdash = "âŠ¢";
const vDash = "âŠ¨";
const Vdash = "âŠ©";
const VDash = "âŠ«";
const Vdashl = "â«¦";
const veebar = "âŠ»";
const vee = "âˆ¨";
const Vee = "â‹";
const veeeq = "â‰š";
const vellip = "â‹®";
const verbar = "|";
const Verbar = "â€–";
const vert = "|";
const Vert = "â€–";
const VerticalBar = "âˆ£";
const VerticalLine = "|";
const VerticalSeparator = "â˜";
const VerticalTilde = "â‰€";
const VeryThinSpace = "â€Š";
const Vfr = "ğ”™";
const vfr = "ğ”³";
const vltri = "âŠ²";
const vnsub = "âŠ‚âƒ’";
const vnsup = "âŠƒâƒ’";
const Vopf = "ğ•";
const vopf = "ğ•§";
const vprop = "âˆ";
const vrtri = "âŠ³";
const Vscr = "ğ’±";
const vscr = "ğ“‹";
const vsubnE = "â«‹ï¸€";
const vsubne = "âŠŠï¸€";
const vsupnE = "â«Œï¸€";
const vsupne = "âŠ‹ï¸€";
const Vvdash = "âŠª";
const vzigzag = "â¦š";
const Wcirc = "Å´";
const wcirc = "Åµ";
const wedbar = "â©Ÿ";
const wedge = "âˆ§";
const Wedge = "â‹€";
const wedgeq = "â‰™";
const weierp = "â„˜";
const Wfr = "ğ”š";
const wfr = "ğ”´";
const Wopf = "ğ•";
const wopf = "ğ•¨";
const wp = "â„˜";
const wr = "â‰€";
const wreath = "â‰€";
const Wscr = "ğ’²";
const wscr = "ğ“Œ";
const xcap = "â‹‚";
const xcirc = "â—¯";
const xcup = "â‹ƒ";
const xdtri = "â–½";
const Xfr = "ğ”›";
const xfr = "ğ”µ";
const xharr = "âŸ·";
const xhArr = "âŸº";
const Xi = "Î";
const xi = "Î¾";
const xlarr = "âŸµ";
const xlArr = "âŸ¸";
const xmap = "âŸ¼";
const xnis = "â‹»";
const xodot = "â¨€";
const Xopf = "ğ•";
const xopf = "ğ•©";
const xoplus = "â¨";
const xotime = "â¨‚";
const xrarr = "âŸ¶";
const xrArr = "âŸ¹";
const Xscr = "ğ’³";
const xscr = "ğ“";
const xsqcup = "â¨†";
const xuplus = "â¨„";
const xutri = "â–³";
const xvee = "â‹";
const xwedge = "â‹€";
const Yacute$1 = "Ã";
const yacute$1 = "Ã½";
const YAcy = "Ğ¯";
const yacy = "Ñ";
const Ycirc = "Å¶";
const ycirc = "Å·";
const Ycy = "Ğ«";
const ycy = "Ñ‹";
const yen$1 = "Â¥";
const Yfr = "ğ”œ";
const yfr = "ğ”¶";
const YIcy = "Ğ‡";
const yicy = "Ñ—";
const Yopf = "ğ•";
const yopf = "ğ•ª";
const Yscr = "ğ’´";
const yscr = "ğ“";
const YUcy = "Ğ®";
const yucy = "Ñ";
const yuml$1 = "Ã¿";
const Yuml = "Å¸";
const Zacute = "Å¹";
const zacute = "Åº";
const Zcaron = "Å½";
const zcaron = "Å¾";
const Zcy = "Ğ—";
const zcy = "Ğ·";
const Zdot = "Å»";
const zdot = "Å¼";
const zeetrf = "â„¨";
const ZeroWidthSpace = "â€‹";
const Zeta = "Î–";
const zeta = "Î¶";
const zfr = "ğ”·";
const Zfr = "â„¨";
const ZHcy = "Ğ–";
const zhcy = "Ğ¶";
const zigrarr = "â‡";
const zopf = "ğ•«";
const Zopf = "â„¤";
const Zscr = "ğ’µ";
const zscr = "ğ“";
const zwj = "â€";
const zwnj = "â€Œ";
const require$$0 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element: Element2,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "âˆˆ",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  "Map": "â¤…",
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
const Aacute = "Ã";
const aacute = "Ã¡";
const Acirc = "Ã‚";
const acirc = "Ã¢";
const acute = "Â´";
const AElig = "Ã†";
const aelig = "Ã¦";
const Agrave = "Ã€";
const agrave = "Ã ";
const amp$1 = "&";
const AMP = "&";
const Aring = "Ã…";
const aring = "Ã¥";
const Atilde = "Ãƒ";
const atilde = "Ã£";
const Auml = "Ã„";
const auml = "Ã¤";
const brvbar = "Â¦";
const Ccedil = "Ã‡";
const ccedil = "Ã§";
const cedil = "Â¸";
const cent = "Â¢";
const copy = "Â©";
const COPY = "Â©";
const curren = "Â¤";
const deg = "Â°";
const divide = "Ã·";
const Eacute = "Ã‰";
const eacute = "Ã©";
const Ecirc = "ÃŠ";
const ecirc = "Ãª";
const Egrave = "Ãˆ";
const egrave = "Ã¨";
const ETH = "Ã";
const eth = "Ã°";
const Euml = "Ã‹";
const euml = "Ã«";
const frac12 = "Â½";
const frac14 = "Â¼";
const frac34 = "Â¾";
const gt$1 = ">";
const GT = ">";
const Iacute = "Ã";
const iacute = "Ã­";
const Icirc = "Ã";
const icirc = "Ã®";
const iexcl = "Â¡";
const Igrave = "ÃŒ";
const igrave = "Ã¬";
const iquest = "Â¿";
const Iuml = "Ã";
const iuml = "Ã¯";
const laquo = "Â«";
const lt$1 = "<";
const LT = "<";
const macr = "Â¯";
const micro = "Âµ";
const middot = "Â·";
const nbsp = "Â ";
const not = "Â¬";
const Ntilde = "Ã‘";
const ntilde = "Ã±";
const Oacute = "Ã“";
const oacute = "Ã³";
const Ocirc = "Ã”";
const ocirc = "Ã´";
const Ograve = "Ã’";
const ograve = "Ã²";
const ordf = "Âª";
const ordm = "Âº";
const Oslash = "Ã˜";
const oslash = "Ã¸";
const Otilde = "Ã•";
const otilde = "Ãµ";
const Ouml = "Ã–";
const ouml = "Ã¶";
const para = "Â¶";
const plusmn = "Â±";
const pound = "Â£";
const quot$1 = '"';
const QUOT = '"';
const raquo = "Â»";
const reg = "Â®";
const REG = "Â®";
const sect = "Â§";
const shy = "Â­";
const sup1 = "Â¹";
const sup2 = "Â²";
const sup3 = "Â³";
const szlig = "ÃŸ";
const THORN = "Ã";
const thorn = "Ã¾";
const times = "Ã—";
const Uacute = "Ãš";
const uacute = "Ãº";
const Ucirc = "Ã›";
const ucirc = "Ã»";
const Ugrave = "Ã™";
const ugrave = "Ã¹";
const uml = "Â¨";
const Uuml = "Ãœ";
const uuml = "Ã¼";
const Yacute = "Ã";
const yacute = "Ã½";
const yen = "Â¥";
const yuml = "Ã¿";
const require$$1$2 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
};
const amp = "&";
const apos = "'";
const gt = ">";
const lt = "<";
const quot = '"';
const require$$2 = {
  amp,
  apos,
  gt,
  lt,
  quot
};
var Tokenizer_1 = Tokenizer$8;
var decodeCodePoint$1 = decode_codepoint;
var entityMap$1 = require$$0;
var legacyMap$1 = require$$1$2;
var xmlMap$1 = require$$2;
var i = 0;
var TEXT = i++;
var BEFORE_TAG_NAME = i++;
var IN_TAG_NAME = i++;
var IN_SELF_CLOSING_TAG = i++;
var BEFORE_CLOSING_TAG_NAME = i++;
var IN_CLOSING_TAG_NAME = i++;
var AFTER_CLOSING_TAG_NAME = i++;
var BEFORE_ATTRIBUTE_NAME = i++;
var IN_ATTRIBUTE_NAME = i++;
var AFTER_ATTRIBUTE_NAME = i++;
var BEFORE_ATTRIBUTE_VALUE = i++;
var IN_ATTRIBUTE_VALUE_DQ = i++;
var IN_ATTRIBUTE_VALUE_SQ = i++;
var IN_ATTRIBUTE_VALUE_NQ = i++;
var BEFORE_DECLARATION = i++;
var IN_DECLARATION = i++;
var IN_PROCESSING_INSTRUCTION = i++;
var BEFORE_COMMENT = i++;
var IN_COMMENT = i++;
var AFTER_COMMENT_1 = i++;
var AFTER_COMMENT_2 = i++;
var BEFORE_CDATA_1 = i++;
var BEFORE_CDATA_2 = i++;
var BEFORE_CDATA_3 = i++;
var BEFORE_CDATA_4 = i++;
var BEFORE_CDATA_5 = i++;
var BEFORE_CDATA_6 = i++;
var IN_CDATA = i++;
var AFTER_CDATA_1 = i++;
var AFTER_CDATA_2 = i++;
var BEFORE_SPECIAL = i++;
var BEFORE_SPECIAL_END = i++;
var BEFORE_SCRIPT_1 = i++;
var BEFORE_SCRIPT_2 = i++;
var BEFORE_SCRIPT_3 = i++;
var BEFORE_SCRIPT_4 = i++;
var BEFORE_SCRIPT_5 = i++;
var AFTER_SCRIPT_1 = i++;
var AFTER_SCRIPT_2 = i++;
var AFTER_SCRIPT_3 = i++;
var AFTER_SCRIPT_4 = i++;
var AFTER_SCRIPT_5 = i++;
var BEFORE_STYLE_1 = i++;
var BEFORE_STYLE_2 = i++;
var BEFORE_STYLE_3 = i++;
var BEFORE_STYLE_4 = i++;
var AFTER_STYLE_1 = i++;
var AFTER_STYLE_2 = i++;
var AFTER_STYLE_3 = i++;
var AFTER_STYLE_4 = i++;
var BEFORE_ENTITY = i++;
var BEFORE_NUMERIC_ENTITY = i++;
var IN_NAMED_ENTITY = i++;
var IN_NUMERIC_ENTITY = i++;
var IN_HEX_ENTITY = i++;
var j = 0;
var SPECIAL_NONE = j++;
var SPECIAL_SCRIPT = j++;
var SPECIAL_STYLE = j++;
function whitespace(c) {
  return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
}
function ifElseState(upper, SUCCESS, FAILURE) {
  var lower = upper.toLowerCase();
  if (upper === lower) {
    return function(c) {
      if (c === lower) {
        this._state = SUCCESS;
      } else {
        this._state = FAILURE;
        this._index--;
      }
    };
  } else {
    return function(c) {
      if (c === lower || c === upper) {
        this._state = SUCCESS;
      } else {
        this._state = FAILURE;
        this._index--;
      }
    };
  }
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
  var lower = upper.toLowerCase();
  return function(c) {
    if (c === lower || c === upper) {
      this._state = NEXT_STATE;
    } else {
      this._state = IN_TAG_NAME;
      this._index--;
    }
  };
}
function Tokenizer$8(options2, cbs) {
  this._state = TEXT;
  this._buffer = "";
  this._sectionStart = 0;
  this._index = 0;
  this._bufferOffset = 0;
  this._baseState = TEXT;
  this._special = SPECIAL_NONE;
  this._cbs = cbs;
  this._running = true;
  this._ended = false;
  this._xmlMode = !!(options2 && options2.xmlMode);
  this._decodeEntities = !!(options2 && options2.decodeEntities);
}
Tokenizer$8.prototype._stateText = function(c) {
  if (c === "<") {
    if (this._index > this._sectionStart) {
      this._cbs.ontext(this._getSection());
    }
    this._state = BEFORE_TAG_NAME;
    this._sectionStart = this._index;
  } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === "&") {
    if (this._index > this._sectionStart) {
      this._cbs.ontext(this._getSection());
    }
    this._baseState = TEXT;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateBeforeTagName = function(c) {
  if (c === "/") {
    this._state = BEFORE_CLOSING_TAG_NAME;
  } else if (c === "<") {
    this._cbs.ontext(this._getSection());
    this._sectionStart = this._index;
  } else if (c === ">" || this._special !== SPECIAL_NONE || whitespace(c)) {
    this._state = TEXT;
  } else if (c === "!") {
    this._state = BEFORE_DECLARATION;
    this._sectionStart = this._index + 1;
  } else if (c === "?") {
    this._state = IN_PROCESSING_INSTRUCTION;
    this._sectionStart = this._index + 1;
  } else {
    this._state = !this._xmlMode && (c === "s" || c === "S") ? BEFORE_SPECIAL : IN_TAG_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateInTagName = function(c) {
  if (c === "/" || c === ">" || whitespace(c)) {
    this._emitToken("onopentagname");
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer$8.prototype._stateBeforeCloseingTagName = function(c) {
  if (whitespace(c))
    ;
  else if (c === ">") {
    this._state = TEXT;
  } else if (this._special !== SPECIAL_NONE) {
    if (c === "s" || c === "S") {
      this._state = BEFORE_SPECIAL_END;
    } else {
      this._state = TEXT;
      this._index--;
    }
  } else {
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateInCloseingTagName = function(c) {
  if (c === ">" || whitespace(c)) {
    this._emitToken("onclosetag");
    this._state = AFTER_CLOSING_TAG_NAME;
    this._index--;
  }
};
Tokenizer$8.prototype._stateAfterCloseingTagName = function(c) {
  if (c === ">") {
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer$8.prototype._stateBeforeAttributeName = function(c) {
  if (c === ">") {
    this._cbs.onopentagend();
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c === "/") {
    this._state = IN_SELF_CLOSING_TAG;
  } else if (!whitespace(c)) {
    this._state = IN_ATTRIBUTE_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateInSelfClosingTag = function(c) {
  if (c === ">") {
    this._cbs.onselfclosingtag();
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (!whitespace(c)) {
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer$8.prototype._stateInAttributeName = function(c) {
  if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
    this._cbs.onattribname(this._getSection());
    this._sectionStart = -1;
    this._state = AFTER_ATTRIBUTE_NAME;
    this._index--;
  }
};
Tokenizer$8.prototype._stateAfterAttributeName = function(c) {
  if (c === "=") {
    this._state = BEFORE_ATTRIBUTE_VALUE;
  } else if (c === "/" || c === ">") {
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  } else if (!whitespace(c)) {
    this._cbs.onattribend();
    this._state = IN_ATTRIBUTE_NAME;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateBeforeAttributeValue = function(c) {
  if (c === '"') {
    this._state = IN_ATTRIBUTE_VALUE_DQ;
    this._sectionStart = this._index + 1;
  } else if (c === "'") {
    this._state = IN_ATTRIBUTE_VALUE_SQ;
    this._sectionStart = this._index + 1;
  } else if (!whitespace(c)) {
    this._state = IN_ATTRIBUTE_VALUE_NQ;
    this._sectionStart = this._index;
    this._index--;
  }
};
Tokenizer$8.prototype._stateInAttributeValueDoubleQuotes = function(c) {
  if (c === '"') {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateInAttributeValueSingleQuotes = function(c) {
  if (c === "'") {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateInAttributeValueNoQuotes = function(c) {
  if (whitespace(c) || c === ">") {
    this._emitToken("onattribdata");
    this._cbs.onattribend();
    this._state = BEFORE_ATTRIBUTE_NAME;
    this._index--;
  } else if (this._decodeEntities && c === "&") {
    this._emitToken("onattribdata");
    this._baseState = this._state;
    this._state = BEFORE_ENTITY;
    this._sectionStart = this._index;
  }
};
Tokenizer$8.prototype._stateBeforeDeclaration = function(c) {
  this._state = c === "[" ? BEFORE_CDATA_1 : c === "-" ? BEFORE_COMMENT : IN_DECLARATION;
};
Tokenizer$8.prototype._stateInDeclaration = function(c) {
  if (c === ">") {
    this._cbs.ondeclaration(this._getSection());
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer$8.prototype._stateInProcessingInstruction = function(c) {
  if (c === ">") {
    this._cbs.onprocessinginstruction(this._getSection());
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  }
};
Tokenizer$8.prototype._stateBeforeComment = function(c) {
  if (c === "-") {
    this._state = IN_COMMENT;
    this._sectionStart = this._index + 1;
  } else {
    this._state = IN_DECLARATION;
  }
};
Tokenizer$8.prototype._stateInComment = function(c) {
  if (c === "-")
    this._state = AFTER_COMMENT_1;
};
Tokenizer$8.prototype._stateAfterComment1 = function(c) {
  if (c === "-") {
    this._state = AFTER_COMMENT_2;
  } else {
    this._state = IN_COMMENT;
  }
};
Tokenizer$8.prototype._stateAfterComment2 = function(c) {
  if (c === ">") {
    this._cbs.oncomment(
      this._buffer.substring(this._sectionStart, this._index - 2)
    );
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c !== "-") {
    this._state = IN_COMMENT;
  }
};
Tokenizer$8.prototype._stateBeforeCdata1 = ifElseState(
  "C",
  BEFORE_CDATA_2,
  IN_DECLARATION
);
Tokenizer$8.prototype._stateBeforeCdata2 = ifElseState(
  "D",
  BEFORE_CDATA_3,
  IN_DECLARATION
);
Tokenizer$8.prototype._stateBeforeCdata3 = ifElseState(
  "A",
  BEFORE_CDATA_4,
  IN_DECLARATION
);
Tokenizer$8.prototype._stateBeforeCdata4 = ifElseState(
  "T",
  BEFORE_CDATA_5,
  IN_DECLARATION
);
Tokenizer$8.prototype._stateBeforeCdata5 = ifElseState(
  "A",
  BEFORE_CDATA_6,
  IN_DECLARATION
);
Tokenizer$8.prototype._stateBeforeCdata6 = function(c) {
  if (c === "[") {
    this._state = IN_CDATA;
    this._sectionStart = this._index + 1;
  } else {
    this._state = IN_DECLARATION;
    this._index--;
  }
};
Tokenizer$8.prototype._stateInCdata = function(c) {
  if (c === "]")
    this._state = AFTER_CDATA_1;
};
Tokenizer$8.prototype._stateAfterCdata1 = function(c) {
  if (c === "]")
    this._state = AFTER_CDATA_2;
  else
    this._state = IN_CDATA;
};
Tokenizer$8.prototype._stateAfterCdata2 = function(c) {
  if (c === ">") {
    this._cbs.oncdata(
      this._buffer.substring(this._sectionStart, this._index - 2)
    );
    this._state = TEXT;
    this._sectionStart = this._index + 1;
  } else if (c !== "]") {
    this._state = IN_CDATA;
  }
};
Tokenizer$8.prototype._stateBeforeSpecial = function(c) {
  if (c === "c" || c === "C") {
    this._state = BEFORE_SCRIPT_1;
  } else if (c === "t" || c === "T") {
    this._state = BEFORE_STYLE_1;
  } else {
    this._state = IN_TAG_NAME;
    this._index--;
  }
};
Tokenizer$8.prototype._stateBeforeSpecialEnd = function(c) {
  if (this._special === SPECIAL_SCRIPT && (c === "c" || c === "C")) {
    this._state = AFTER_SCRIPT_1;
  } else if (this._special === SPECIAL_STYLE && (c === "t" || c === "T")) {
    this._state = AFTER_STYLE_1;
  } else
    this._state = TEXT;
};
Tokenizer$8.prototype._stateBeforeScript1 = consumeSpecialNameChar(
  "R",
  BEFORE_SCRIPT_2
);
Tokenizer$8.prototype._stateBeforeScript2 = consumeSpecialNameChar(
  "I",
  BEFORE_SCRIPT_3
);
Tokenizer$8.prototype._stateBeforeScript3 = consumeSpecialNameChar(
  "P",
  BEFORE_SCRIPT_4
);
Tokenizer$8.prototype._stateBeforeScript4 = consumeSpecialNameChar(
  "T",
  BEFORE_SCRIPT_5
);
Tokenizer$8.prototype._stateBeforeScript5 = function(c) {
  if (c === "/" || c === ">" || whitespace(c)) {
    this._special = SPECIAL_SCRIPT;
  }
  this._state = IN_TAG_NAME;
  this._index--;
};
Tokenizer$8.prototype._stateAfterScript1 = ifElseState("R", AFTER_SCRIPT_2, TEXT);
Tokenizer$8.prototype._stateAfterScript2 = ifElseState("I", AFTER_SCRIPT_3, TEXT);
Tokenizer$8.prototype._stateAfterScript3 = ifElseState("P", AFTER_SCRIPT_4, TEXT);
Tokenizer$8.prototype._stateAfterScript4 = ifElseState("T", AFTER_SCRIPT_5, TEXT);
Tokenizer$8.prototype._stateAfterScript5 = function(c) {
  if (c === ">" || whitespace(c)) {
    this._special = SPECIAL_NONE;
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index - 6;
    this._index--;
  } else
    this._state = TEXT;
};
Tokenizer$8.prototype._stateBeforeStyle1 = consumeSpecialNameChar(
  "Y",
  BEFORE_STYLE_2
);
Tokenizer$8.prototype._stateBeforeStyle2 = consumeSpecialNameChar(
  "L",
  BEFORE_STYLE_3
);
Tokenizer$8.prototype._stateBeforeStyle3 = consumeSpecialNameChar(
  "E",
  BEFORE_STYLE_4
);
Tokenizer$8.prototype._stateBeforeStyle4 = function(c) {
  if (c === "/" || c === ">" || whitespace(c)) {
    this._special = SPECIAL_STYLE;
  }
  this._state = IN_TAG_NAME;
  this._index--;
};
Tokenizer$8.prototype._stateAfterStyle1 = ifElseState("Y", AFTER_STYLE_2, TEXT);
Tokenizer$8.prototype._stateAfterStyle2 = ifElseState("L", AFTER_STYLE_3, TEXT);
Tokenizer$8.prototype._stateAfterStyle3 = ifElseState("E", AFTER_STYLE_4, TEXT);
Tokenizer$8.prototype._stateAfterStyle4 = function(c) {
  if (c === ">" || whitespace(c)) {
    this._special = SPECIAL_NONE;
    this._state = IN_CLOSING_TAG_NAME;
    this._sectionStart = this._index - 5;
    this._index--;
  } else
    this._state = TEXT;
};
Tokenizer$8.prototype._stateBeforeEntity = ifElseState(
  "#",
  BEFORE_NUMERIC_ENTITY,
  IN_NAMED_ENTITY
);
Tokenizer$8.prototype._stateBeforeNumericEntity = ifElseState(
  "X",
  IN_HEX_ENTITY,
  IN_NUMERIC_ENTITY
);
Tokenizer$8.prototype._parseNamedEntityStrict = function() {
  if (this._sectionStart + 1 < this._index) {
    var entity = this._buffer.substring(
      this._sectionStart + 1,
      this._index
    ), map2 = this._xmlMode ? xmlMap$1 : entityMap$1;
    if (map2.hasOwnProperty(entity)) {
      this._emitPartial(map2[entity]);
      this._sectionStart = this._index + 1;
    }
  }
};
Tokenizer$8.prototype._parseLegacyEntity = function() {
  var start = this._sectionStart + 1, limit = this._index - start;
  if (limit > 6)
    limit = 6;
  while (limit >= 2) {
    var entity = this._buffer.substr(start, limit);
    if (legacyMap$1.hasOwnProperty(entity)) {
      this._emitPartial(legacyMap$1[entity]);
      this._sectionStart += limit + 1;
      return;
    } else {
      limit--;
    }
  }
};
Tokenizer$8.prototype._stateInNamedEntity = function(c) {
  if (c === ";") {
    this._parseNamedEntityStrict();
    if (this._sectionStart + 1 < this._index && !this._xmlMode) {
      this._parseLegacyEntity();
    }
    this._state = this._baseState;
  } else if ((c < "a" || c > "z") && (c < "A" || c > "Z") && (c < "0" || c > "9")) {
    if (this._xmlMode)
      ;
    else if (this._sectionStart + 1 === this._index)
      ;
    else if (this._baseState !== TEXT) {
      if (c !== "=") {
        this._parseNamedEntityStrict();
      }
    } else {
      this._parseLegacyEntity();
    }
    this._state = this._baseState;
    this._index--;
  }
};
Tokenizer$8.prototype._decodeNumericEntity = function(offset, base) {
  var sectionStart = this._sectionStart + offset;
  if (sectionStart !== this._index) {
    var entity = this._buffer.substring(sectionStart, this._index);
    var parsed = parseInt(entity, base);
    this._emitPartial(decodeCodePoint$1(parsed));
    this._sectionStart = this._index;
  } else {
    this._sectionStart--;
  }
  this._state = this._baseState;
};
Tokenizer$8.prototype._stateInNumericEntity = function(c) {
  if (c === ";") {
    this._decodeNumericEntity(2, 10);
    this._sectionStart++;
  } else if (c < "0" || c > "9") {
    if (!this._xmlMode) {
      this._decodeNumericEntity(2, 10);
    } else {
      this._state = this._baseState;
    }
    this._index--;
  }
};
Tokenizer$8.prototype._stateInHexEntity = function(c) {
  if (c === ";") {
    this._decodeNumericEntity(3, 16);
    this._sectionStart++;
  } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
    if (!this._xmlMode) {
      this._decodeNumericEntity(3, 16);
    } else {
      this._state = this._baseState;
    }
    this._index--;
  }
};
Tokenizer$8.prototype._cleanup = function() {
  if (this._sectionStart < 0) {
    this._buffer = "";
    this._bufferOffset += this._index;
    this._index = 0;
  } else if (this._running) {
    if (this._state === TEXT) {
      if (this._sectionStart !== this._index) {
        this._cbs.ontext(this._buffer.substr(this._sectionStart));
      }
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else if (this._sectionStart === this._index) {
      this._buffer = "";
      this._bufferOffset += this._index;
      this._index = 0;
    } else {
      this._buffer = this._buffer.substr(this._sectionStart);
      this._index -= this._sectionStart;
      this._bufferOffset += this._sectionStart;
    }
    this._sectionStart = 0;
  }
};
Tokenizer$8.prototype.write = function(chunk) {
  if (this._ended)
    this._cbs.onerror(Error(".write() after done!"));
  this._buffer += chunk;
  this._parse();
};
Tokenizer$8.prototype._parse = function() {
  while (this._index < this._buffer.length && this._running) {
    var c = this._buffer.charAt(this._index);
    if (this._state === TEXT) {
      this._stateText(c);
    } else if (this._state === BEFORE_TAG_NAME) {
      this._stateBeforeTagName(c);
    } else if (this._state === IN_TAG_NAME) {
      this._stateInTagName(c);
    } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
      this._stateBeforeCloseingTagName(c);
    } else if (this._state === IN_CLOSING_TAG_NAME) {
      this._stateInCloseingTagName(c);
    } else if (this._state === AFTER_CLOSING_TAG_NAME) {
      this._stateAfterCloseingTagName(c);
    } else if (this._state === IN_SELF_CLOSING_TAG) {
      this._stateInSelfClosingTag(c);
    } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
      this._stateBeforeAttributeName(c);
    } else if (this._state === IN_ATTRIBUTE_NAME) {
      this._stateInAttributeName(c);
    } else if (this._state === AFTER_ATTRIBUTE_NAME) {
      this._stateAfterAttributeName(c);
    } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
      this._stateBeforeAttributeValue(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
      this._stateInAttributeValueDoubleQuotes(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
      this._stateInAttributeValueSingleQuotes(c);
    } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
      this._stateInAttributeValueNoQuotes(c);
    } else if (this._state === BEFORE_DECLARATION) {
      this._stateBeforeDeclaration(c);
    } else if (this._state === IN_DECLARATION) {
      this._stateInDeclaration(c);
    } else if (this._state === IN_PROCESSING_INSTRUCTION) {
      this._stateInProcessingInstruction(c);
    } else if (this._state === BEFORE_COMMENT) {
      this._stateBeforeComment(c);
    } else if (this._state === IN_COMMENT) {
      this._stateInComment(c);
    } else if (this._state === AFTER_COMMENT_1) {
      this._stateAfterComment1(c);
    } else if (this._state === AFTER_COMMENT_2) {
      this._stateAfterComment2(c);
    } else if (this._state === BEFORE_CDATA_1) {
      this._stateBeforeCdata1(c);
    } else if (this._state === BEFORE_CDATA_2) {
      this._stateBeforeCdata2(c);
    } else if (this._state === BEFORE_CDATA_3) {
      this._stateBeforeCdata3(c);
    } else if (this._state === BEFORE_CDATA_4) {
      this._stateBeforeCdata4(c);
    } else if (this._state === BEFORE_CDATA_5) {
      this._stateBeforeCdata5(c);
    } else if (this._state === BEFORE_CDATA_6) {
      this._stateBeforeCdata6(c);
    } else if (this._state === IN_CDATA) {
      this._stateInCdata(c);
    } else if (this._state === AFTER_CDATA_1) {
      this._stateAfterCdata1(c);
    } else if (this._state === AFTER_CDATA_2) {
      this._stateAfterCdata2(c);
    } else if (this._state === BEFORE_SPECIAL) {
      this._stateBeforeSpecial(c);
    } else if (this._state === BEFORE_SPECIAL_END) {
      this._stateBeforeSpecialEnd(c);
    } else if (this._state === BEFORE_SCRIPT_1) {
      this._stateBeforeScript1(c);
    } else if (this._state === BEFORE_SCRIPT_2) {
      this._stateBeforeScript2(c);
    } else if (this._state === BEFORE_SCRIPT_3) {
      this._stateBeforeScript3(c);
    } else if (this._state === BEFORE_SCRIPT_4) {
      this._stateBeforeScript4(c);
    } else if (this._state === BEFORE_SCRIPT_5) {
      this._stateBeforeScript5(c);
    } else if (this._state === AFTER_SCRIPT_1) {
      this._stateAfterScript1(c);
    } else if (this._state === AFTER_SCRIPT_2) {
      this._stateAfterScript2(c);
    } else if (this._state === AFTER_SCRIPT_3) {
      this._stateAfterScript3(c);
    } else if (this._state === AFTER_SCRIPT_4) {
      this._stateAfterScript4(c);
    } else if (this._state === AFTER_SCRIPT_5) {
      this._stateAfterScript5(c);
    } else if (this._state === BEFORE_STYLE_1) {
      this._stateBeforeStyle1(c);
    } else if (this._state === BEFORE_STYLE_2) {
      this._stateBeforeStyle2(c);
    } else if (this._state === BEFORE_STYLE_3) {
      this._stateBeforeStyle3(c);
    } else if (this._state === BEFORE_STYLE_4) {
      this._stateBeforeStyle4(c);
    } else if (this._state === AFTER_STYLE_1) {
      this._stateAfterStyle1(c);
    } else if (this._state === AFTER_STYLE_2) {
      this._stateAfterStyle2(c);
    } else if (this._state === AFTER_STYLE_3) {
      this._stateAfterStyle3(c);
    } else if (this._state === AFTER_STYLE_4) {
      this._stateAfterStyle4(c);
    } else if (this._state === BEFORE_ENTITY) {
      this._stateBeforeEntity(c);
    } else if (this._state === BEFORE_NUMERIC_ENTITY) {
      this._stateBeforeNumericEntity(c);
    } else if (this._state === IN_NAMED_ENTITY) {
      this._stateInNamedEntity(c);
    } else if (this._state === IN_NUMERIC_ENTITY) {
      this._stateInNumericEntity(c);
    } else if (this._state === IN_HEX_ENTITY) {
      this._stateInHexEntity(c);
    } else {
      this._cbs.onerror(Error("unknown _state"), this._state);
    }
    this._index++;
  }
  this._cleanup();
};
Tokenizer$8.prototype.pause = function() {
  this._running = false;
};
Tokenizer$8.prototype.resume = function() {
  this._running = true;
  if (this._index < this._buffer.length) {
    this._parse();
  }
  if (this._ended) {
    this._finish();
  }
};
Tokenizer$8.prototype.end = function(chunk) {
  if (this._ended)
    this._cbs.onerror(Error(".end() after done!"));
  if (chunk)
    this.write(chunk);
  this._ended = true;
  if (this._running)
    this._finish();
};
Tokenizer$8.prototype._finish = function() {
  if (this._sectionStart < this._index) {
    this._handleTrailingData();
  }
  this._cbs.onend();
};
Tokenizer$8.prototype._handleTrailingData = function() {
  var data2 = this._buffer.substr(this._sectionStart);
  if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
    this._cbs.oncdata(data2);
  } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
    this._cbs.oncomment(data2);
  } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
    this._parseLegacyEntity();
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
    this._decodeNumericEntity(2, 10);
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
    this._decodeNumericEntity(3, 16);
    if (this._sectionStart < this._index) {
      this._state = this._baseState;
      this._handleTrailingData();
    }
  } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
    this._cbs.ontext(data2);
  }
};
Tokenizer$8.prototype.reset = function() {
  Tokenizer$8.call(
    this,
    { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities },
    this._cbs
  );
};
Tokenizer$8.prototype.getAbsoluteIndex = function() {
  return this._bufferOffset + this._index;
};
Tokenizer$8.prototype._getSection = function() {
  return this._buffer.substring(this._sectionStart, this._index);
};
Tokenizer$8.prototype._emitToken = function(name2) {
  this._cbs[name2](this._getSection());
  this._sectionStart = -1;
};
Tokenizer$8.prototype._emitPartial = function(value) {
  if (this._baseState !== TEXT) {
    this._cbs.onattribdata(value);
  } else {
    this._cbs.ontext(value);
  }
};
var inherits_browserExports = {};
var inherits_browser = {
  get exports() {
    return inherits_browserExports;
  },
  set exports(v) {
    inherits_browserExports = v;
  }
};
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var Tokenizer$7 = Tokenizer_1;
var formTags = {
  input: true,
  option: true,
  optgroup: true,
  select: true,
  button: true,
  datalist: true,
  textarea: true
};
var openImpliesClose = {
  tr: { tr: true, th: true, td: true },
  th: { th: true },
  td: { thead: true, th: true, td: true },
  body: { head: true, link: true, script: true },
  li: { li: true },
  p: { p: true },
  h1: { p: true },
  h2: { p: true },
  h3: { p: true },
  h4: { p: true },
  h5: { p: true },
  h6: { p: true },
  select: formTags,
  input: formTags,
  output: formTags,
  button: formTags,
  datalist: formTags,
  textarea: formTags,
  option: { option: true },
  optgroup: { optgroup: true }
};
var voidElements = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};
var foreignContextElements = {
  __proto__: null,
  math: true,
  svg: true
};
var htmlIntegrationElements = {
  __proto__: null,
  mi: true,
  mo: true,
  mn: true,
  ms: true,
  mtext: true,
  "annotation-xml": true,
  foreignObject: true,
  desc: true,
  title: true
};
var re_nameEnd = /\s|\//;
function Parser$3(cbs, options2) {
  this._options = options2 || {};
  this._cbs = cbs || {};
  this._tagname = "";
  this._attribname = "";
  this._attribvalue = "";
  this._attribs = null;
  this._stack = [];
  this._foreignContext = [];
  this.startIndex = 0;
  this.endIndex = null;
  this._lowerCaseTagNames = "lowerCaseTags" in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
  this._lowerCaseAttributeNames = "lowerCaseAttributeNames" in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
  if (this._options.Tokenizer) {
    Tokenizer$7 = this._options.Tokenizer;
  }
  this._tokenizer = new Tokenizer$7(this._options, this);
  if (this._cbs.onparserinit)
    this._cbs.onparserinit(this);
}
inherits_browserExports(Parser$3, require$$2$1.EventEmitter);
Parser$3.prototype._updatePosition = function(initialOffset) {
  if (this.endIndex === null) {
    if (this._tokenizer._sectionStart <= initialOffset) {
      this.startIndex = 0;
    } else {
      this.startIndex = this._tokenizer._sectionStart - initialOffset;
    }
  } else
    this.startIndex = this.endIndex + 1;
  this.endIndex = this._tokenizer.getAbsoluteIndex();
};
Parser$3.prototype.ontext = function(data2) {
  this._updatePosition(1);
  this.endIndex--;
  if (this._cbs.ontext)
    this._cbs.ontext(data2);
};
Parser$3.prototype.onopentagname = function(name2) {
  if (this._lowerCaseTagNames) {
    name2 = name2.toLowerCase();
  }
  this._tagname = name2;
  if (!this._options.xmlMode && name2 in openImpliesClose) {
    for (var el2; (el2 = this._stack[this._stack.length - 1]) in openImpliesClose[name2]; this.onclosetag(el2))
      ;
  }
  if (this._options.xmlMode || !(name2 in voidElements)) {
    this._stack.push(name2);
    if (name2 in foreignContextElements)
      this._foreignContext.push(true);
    else if (name2 in htmlIntegrationElements)
      this._foreignContext.push(false);
  }
  if (this._cbs.onopentagname)
    this._cbs.onopentagname(name2);
  if (this._cbs.onopentag)
    this._attribs = {};
};
Parser$3.prototype.onopentagend = function() {
  this._updatePosition(1);
  if (this._attribs) {
    if (this._cbs.onopentag)
      this._cbs.onopentag(this._tagname, this._attribs);
    this._attribs = null;
  }
  if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
    this._cbs.onclosetag(this._tagname);
  }
  this._tagname = "";
};
Parser$3.prototype.onclosetag = function(name2) {
  this._updatePosition(1);
  if (this._lowerCaseTagNames) {
    name2 = name2.toLowerCase();
  }
  if (name2 in foreignContextElements || name2 in htmlIntegrationElements) {
    this._foreignContext.pop();
  }
  if (this._stack.length && (!(name2 in voidElements) || this._options.xmlMode)) {
    var pos = this._stack.lastIndexOf(name2);
    if (pos !== -1) {
      if (this._cbs.onclosetag) {
        pos = this._stack.length - pos;
        while (pos--)
          this._cbs.onclosetag(this._stack.pop());
      } else
        this._stack.length = pos;
    } else if (name2 === "p" && !this._options.xmlMode) {
      this.onopentagname(name2);
      this._closeCurrentTag();
    }
  } else if (!this._options.xmlMode && (name2 === "br" || name2 === "p")) {
    this.onopentagname(name2);
    this._closeCurrentTag();
  }
};
Parser$3.prototype.onselfclosingtag = function() {
  if (this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1]) {
    this._closeCurrentTag();
  } else {
    this.onopentagend();
  }
};
Parser$3.prototype._closeCurrentTag = function() {
  var name2 = this._tagname;
  this.onopentagend();
  if (this._stack[this._stack.length - 1] === name2) {
    if (this._cbs.onclosetag) {
      this._cbs.onclosetag(name2);
    }
    this._stack.pop();
  }
};
Parser$3.prototype.onattribname = function(name2) {
  if (this._lowerCaseAttributeNames) {
    name2 = name2.toLowerCase();
  }
  this._attribname = name2;
};
Parser$3.prototype.onattribdata = function(value) {
  this._attribvalue += value;
};
Parser$3.prototype.onattribend = function() {
  if (this._cbs.onattribute)
    this._cbs.onattribute(this._attribname, this._attribvalue);
  if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
    this._attribs[this._attribname] = this._attribvalue;
  }
  this._attribname = "";
  this._attribvalue = "";
};
Parser$3.prototype._getInstructionName = function(value) {
  var idx = value.search(re_nameEnd), name2 = idx < 0 ? value : value.substr(0, idx);
  if (this._lowerCaseTagNames) {
    name2 = name2.toLowerCase();
  }
  return name2;
};
Parser$3.prototype.ondeclaration = function(value) {
  if (this._cbs.onprocessinginstruction) {
    var name2 = this._getInstructionName(value);
    this._cbs.onprocessinginstruction("!" + name2, "!" + value);
  }
};
Parser$3.prototype.onprocessinginstruction = function(value) {
  if (this._cbs.onprocessinginstruction) {
    var name2 = this._getInstructionName(value);
    this._cbs.onprocessinginstruction("?" + name2, "?" + value);
  }
};
Parser$3.prototype.oncomment = function(value) {
  this._updatePosition(4);
  if (this._cbs.oncomment)
    this._cbs.oncomment(value);
  if (this._cbs.oncommentend)
    this._cbs.oncommentend();
};
Parser$3.prototype.oncdata = function(value) {
  this._updatePosition(1);
  if (this._options.xmlMode || this._options.recognizeCDATA) {
    if (this._cbs.oncdatastart)
      this._cbs.oncdatastart();
    if (this._cbs.ontext)
      this._cbs.ontext(value);
    if (this._cbs.oncdataend)
      this._cbs.oncdataend();
  } else {
    this.oncomment("[CDATA[" + value + "]]");
  }
};
Parser$3.prototype.onerror = function(err) {
  if (this._cbs.onerror)
    this._cbs.onerror(err);
};
Parser$3.prototype.onend = function() {
  if (this._cbs.onclosetag) {
    for (var i2 = this._stack.length; i2 > 0; this._cbs.onclosetag(this._stack[--i2]))
      ;
  }
  if (this._cbs.onend)
    this._cbs.onend();
};
Parser$3.prototype.reset = function() {
  if (this._cbs.onreset)
    this._cbs.onreset();
  this._tokenizer.reset();
  this._tagname = "";
  this._attribname = "";
  this._attribs = null;
  this._stack = [];
  if (this._cbs.onparserinit)
    this._cbs.onparserinit(this);
};
Parser$3.prototype.parseComplete = function(data2) {
  this.reset();
  this.end(data2);
};
Parser$3.prototype.write = function(chunk) {
  this._tokenizer.write(chunk);
};
Parser$3.prototype.end = function(chunk) {
  this._tokenizer.end(chunk);
};
Parser$3.prototype.pause = function() {
  this._tokenizer.pause();
};
Parser$3.prototype.resume = function() {
  this._tokenizer.resume();
};
Parser$3.prototype.parseChunk = Parser$3.prototype.write;
Parser$3.prototype.done = Parser$3.prototype.end;
var Parser_1 = Parser$3;
var domelementtype = {
  Text: "text",
  //Text
  Directive: "directive",
  //<? ... ?>
  Comment: "comment",
  //<!-- ... -->
  Script: "script",
  //<script> tags
  Style: "style",
  //<style> tags
  Tag: "tag",
  //Any tag
  CDATA: "cdata",
  //<![CDATA[ ... ]]>
  Doctype: "doctype",
  isTag: function(elem) {
    return elem.type === "tag" || elem.type === "script" || elem.type === "style";
  }
};
var nodeExports = {};
var node = {
  get exports() {
    return nodeExports;
  },
  set exports(v) {
    nodeExports = v;
  }
};
node.exports = {
  get firstChild() {
    var children2 = this.children;
    return children2 && children2[0] || null;
  },
  get lastChild() {
    var children2 = this.children;
    return children2 && children2[children2.length - 1] || null;
  },
  get nodeType() {
    return nodeTypes$1[this.type] || nodeTypes$1.element;
  }
};
var domLvl1$1 = {
  tagName: "name",
  childNodes: "children",
  parentNode: "parent",
  previousSibling: "prev",
  nextSibling: "next",
  nodeValue: "data"
};
var nodeTypes$1 = {
  element: 1,
  text: 3,
  cdata: 4,
  comment: 8
};
Object.keys(domLvl1$1).forEach(function(key) {
});
var elementExports = {};
var element = {
  get exports() {
    return elementExports;
  },
  set exports(v) {
    elementExports = v;
  }
};
var NodePrototype$1 = nodeExports;
var ElementPrototype$1 = element.exports = Object.create(NodePrototype$1);
var domLvl1 = {
  tagName: "name"
};
Object.keys(domLvl1).forEach(function(key) {
  var shorthand = domLvl1[key];
  Object.defineProperty(ElementPrototype$1, key, {
    get: function() {
      return this[shorthand] || null;
    },
    set: function(val2) {
      this[shorthand] = val2;
      return val2;
    }
  });
});
var ElementType$3 = domelementtype;
var re_whitespace = /\s+/g;
var NodePrototype = nodeExports;
var ElementPrototype = elementExports;
function DomHandler2(callback, options2, elementCB) {
  if (typeof callback === "object") {
    elementCB = options2;
    options2 = callback;
    callback = null;
  } else if (typeof options2 === "function") {
    elementCB = options2;
    options2 = defaultOpts;
  }
  this._callback = callback;
  this._options = options2 || defaultOpts;
  this._elementCB = elementCB;
  this.dom = [];
  this._done = false;
  this._tagStack = [];
  this._parser = this._parser || null;
}
var defaultOpts = {
  normalizeWhitespace: false,
  //Replace all whitespace with single spaces
  withStartIndices: false,
  //Add startIndex properties to nodes
  withEndIndices: false
  //Add endIndex properties to nodes
};
DomHandler2.prototype.onparserinit = function(parser2) {
  this._parser = parser2;
};
DomHandler2.prototype.onreset = function() {
  DomHandler2.call(this, this._callback, this._options, this._elementCB);
};
DomHandler2.prototype.onend = function() {
  if (this._done)
    return;
  this._done = true;
  this._parser = null;
  this._handleCallback(null);
};
DomHandler2.prototype._handleCallback = DomHandler2.prototype.onerror = function(error) {
  if (typeof this._callback === "function") {
    this._callback(error, this.dom);
  } else {
    if (error)
      throw error;
  }
};
DomHandler2.prototype.onclosetag = function() {
  var elem = this._tagStack.pop();
  if (this._options.withEndIndices && elem) {
    elem.endIndex = this._parser.endIndex;
  }
  if (this._elementCB)
    this._elementCB(elem);
};
DomHandler2.prototype._createDomElement = function(properties) {
  if (!this._options.withDomLvl1)
    return properties;
  var element2;
  if (properties.type === "tag") {
    element2 = Object.create(ElementPrototype);
  } else {
    element2 = Object.create(NodePrototype);
  }
  for (var key in properties) {
    if (properties.hasOwnProperty(key)) {
      element2[key] = properties[key];
    }
  }
  return element2;
};
DomHandler2.prototype._addDomElement = function(element2) {
  var parent2 = this._tagStack[this._tagStack.length - 1];
  var siblings2 = parent2 ? parent2.children : this.dom;
  var previousSibling = siblings2[siblings2.length - 1];
  element2.next = null;
  if (this._options.withStartIndices) {
    element2.startIndex = this._parser.startIndex;
  }
  if (this._options.withEndIndices) {
    element2.endIndex = this._parser.endIndex;
  }
  if (previousSibling) {
    element2.prev = previousSibling;
    previousSibling.next = element2;
  } else {
    element2.prev = null;
  }
  siblings2.push(element2);
  element2.parent = parent2 || null;
};
DomHandler2.prototype.onopentag = function(name2, attribs) {
  var properties = {
    type: name2 === "script" ? ElementType$3.Script : name2 === "style" ? ElementType$3.Style : ElementType$3.Tag,
    name: name2,
    attribs,
    children: []
  };
  var element2 = this._createDomElement(properties);
  this._addDomElement(element2);
  this._tagStack.push(element2);
};
DomHandler2.prototype.ontext = function(data2) {
  var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
  var lastTag;
  if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType$3.Text) {
    if (normalize) {
      lastTag.data = (lastTag.data + data2).replace(re_whitespace, " ");
    } else {
      lastTag.data += data2;
    }
  } else {
    if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType$3.Text) {
      if (normalize) {
        lastTag.data = (lastTag.data + data2).replace(re_whitespace, " ");
      } else {
        lastTag.data += data2;
      }
    } else {
      if (normalize) {
        data2 = data2.replace(re_whitespace, " ");
      }
      var element2 = this._createDomElement({
        data: data2,
        type: ElementType$3.Text
      });
      this._addDomElement(element2);
    }
  }
};
DomHandler2.prototype.oncomment = function(data2) {
  var lastTag = this._tagStack[this._tagStack.length - 1];
  if (lastTag && lastTag.type === ElementType$3.Comment) {
    lastTag.data += data2;
    return;
  }
  var properties = {
    data: data2,
    type: ElementType$3.Comment
  };
  var element2 = this._createDomElement(properties);
  this._addDomElement(element2);
  this._tagStack.push(element2);
};
DomHandler2.prototype.oncdatastart = function() {
  var properties = {
    children: [{
      data: "",
      type: ElementType$3.Text
    }],
    type: ElementType$3.CDATA
  };
  var element2 = this._createDomElement(properties);
  this._addDomElement(element2);
  this._tagStack.push(element2);
};
DomHandler2.prototype.oncommentend = DomHandler2.prototype.oncdataend = function() {
  this._tagStack.pop();
};
DomHandler2.prototype.onprocessinginstruction = function(name2, data2) {
  var element2 = this._createDomElement({
    name: name2,
    data: data2,
    type: ElementType$3.Directive
  });
  this._addDomElement(element2);
};
var domhandler = DomHandler2;
var domutilsExports = {};
var domutils = {
  get exports() {
    return domutilsExports;
  },
  set exports(v) {
    domutilsExports = v;
  }
};
var domSerializerExports = {};
var domSerializer = {
  get exports() {
    return domSerializerExports;
  },
  set exports(v) {
    domSerializerExports = v;
  }
};
var entities$1 = {};
var encode$1 = {};
var inverseXML = getInverseObj(require$$2), xmlReplacer = getInverseReplacer(inverseXML);
encode$1.XML = getInverse(inverseXML, xmlReplacer);
var inverseHTML = getInverseObj(require$$0), htmlReplacer = getInverseReplacer(inverseHTML);
encode$1.HTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
  return Object.keys(obj).sort().reduce(function(inverse, name2) {
    inverse[obj[name2]] = "&" + name2 + ";";
    return inverse;
  }, {});
}
function getInverseReplacer(inverse) {
  var single = [], multiple = [];
  Object.keys(inverse).forEach(function(k) {
    if (k.length === 1) {
      single.push("\\" + k);
    } else {
      multiple.push(k);
    }
  });
  multiple.unshift("[" + single.join("") + "]");
  return new RegExp(multiple.join("|"), "g");
}
var re_nonASCII = /[^\0-\x7F]/g, re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
function singleCharReplacer(c) {
  return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
}
function astralReplacer(c) {
  var high = c.charCodeAt(0);
  var low = c.charCodeAt(1);
  var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
  return "&#x" + codePoint.toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
  function func(name2) {
    return inverse[name2];
  }
  return function(data2) {
    return data2.replace(re, func).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
  };
}
var re_xmlChars = getInverseReplacer(inverseXML);
function escapeXML(data2) {
  return data2.replace(re_xmlChars, singleCharReplacer).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
}
encode$1.escape = escapeXML;
var entityMap = require$$0, legacyMap = require$$1$2, xmlMap = require$$2, decodeCodePoint = decode_codepoint;
var decodeXMLStrict = getStrictDecoder(xmlMap), decodeHTMLStrict = getStrictDecoder(entityMap);
function getStrictDecoder(map2) {
  var keys2 = Object.keys(map2).join("|"), replace = getReplacer(map2);
  keys2 += "|#[xX][\\da-fA-F]+|#\\d+";
  var re = new RegExp("&(?:" + keys2 + ");", "g");
  return function(str) {
    return String(str).replace(re, replace);
  };
}
var decodeHTML = function() {
  var legacy2 = Object.keys(legacyMap).sort(sorter);
  var keys2 = Object.keys(entityMap).sort(sorter);
  for (var i2 = 0, j2 = 0; i2 < keys2.length; i2++) {
    if (legacy2[j2] === keys2[i2]) {
      keys2[i2] += ";?";
      j2++;
    } else {
      keys2[i2] += ";";
    }
  }
  var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), replace = getReplacer(entityMap);
  function replacer(str) {
    if (str.substr(-1) !== ";")
      str += ";";
    return replace(str);
  }
  return function(str) {
    return String(str).replace(re, replacer);
  };
}();
function sorter(a, b) {
  return a < b ? 1 : -1;
}
function getReplacer(map2) {
  return function replace(str) {
    if (str.charAt(1) === "#") {
      if (str.charAt(2) === "X" || str.charAt(2) === "x") {
        return decodeCodePoint(parseInt(str.substr(3), 16));
      }
      return decodeCodePoint(parseInt(str.substr(2), 10));
    }
    return map2[str.slice(1, -1)];
  };
}
var decode$1 = {
  XML: decodeXMLStrict,
  HTML: decodeHTML,
  HTMLStrict: decodeHTMLStrict
};
var encode = encode$1, decode = decode$1;
entities$1.decode = function(data2, level) {
  return (!level || level <= 0 ? decode.XML : decode.HTML)(data2);
};
entities$1.decodeStrict = function(data2, level) {
  return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data2);
};
entities$1.encode = function(data2, level) {
  return (!level || level <= 0 ? encode.XML : encode.HTML)(data2);
};
entities$1.encodeXML = encode.XML;
entities$1.encodeHTML4 = entities$1.encodeHTML5 = entities$1.encodeHTML = encode.HTML;
entities$1.decodeXML = entities$1.decodeXMLStrict = decode.XML;
entities$1.decodeHTML4 = entities$1.decodeHTML5 = entities$1.decodeHTML = decode.HTML;
entities$1.decodeHTML4Strict = entities$1.decodeHTML5Strict = entities$1.decodeHTMLStrict = decode.HTMLStrict;
entities$1.escape = encode.escape;
var ElementType$2 = domelementtype;
var entities = entities$1;
var unencodedElements = {
  __proto__: null,
  style: true,
  script: true,
  xmp: true,
  iframe: true,
  noembed: true,
  noframes: true,
  plaintext: true,
  noscript: true
};
function formatAttrs(attributes2, opts) {
  if (!attributes2)
    return;
  var output = "", value;
  for (var key in attributes2) {
    value = attributes2[key];
    if (output) {
      output += " ";
    }
    output += key;
    if (value !== null && value !== "" || opts.xmlMode) {
      output += '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
    }
  }
  return output;
}
var singleTag = {
  __proto__: null,
  area: true,
  base: true,
  basefont: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  isindex: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};
var render$1 = domSerializer.exports = function(dom, opts) {
  if (!Array.isArray(dom) && !dom.cheerio)
    dom = [dom];
  opts = opts || {};
  var output = "";
  for (var i2 = 0; i2 < dom.length; i2++) {
    var elem = dom[i2];
    if (elem.type === "root")
      output += render$1(elem.children, opts);
    else if (ElementType$2.isTag(elem))
      output += renderTag(elem, opts);
    else if (elem.type === ElementType$2.Directive)
      output += renderDirective(elem);
    else if (elem.type === ElementType$2.Comment)
      output += renderComment(elem);
    else if (elem.type === ElementType$2.CDATA)
      output += renderCdata(elem);
    else
      output += renderText(elem, opts);
  }
  return output;
};
function renderTag(elem, opts) {
  if (elem.name === "svg")
    opts = { decodeEntities: opts.decodeEntities, xmlMode: true };
  var tag2 = "<" + elem.name, attribs = formatAttrs(elem.attribs, opts);
  if (attribs) {
    tag2 += " " + attribs;
  }
  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
    tag2 += "/>";
  } else {
    tag2 += ">";
    if (elem.children) {
      tag2 += render$1(elem.children, opts);
    }
    if (!singleTag[elem.name] || opts.xmlMode) {
      tag2 += "</" + elem.name + ">";
    }
  }
  return tag2;
}
function renderDirective(elem) {
  return "<" + elem.data + ">";
}
function renderText(elem, opts) {
  var data2 = elem.data || "";
  if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
    data2 = entities.encodeXML(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
  return "<!--" + elem.data + "-->";
}
var ElementType$1 = domelementtype, getOuterHTML = domSerializerExports, isTag$5 = ElementType$1.isTag;
var stringify$1 = {
  getInnerHTML,
  getOuterHTML,
  getText: getText$1
};
function getInnerHTML(elem, opts) {
  return elem.children ? elem.children.map(function(elem2) {
    return getOuterHTML(elem2, opts);
  }).join("") : "";
}
function getText$1(elem) {
  if (Array.isArray(elem))
    return elem.map(getText$1).join("");
  if (isTag$5(elem) || elem.type === ElementType$1.CDATA)
    return getText$1(elem.children);
  if (elem.type === ElementType$1.Text)
    return elem.data;
  return "";
}
var traversal = {};
var getChildren$4 = traversal.getChildren = function(elem) {
  return elem.children;
};
var getParent$3 = traversal.getParent = function(elem) {
  return elem.parent;
};
traversal.getSiblings = function(elem) {
  var parent2 = getParent$3(elem);
  return parent2 ? getChildren$4(parent2) : [elem];
};
traversal.getAttributeValue = function(elem, name2) {
  return elem.attribs && elem.attribs[name2];
};
traversal.hasAttrib = function(elem, name2) {
  return !!elem.attribs && hasOwnProperty.call(elem.attribs, name2);
};
traversal.getName = function(elem) {
  return elem.name;
};
var manipulation$1 = {};
manipulation$1.removeElement = function(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    var childs = elem.parent.children;
    childs.splice(childs.lastIndexOf(elem), 1);
  }
};
manipulation$1.replaceElement = function(elem, replacement) {
  var prev2 = replacement.prev = elem.prev;
  if (prev2) {
    prev2.next = replacement;
  }
  var next2 = replacement.next = elem.next;
  if (next2) {
    next2.prev = replacement;
  }
  var parent2 = replacement.parent = elem.parent;
  if (parent2) {
    var childs = parent2.children;
    childs[childs.lastIndexOf(elem)] = replacement;
  }
};
manipulation$1.appendChild = function(elem, child2) {
  child2.parent = elem;
  if (elem.children.push(child2) !== 1) {
    var sibling2 = elem.children[elem.children.length - 2];
    sibling2.next = child2;
    child2.prev = sibling2;
    child2.next = null;
  }
};
manipulation$1.append = function(elem, next2) {
  var parent2 = elem.parent, currNext = elem.next;
  next2.next = currNext;
  next2.prev = elem;
  elem.next = next2;
  next2.parent = parent2;
  if (currNext) {
    currNext.prev = next2;
    if (parent2) {
      var childs = parent2.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next2);
    }
  } else if (parent2) {
    parent2.children.push(next2);
  }
};
manipulation$1.prepend = function(elem, prev2) {
  var parent2 = elem.parent;
  if (parent2) {
    var childs = parent2.children;
    childs.splice(childs.lastIndexOf(elem), 0, prev2);
  }
  if (elem.prev) {
    elem.prev.next = prev2;
  }
  prev2.parent = parent2;
  prev2.prev = elem.prev;
  prev2.next = elem;
  elem.prev = prev2;
};
var isTag$4 = domelementtype.isTag;
var querying = {
  filter: filter$1,
  find,
  findOneChild,
  findOne: findOne$1,
  existsOne: existsOne$1,
  findAll: findAll$1
};
function filter$1(test, element2, recurse, limit) {
  if (!Array.isArray(element2))
    element2 = [element2];
  if (typeof limit !== "number" || !isFinite(limit)) {
    limit = Infinity;
  }
  return find(test, element2, recurse !== false, limit);
}
function find(test, elems, recurse, limit) {
  var result = [], childs;
  for (var i2 = 0, j2 = elems.length; i2 < j2; i2++) {
    if (test(elems[i2])) {
      result.push(elems[i2]);
      if (--limit <= 0)
        break;
    }
    childs = elems[i2].children;
    if (recurse && childs && childs.length > 0) {
      childs = find(test, childs, recurse, limit);
      result = result.concat(childs);
      limit -= childs.length;
      if (limit <= 0)
        break;
    }
  }
  return result;
}
function findOneChild(test, elems) {
  for (var i2 = 0, l = elems.length; i2 < l; i2++) {
    if (test(elems[i2]))
      return elems[i2];
  }
  return null;
}
function findOne$1(test, elems) {
  var elem = null;
  for (var i2 = 0, l = elems.length; i2 < l && !elem; i2++) {
    if (!isTag$4(elems[i2])) {
      continue;
    } else if (test(elems[i2])) {
      elem = elems[i2];
    } else if (elems[i2].children.length > 0) {
      elem = findOne$1(test, elems[i2].children);
    }
  }
  return elem;
}
function existsOne$1(test, elems) {
  for (var i2 = 0, l = elems.length; i2 < l; i2++) {
    if (isTag$4(elems[i2]) && (test(elems[i2]) || elems[i2].children.length > 0 && existsOne$1(test, elems[i2].children))) {
      return true;
    }
  }
  return false;
}
function findAll$1(test, elems) {
  var result = [];
  for (var i2 = 0, j2 = elems.length; i2 < j2; i2++) {
    if (!isTag$4(elems[i2]))
      continue;
    if (test(elems[i2]))
      result.push(elems[i2]);
    if (elems[i2].children.length > 0) {
      result = result.concat(findAll$1(test, elems[i2].children));
    }
  }
  return result;
}
var legacy = {};
var ElementType = domelementtype;
var isTag$3 = legacy.isTag = ElementType.isTag;
legacy.testElement = function(options2, element2) {
  for (var key in options2) {
    if (!options2.hasOwnProperty(key))
      ;
    else if (key === "tag_name") {
      if (!isTag$3(element2) || !options2.tag_name(element2.name)) {
        return false;
      }
    } else if (key === "tag_type") {
      if (!options2.tag_type(element2.type))
        return false;
    } else if (key === "tag_contains") {
      if (isTag$3(element2) || !options2.tag_contains(element2.data)) {
        return false;
      }
    } else if (!element2.attribs || !options2[key](element2.attribs[key])) {
      return false;
    }
  }
  return true;
};
var Checks = {
  tag_name: function(name2) {
    if (typeof name2 === "function") {
      return function(elem) {
        return isTag$3(elem) && name2(elem.name);
      };
    } else if (name2 === "*") {
      return isTag$3;
    } else {
      return function(elem) {
        return isTag$3(elem) && elem.name === name2;
      };
    }
  },
  tag_type: function(type) {
    if (typeof type === "function") {
      return function(elem) {
        return type(elem.type);
      };
    } else {
      return function(elem) {
        return elem.type === type;
      };
    }
  },
  tag_contains: function(data2) {
    if (typeof data2 === "function") {
      return function(elem) {
        return !isTag$3(elem) && data2(elem.data);
      };
    } else {
      return function(elem) {
        return !isTag$3(elem) && elem.data === data2;
      };
    }
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return function(elem) {
      return elem.attribs && value(elem.attribs[attrib]);
    };
  } else {
    return function(elem) {
      return elem.attribs && elem.attribs[attrib] === value;
    };
  }
}
function combineFuncs(a, b) {
  return function(elem) {
    return a(elem) || b(elem);
  };
}
legacy.getElements = function(options2, element2, recurse, limit) {
  var funcs = Object.keys(options2).map(function(key) {
    var value = options2[key];
    return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? [] : this.filter(
    funcs.reduce(combineFuncs),
    element2,
    recurse,
    limit
  );
};
legacy.getElementById = function(id, element2, recurse) {
  if (!Array.isArray(element2))
    element2 = [element2];
  return this.findOne(getAttribCheck("id", id), element2, recurse !== false);
};
legacy.getElementsByTagName = function(name2, element2, recurse, limit) {
  return this.filter(Checks.tag_name(name2), element2, recurse, limit);
};
legacy.getElementsByTagType = function(type, element2, recurse, limit) {
  return this.filter(Checks.tag_type(type), element2, recurse, limit);
};
var helpers = {};
helpers.removeSubsets = function(nodes) {
  var idx = nodes.length, node2, ancestor, replace;
  while (--idx > -1) {
    node2 = ancestor = nodes[idx];
    nodes[idx] = null;
    replace = true;
    while (ancestor) {
      if (nodes.indexOf(ancestor) > -1) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = ancestor.parent;
    }
    if (replace) {
      nodes[idx] = node2;
    }
  }
  return nodes;
};
var POSITION = {
  DISCONNECTED: 1,
  PRECEDING: 2,
  FOLLOWING: 4,
  CONTAINS: 8,
  CONTAINED_BY: 16
};
var comparePos = helpers.compareDocumentPosition = function(nodeA, nodeB) {
  var aParents = [];
  var bParents = [];
  var current, sharedParent, siblings2, aSibling, bSibling, idx;
  if (nodeA === nodeB) {
    return 0;
  }
  current = nodeA;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = nodeB;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  idx = 0;
  while (aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return POSITION.DISCONNECTED;
  }
  sharedParent = aParents[idx - 1];
  siblings2 = sharedParent.children;
  aSibling = aParents[idx];
  bSibling = bParents[idx];
  if (siblings2.indexOf(aSibling) > siblings2.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
    }
    return POSITION.FOLLOWING;
  } else {
    if (sharedParent === nodeA) {
      return POSITION.PRECEDING | POSITION.CONTAINS;
    }
    return POSITION.PRECEDING;
  }
};
helpers.uniqueSort = function(nodes) {
  var idx = nodes.length, node2, position;
  nodes = nodes.slice();
  while (--idx > -1) {
    node2 = nodes[idx];
    position = nodes.indexOf(node2);
    if (position > -1 && position < idx) {
      nodes.splice(idx, 1);
    }
  }
  nodes.sort(function(a, b) {
    var relative = comparePos(a, b);
    if (relative & POSITION.PRECEDING) {
      return -1;
    } else if (relative & POSITION.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
};
(function(module) {
  var DomUtils2 = module.exports;
  [
    stringify$1,
    traversal,
    manipulation$1,
    querying,
    legacy,
    helpers
  ].forEach(function(ext) {
    Object.keys(ext).forEach(function(key) {
      DomUtils2[key] = ext[key].bind(DomUtils2);
    });
  });
})(domutils);
var FeedHandler_1;
var hasRequiredFeedHandler;
function requireFeedHandler() {
  if (hasRequiredFeedHandler)
    return FeedHandler_1;
  hasRequiredFeedHandler = 1;
  var DomHandler3 = domhandler;
  var DomUtils2 = domutilsExports;
  function FeedHandler(callback, options2) {
    this.init(callback, options2);
  }
  inherits_browserExports(FeedHandler, DomHandler3);
  FeedHandler.prototype.init = DomHandler3;
  function getElements2(what, where) {
    return DomUtils2.getElementsByTagName(what, where, true);
  }
  function getOneElement2(what, where) {
    return DomUtils2.getElementsByTagName(what, where, true, 1)[0];
  }
  function fetch2(what, where, recurse) {
    return DomUtils2.getText(
      DomUtils2.getElementsByTagName(what, where, recurse, 1)
    ).trim();
  }
  function addConditionally2(obj, prop2, what, where, recurse) {
    var tmp = fetch2(what, where, recurse);
    if (tmp)
      obj[prop2] = tmp;
  }
  var isValidFeed2 = function(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
  };
  FeedHandler.prototype.onend = function() {
    var feed = {}, feedRoot = getOneElement2(isValidFeed2, this.dom), tmp, childs;
    if (feedRoot) {
      if (feedRoot.name === "feed") {
        childs = feedRoot.children;
        feed.type = "atom";
        addConditionally2(feed, "id", "id", childs);
        addConditionally2(feed, "title", "title", childs);
        if ((tmp = getOneElement2("link", childs)) && (tmp = tmp.attribs) && (tmp = tmp.href))
          feed.link = tmp;
        addConditionally2(feed, "description", "subtitle", childs);
        if (tmp = fetch2("updated", childs))
          feed.updated = new Date(tmp);
        addConditionally2(feed, "author", "email", childs, true);
        feed.items = getElements2("entry", childs).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally2(entry, "id", "id", item);
          addConditionally2(entry, "title", "title", item);
          if ((tmp2 = getOneElement2("link", item)) && (tmp2 = tmp2.attribs) && (tmp2 = tmp2.href))
            entry.link = tmp2;
          if (tmp2 = fetch2("summary", item) || fetch2("content", item))
            entry.description = tmp2;
          if (tmp2 = fetch2("updated", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      } else {
        childs = getOneElement2("channel", feedRoot.children).children;
        feed.type = feedRoot.name.substr(0, 3);
        feed.id = "";
        addConditionally2(feed, "title", "title", childs);
        addConditionally2(feed, "link", "link", childs);
        addConditionally2(feed, "description", "description", childs);
        if (tmp = fetch2("lastBuildDate", childs))
          feed.updated = new Date(tmp);
        addConditionally2(feed, "author", "managingEditor", childs, true);
        feed.items = getElements2("item", feedRoot.children).map(function(item) {
          var entry = {}, tmp2;
          item = item.children;
          addConditionally2(entry, "id", "guid", item);
          addConditionally2(entry, "title", "title", item);
          addConditionally2(entry, "link", "link", item);
          addConditionally2(entry, "description", "description", item);
          if (tmp2 = fetch2("pubDate", item))
            entry.pubDate = new Date(tmp2);
          return entry;
        });
      }
    }
    this.dom = feed;
    DomHandler3.prototype._handleCallback.call(
      this,
      feedRoot ? null : Error("couldn't find root of feed")
    );
  };
  FeedHandler_1 = FeedHandler;
  return FeedHandler_1;
}
const __viteBrowserExternal = new Proxy({}, {
  get(_2, key) {
    throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
  }
});
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var WritableStream_1;
var hasRequiredWritableStream;
function requireWritableStream() {
  if (hasRequiredWritableStream)
    return WritableStream_1;
  hasRequiredWritableStream = 1;
  WritableStream_1 = Stream;
  var Parser4 = Parser_1;
  var WritableStream2 = require$$1$1.Writable;
  var StringDecoder = require$$2$2.StringDecoder;
  var Buffer2 = require$$3.Buffer;
  function Stream(cbs, options2) {
    var parser2 = this._parser = new Parser4(cbs, options2);
    var decoder = this._decoder = new StringDecoder();
    WritableStream2.call(this, { decodeStrings: false });
    this.once("finish", function() {
      parser2.end(decoder.end());
    });
  }
  inherits_browserExports(Stream, WritableStream2);
  Stream.prototype._write = function(chunk, encoding, cb) {
    if (chunk instanceof Buffer2)
      chunk = this._decoder.write(chunk);
    this._parser.write(chunk);
    cb();
  };
  return WritableStream_1;
}
var Stream_1;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream)
    return Stream_1;
  hasRequiredStream = 1;
  Stream_1 = Stream;
  var Parser4 = requireWritableStream();
  function Stream(options2) {
    Parser4.call(this, new Cbs(this), options2);
  }
  inherits_browserExports(Stream, Parser4);
  Stream.prototype.readable = true;
  function Cbs(scope) {
    this.scope = scope;
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function(name2) {
    if (EVENTS[name2] === 0) {
      Cbs.prototype["on" + name2] = function() {
        this.scope.emit(name2);
      };
    } else if (EVENTS[name2] === 1) {
      Cbs.prototype["on" + name2] = function(a) {
        this.scope.emit(name2, a);
      };
    } else if (EVENTS[name2] === 2) {
      Cbs.prototype["on" + name2] = function(a, b) {
        this.scope.emit(name2, a, b);
      };
    } else {
      throw Error("wrong number of arguments!");
    }
  });
  return Stream_1;
}
var ProxyHandler_1;
var hasRequiredProxyHandler;
function requireProxyHandler() {
  if (hasRequiredProxyHandler)
    return ProxyHandler_1;
  hasRequiredProxyHandler = 1;
  ProxyHandler_1 = ProxyHandler;
  function ProxyHandler(cbs) {
    this._cbs = cbs || {};
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function(name2) {
    if (EVENTS[name2] === 0) {
      name2 = "on" + name2;
      ProxyHandler.prototype[name2] = function() {
        if (this._cbs[name2])
          this._cbs[name2]();
      };
    } else if (EVENTS[name2] === 1) {
      name2 = "on" + name2;
      ProxyHandler.prototype[name2] = function(a) {
        if (this._cbs[name2])
          this._cbs[name2](a);
      };
    } else if (EVENTS[name2] === 2) {
      name2 = "on" + name2;
      ProxyHandler.prototype[name2] = function(a, b) {
        if (this._cbs[name2])
          this._cbs[name2](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  return ProxyHandler_1;
}
var CollectingHandler_1;
var hasRequiredCollectingHandler;
function requireCollectingHandler() {
  if (hasRequiredCollectingHandler)
    return CollectingHandler_1;
  hasRequiredCollectingHandler = 1;
  CollectingHandler_1 = CollectingHandler;
  function CollectingHandler(cbs) {
    this._cbs = cbs || {};
    this.events = [];
  }
  var EVENTS = requireLib().EVENTS;
  Object.keys(EVENTS).forEach(function(name2) {
    if (EVENTS[name2] === 0) {
      name2 = "on" + name2;
      CollectingHandler.prototype[name2] = function() {
        this.events.push([name2]);
        if (this._cbs[name2])
          this._cbs[name2]();
      };
    } else if (EVENTS[name2] === 1) {
      name2 = "on" + name2;
      CollectingHandler.prototype[name2] = function(a) {
        this.events.push([name2, a]);
        if (this._cbs[name2])
          this._cbs[name2](a);
      };
    } else if (EVENTS[name2] === 2) {
      name2 = "on" + name2;
      CollectingHandler.prototype[name2] = function(a, b) {
        this.events.push([name2, a, b]);
        if (this._cbs[name2])
          this._cbs[name2](a, b);
      };
    } else {
      throw Error("wrong number of arguments");
    }
  });
  CollectingHandler.prototype.onreset = function() {
    this.events = [];
    if (this._cbs.onreset)
      this._cbs.onreset();
  };
  CollectingHandler.prototype.restart = function() {
    if (this._cbs.onreset)
      this._cbs.onreset();
    for (var i2 = 0, len = this.events.length; i2 < len; i2++) {
      if (this._cbs[this.events[i2][0]]) {
        var num2 = this.events[i2].length;
        if (num2 === 1) {
          this._cbs[this.events[i2][0]]();
        } else if (num2 === 2) {
          this._cbs[this.events[i2][0]](this.events[i2][1]);
        } else {
          this._cbs[this.events[i2][0]](
            this.events[i2][1],
            this.events[i2][2]
          );
        }
      }
    }
  };
  return CollectingHandler_1;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib)
    return libExports;
  hasRequiredLib = 1;
  (function(module) {
    var Parser4 = Parser_1;
    var DomHandler3 = domhandler;
    function defineProp(name2, value) {
      delete module.exports[name2];
      module.exports[name2] = value;
      return value;
    }
    module.exports = {
      Parser: Parser4,
      Tokenizer: Tokenizer_1,
      ElementType: domelementtype,
      DomHandler: DomHandler3,
      get FeedHandler() {
        return defineProp("FeedHandler", requireFeedHandler());
      },
      get Stream() {
        return defineProp("Stream", requireStream());
      },
      get WritableStream() {
        return defineProp("WritableStream", requireWritableStream());
      },
      get ProxyHandler() {
        return defineProp("ProxyHandler", requireProxyHandler());
      },
      get DomUtils() {
        return defineProp("DomUtils", domutilsExports);
      },
      get CollectingHandler() {
        return defineProp(
          "CollectingHandler",
          requireCollectingHandler()
        );
      },
      // For legacy support
      DefaultHandler: DomHandler3,
      get RssHandler() {
        return defineProp("RssHandler", this.FeedHandler);
      },
      //helper methods
      parseDOM: function(data2, options2) {
        var handler = new DomHandler3(options2);
        new Parser4(handler, options2).end(data2);
        return handler.dom;
      },
      parseFeed: function(feed, options2) {
        var handler = new module.exports.FeedHandler(options2);
        new Parser4(handler, options2).end(feed);
        return handler.dom;
      },
      createDomStream: function(cb, options2, elementCb) {
        var handler = new DomHandler3(cb, options2, elementCb);
        return new Parser4(handler, options2);
      },
      // List of all events that the parser emits
      EVENTS: {
        /* Format: eventname: number of arguments */
        attribute: 2,
        cdatastart: 0,
        cdataend: 0,
        text: 1,
        processinginstruction: 2,
        comment: 1,
        commentend: 0,
        closetag: 1,
        opentag: 2,
        opentagname: 1,
        error: 1,
        end: 0
      }
    };
  })(lib$1);
  return libExports;
}
var lib = {};
var parserExports = {};
var parser = {
  get exports() {
    return parserExports;
  },
  set exports(v) {
    parserExports = v;
  }
};
var tokenizerExports = {};
var tokenizer = {
  get exports() {
    return tokenizerExports;
  },
  set exports(v) {
    tokenizerExports = v;
  }
};
var preprocessorExports = {};
var preprocessor = {
  get exports() {
    return preprocessorExports;
  },
  set exports(v) {
    preprocessorExports = v;
  }
};
var unicode = {};
unicode.REPLACEMENT_CHARACTER = "ï¿½";
unicode.CODE_POINTS = {
  EOF: -1,
  NULL: 0,
  TABULATION: 9,
  CARRIAGE_RETURN: 13,
  LINE_FEED: 10,
  FORM_FEED: 12,
  SPACE: 32,
  EXCLAMATION_MARK: 33,
  QUOTATION_MARK: 34,
  NUMBER_SIGN: 35,
  AMPERSAND: 38,
  APOSTROPHE: 39,
  HYPHEN_MINUS: 45,
  SOLIDUS: 47,
  DIGIT_0: 48,
  DIGIT_9: 57,
  SEMICOLON: 59,
  LESS_THAN_SIGN: 60,
  EQUALS_SIGN: 61,
  GREATER_THAN_SIGN: 62,
  QUESTION_MARK: 63,
  LATIN_CAPITAL_A: 65,
  LATIN_CAPITAL_F: 70,
  LATIN_CAPITAL_X: 88,
  LATIN_CAPITAL_Z: 90,
  GRAVE_ACCENT: 96,
  LATIN_SMALL_A: 97,
  LATIN_SMALL_F: 102,
  LATIN_SMALL_X: 120,
  LATIN_SMALL_Z: 122,
  REPLACEMENT_CHARACTER: 65533
};
unicode.CODE_POINT_SEQUENCES = {
  DASH_DASH_STRING: [45, 45],
  //--
  DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
  //DOCTYPE
  CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
  //[CDATA[
  CDATA_END_STRING: [93, 93, 62],
  //]]>
  SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
  //script
  PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
  //PUBLIC
  SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
  //SYSTEM
};
var UNICODE$4 = unicode;
var $$a = UNICODE$4.CODE_POINTS;
function isSurrogatePair(cp1, cp2) {
  return cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343;
}
function getSurrogatePairCodePoint(cp1, cp2) {
  return (cp1 - 55296) * 1024 + 9216 + cp2;
}
var DEFAULT_BUFFER_WATERLINE = 1 << 16;
var Preprocessor$1 = preprocessor.exports = function() {
  this.html = null;
  this.pos = -1;
  this.lastGapPos = -1;
  this.lastCharPos = -1;
  this.gapStack = [];
  this.skipNextNewLine = false;
  this.lastChunkWritten = false;
  this.endOfChunkHit = false;
  this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
};
Preprocessor$1.prototype.dropParsedChunk = function() {
  if (this.pos > this.bufferWaterline) {
    this.lastCharPos -= this.pos;
    this.html = this.html.substring(this.pos);
    this.pos = 0;
    this.lastGapPos = -1;
    this.gapStack = [];
  }
};
Preprocessor$1.prototype._addGap = function() {
  this.gapStack.push(this.lastGapPos);
  this.lastGapPos = this.pos;
};
Preprocessor$1.prototype._processHighRangeCodePoint = function(cp) {
  if (this.pos !== this.lastCharPos) {
    var nextCp = this.html.charCodeAt(this.pos + 1);
    if (isSurrogatePair(cp, nextCp)) {
      this.pos++;
      cp = getSurrogatePairCodePoint(cp, nextCp);
      this._addGap();
    }
  } else if (!this.lastChunkWritten) {
    this.endOfChunkHit = true;
    return $$a.EOF;
  }
  return cp;
};
Preprocessor$1.prototype.write = function(chunk, isLastChunk) {
  if (this.html)
    this.html += chunk;
  else
    this.html = chunk;
  this.lastCharPos = this.html.length - 1;
  this.endOfChunkHit = false;
  this.lastChunkWritten = isLastChunk;
};
Preprocessor$1.prototype.insertHtmlAtCurrentPos = function(chunk) {
  this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
  this.lastCharPos = this.html.length - 1;
  this.endOfChunkHit = false;
};
Preprocessor$1.prototype.advance = function() {
  this.pos++;
  if (this.pos > this.lastCharPos) {
    if (!this.lastChunkWritten)
      this.endOfChunkHit = true;
    return $$a.EOF;
  }
  var cp = this.html.charCodeAt(this.pos);
  if (this.skipNextNewLine && cp === $$a.LINE_FEED) {
    this.skipNextNewLine = false;
    this._addGap();
    return this.advance();
  }
  if (cp === $$a.CARRIAGE_RETURN) {
    this.skipNextNewLine = true;
    return $$a.LINE_FEED;
  }
  this.skipNextNewLine = false;
  return cp >= 55296 ? this._processHighRangeCodePoint(cp) : cp;
};
Preprocessor$1.prototype.retreat = function() {
  if (this.pos === this.lastGapPos) {
    this.lastGapPos = this.gapStack.pop();
    this.pos--;
  }
  this.pos--;
};
var named_entity_data = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
var Preprocessor2 = preprocessorExports, UNICODE$3 = unicode, neTree = named_entity_data;
var $$9 = UNICODE$3.CODE_POINTS, $$ = UNICODE$3.CODE_POINT_SEQUENCES;
var NUMERIC_ENTITY_REPLACEMENTS = {
  0: 65533,
  13: 13,
  128: 8364,
  129: 129,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  141: 141,
  142: 381,
  143: 143,
  144: 144,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  157: 157,
  158: 382,
  159: 376
};
var HAS_DATA_FLAG = 1 << 0;
var DATA_DUPLET_FLAG = 1 << 1;
var HAS_BRANCHES_FLAG = 1 << 2;
var MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
var DATA_STATE = "DATA_STATE", CHARACTER_REFERENCE_IN_DATA_STATE = "CHARACTER_REFERENCE_IN_DATA_STATE", RCDATA_STATE = "RCDATA_STATE", CHARACTER_REFERENCE_IN_RCDATA_STATE = "CHARACTER_REFERENCE_IN_RCDATA_STATE", RAWTEXT_STATE = "RAWTEXT_STATE", SCRIPT_DATA_STATE = "SCRIPT_DATA_STATE", PLAINTEXT_STATE = "PLAINTEXT_STATE", TAG_OPEN_STATE = "TAG_OPEN_STATE", END_TAG_OPEN_STATE = "END_TAG_OPEN_STATE", TAG_NAME_STATE = "TAG_NAME_STATE", RCDATA_LESS_THAN_SIGN_STATE = "RCDATA_LESS_THAN_SIGN_STATE", RCDATA_END_TAG_OPEN_STATE = "RCDATA_END_TAG_OPEN_STATE", RCDATA_END_TAG_NAME_STATE = "RCDATA_END_TAG_NAME_STATE", RAWTEXT_LESS_THAN_SIGN_STATE = "RAWTEXT_LESS_THAN_SIGN_STATE", RAWTEXT_END_TAG_OPEN_STATE = "RAWTEXT_END_TAG_OPEN_STATE", RAWTEXT_END_TAG_NAME_STATE = "RAWTEXT_END_TAG_NAME_STATE", SCRIPT_DATA_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_LESS_THAN_SIGN_STATE", SCRIPT_DATA_END_TAG_OPEN_STATE = "SCRIPT_DATA_END_TAG_OPEN_STATE", SCRIPT_DATA_END_TAG_NAME_STATE = "SCRIPT_DATA_END_TAG_NAME_STATE", SCRIPT_DATA_ESCAPE_START_STATE = "SCRIPT_DATA_ESCAPE_START_STATE", SCRIPT_DATA_ESCAPE_START_DASH_STATE = "SCRIPT_DATA_ESCAPE_START_DASH_STATE", SCRIPT_DATA_ESCAPED_STATE = "SCRIPT_DATA_ESCAPED_STATE", SCRIPT_DATA_ESCAPED_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_STATE", SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE", SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE", SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE", SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE", SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE", SCRIPT_DATA_DOUBLE_ESCAPED_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE", SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE", SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE", SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE", SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE", BEFORE_ATTRIBUTE_NAME_STATE = "BEFORE_ATTRIBUTE_NAME_STATE", ATTRIBUTE_NAME_STATE = "ATTRIBUTE_NAME_STATE", AFTER_ATTRIBUTE_NAME_STATE = "AFTER_ATTRIBUTE_NAME_STATE", BEFORE_ATTRIBUTE_VALUE_STATE = "BEFORE_ATTRIBUTE_VALUE_STATE", ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE", ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE", ATTRIBUTE_VALUE_UNQUOTED_STATE = "ATTRIBUTE_VALUE_UNQUOTED_STATE", CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE = "CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE", AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE", SELF_CLOSING_START_TAG_STATE = "SELF_CLOSING_START_TAG_STATE", BOGUS_COMMENT_STATE = "BOGUS_COMMENT_STATE", BOGUS_COMMENT_STATE_CONTINUATION = "BOGUS_COMMENT_STATE_CONTINUATION", MARKUP_DECLARATION_OPEN_STATE = "MARKUP_DECLARATION_OPEN_STATE", COMMENT_START_STATE = "COMMENT_START_STATE", COMMENT_START_DASH_STATE = "COMMENT_START_DASH_STATE", COMMENT_STATE = "COMMENT_STATE", COMMENT_END_DASH_STATE = "COMMENT_END_DASH_STATE", COMMENT_END_STATE = "COMMENT_END_STATE", COMMENT_END_BANG_STATE = "COMMENT_END_BANG_STATE", DOCTYPE_STATE = "DOCTYPE_STATE", DOCTYPE_NAME_STATE = "DOCTYPE_NAME_STATE", AFTER_DOCTYPE_NAME_STATE = "AFTER_DOCTYPE_NAME_STATE", BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE", DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE", DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE", BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE", BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE", DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE", DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE", AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE", BOGUS_DOCTYPE_STATE = "BOGUS_DOCTYPE_STATE", CDATA_SECTION_STATE = "CDATA_SECTION_STATE";
function isWhitespace$1(cp) {
  return cp === $$9.SPACE || cp === $$9.LINE_FEED || cp === $$9.TABULATION || cp === $$9.FORM_FEED;
}
function isAsciiDigit(cp) {
  return cp >= $$9.DIGIT_0 && cp <= $$9.DIGIT_9;
}
function isAsciiUpper(cp) {
  return cp >= $$9.LATIN_CAPITAL_A && cp <= $$9.LATIN_CAPITAL_Z;
}
function isAsciiLower(cp) {
  return cp >= $$9.LATIN_SMALL_A && cp <= $$9.LATIN_SMALL_Z;
}
function isAsciiLetter(cp) {
  return isAsciiLower(cp) || isAsciiUpper(cp);
}
function isAsciiAlphaNumeric(cp) {
  return isAsciiLetter(cp) || isAsciiDigit(cp);
}
function isDigit(cp, isHex) {
  return isAsciiDigit(cp) || isHex && (cp >= $$9.LATIN_CAPITAL_A && cp <= $$9.LATIN_CAPITAL_F || cp >= $$9.LATIN_SMALL_A && cp <= $$9.LATIN_SMALL_F);
}
function isReservedCodePoint(cp) {
  return cp >= 55296 && cp <= 57343 || cp > 1114111;
}
function toAsciiLowerCodePoint(cp) {
  return cp + 32;
}
function toChar(cp) {
  if (cp <= 65535)
    return String.fromCharCode(cp);
  cp -= 65536;
  return String.fromCharCode(cp >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | cp & 1023);
}
function toAsciiLowerChar(cp) {
  return String.fromCharCode(toAsciiLowerCodePoint(cp));
}
function findNamedEntityTreeBranch(nodeIx, cp) {
  var branchCount = neTree[++nodeIx], lo = ++nodeIx, hi = lo + branchCount - 1;
  while (lo <= hi) {
    var mid2 = lo + hi >>> 1, midCp = neTree[mid2];
    if (midCp < cp)
      lo = mid2 + 1;
    else if (midCp > cp)
      hi = mid2 - 1;
    else
      return neTree[mid2 + branchCount];
  }
  return -1;
}
var Tokenizer$6 = tokenizer.exports = function() {
  this.preprocessor = new Preprocessor2();
  this.tokenQueue = [];
  this.allowCDATA = false;
  this.state = DATA_STATE;
  this.returnState = "";
  this.tempBuff = [];
  this.additionalAllowedCp = void 0;
  this.lastStartTagName = "";
  this.consumedAfterSnapshot = -1;
  this.active = false;
  this.currentCharacterToken = null;
  this.currentToken = null;
  this.currentAttr = null;
};
Tokenizer$6.CHARACTER_TOKEN = "CHARACTER_TOKEN";
Tokenizer$6.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
Tokenizer$6.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
Tokenizer$6.START_TAG_TOKEN = "START_TAG_TOKEN";
Tokenizer$6.END_TAG_TOKEN = "END_TAG_TOKEN";
Tokenizer$6.COMMENT_TOKEN = "COMMENT_TOKEN";
Tokenizer$6.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
Tokenizer$6.EOF_TOKEN = "EOF_TOKEN";
Tokenizer$6.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
Tokenizer$6.MODE = {
  DATA: DATA_STATE,
  RCDATA: RCDATA_STATE,
  RAWTEXT: RAWTEXT_STATE,
  SCRIPT_DATA: SCRIPT_DATA_STATE,
  PLAINTEXT: PLAINTEXT_STATE
};
Tokenizer$6.getTokenAttr = function(token, attrName) {
  for (var i2 = token.attrs.length - 1; i2 >= 0; i2--) {
    if (token.attrs[i2].name === attrName)
      return token.attrs[i2].value;
  }
  return null;
};
Tokenizer$6.prototype.getNextToken = function() {
  while (!this.tokenQueue.length && this.active) {
    this._hibernationSnapshot();
    var cp = this._consume();
    if (!this._ensureHibernation())
      this[this.state](cp);
  }
  return this.tokenQueue.shift();
};
Tokenizer$6.prototype.write = function(chunk, isLastChunk) {
  this.active = true;
  this.preprocessor.write(chunk, isLastChunk);
};
Tokenizer$6.prototype.insertHtmlAtCurrentPos = function(chunk) {
  this.active = true;
  this.preprocessor.insertHtmlAtCurrentPos(chunk);
};
Tokenizer$6.prototype._hibernationSnapshot = function() {
  this.consumedAfterSnapshot = 0;
};
Tokenizer$6.prototype._ensureHibernation = function() {
  if (this.preprocessor.endOfChunkHit) {
    for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--)
      this.preprocessor.retreat();
    this.active = false;
    this.tokenQueue.push({ type: Tokenizer$6.HIBERNATION_TOKEN });
    return true;
  }
  return false;
};
Tokenizer$6.prototype._consume = function() {
  this.consumedAfterSnapshot++;
  return this.preprocessor.advance();
};
Tokenizer$6.prototype._unconsume = function() {
  this.consumedAfterSnapshot--;
  this.preprocessor.retreat();
};
Tokenizer$6.prototype._unconsumeSeveral = function(count) {
  while (count--)
    this._unconsume();
};
Tokenizer$6.prototype._reconsumeInState = function(state) {
  this.state = state;
  this._unconsume();
};
Tokenizer$6.prototype._consumeSubsequentIfMatch = function(pattern, startCp, caseSensitive) {
  var consumedCount = 0, isMatch = true, patternLength = pattern.length, patternPos = 0, cp = startCp, patternCp = void 0;
  for (; patternPos < patternLength; patternPos++) {
    if (patternPos > 0) {
      cp = this._consume();
      consumedCount++;
    }
    if (cp === $$9.EOF) {
      isMatch = false;
      break;
    }
    patternCp = pattern[patternPos];
    if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
      isMatch = false;
      break;
    }
  }
  if (!isMatch)
    this._unconsumeSeveral(consumedCount);
  return isMatch;
};
Tokenizer$6.prototype._lookahead = function() {
  var cp = this._consume();
  this._unconsume();
  return cp;
};
Tokenizer$6.prototype.isTempBufferEqualToScriptString = function() {
  if (this.tempBuff.length !== $$.SCRIPT_STRING.length)
    return false;
  for (var i2 = 0; i2 < this.tempBuff.length; i2++) {
    if (this.tempBuff[i2] !== $$.SCRIPT_STRING[i2])
      return false;
  }
  return true;
};
Tokenizer$6.prototype._createStartTagToken = function() {
  this.currentToken = {
    type: Tokenizer$6.START_TAG_TOKEN,
    tagName: "",
    selfClosing: false,
    attrs: []
  };
};
Tokenizer$6.prototype._createEndTagToken = function() {
  this.currentToken = {
    type: Tokenizer$6.END_TAG_TOKEN,
    tagName: "",
    attrs: []
  };
};
Tokenizer$6.prototype._createCommentToken = function() {
  this.currentToken = {
    type: Tokenizer$6.COMMENT_TOKEN,
    data: ""
  };
};
Tokenizer$6.prototype._createDoctypeToken = function(initialName) {
  this.currentToken = {
    type: Tokenizer$6.DOCTYPE_TOKEN,
    name: initialName,
    forceQuirks: false,
    publicId: null,
    systemId: null
  };
};
Tokenizer$6.prototype._createCharacterToken = function(type, ch) {
  this.currentCharacterToken = {
    type,
    chars: ch
  };
};
Tokenizer$6.prototype._createAttr = function(attrNameFirstCh) {
  this.currentAttr = {
    name: attrNameFirstCh,
    value: ""
  };
};
Tokenizer$6.prototype._isDuplicateAttr = function() {
  return Tokenizer$6.getTokenAttr(this.currentToken, this.currentAttr.name) !== null;
};
Tokenizer$6.prototype._leaveAttrName = function(toState) {
  this.state = toState;
  if (!this._isDuplicateAttr())
    this.currentToken.attrs.push(this.currentAttr);
};
Tokenizer$6.prototype._leaveAttrValue = function(toState) {
  this.state = toState;
};
Tokenizer$6.prototype._isAppropriateEndTagToken = function() {
  return this.lastStartTagName === this.currentToken.tagName;
};
Tokenizer$6.prototype._emitCurrentToken = function() {
  this._emitCurrentCharacterToken();
  if (this.currentToken.type === Tokenizer$6.START_TAG_TOKEN)
    this.lastStartTagName = this.currentToken.tagName;
  this.tokenQueue.push(this.currentToken);
  this.currentToken = null;
};
Tokenizer$6.prototype._emitCurrentCharacterToken = function() {
  if (this.currentCharacterToken) {
    this.tokenQueue.push(this.currentCharacterToken);
    this.currentCharacterToken = null;
  }
};
Tokenizer$6.prototype._emitEOFToken = function() {
  this._emitCurrentCharacterToken();
  this.tokenQueue.push({ type: Tokenizer$6.EOF_TOKEN });
};
Tokenizer$6.prototype._appendCharToCurrentCharacterToken = function(type, ch) {
  if (this.currentCharacterToken && this.currentCharacterToken.type !== type)
    this._emitCurrentCharacterToken();
  if (this.currentCharacterToken)
    this.currentCharacterToken.chars += ch;
  else
    this._createCharacterToken(type, ch);
};
Tokenizer$6.prototype._emitCodePoint = function(cp) {
  var type = Tokenizer$6.CHARACTER_TOKEN;
  if (isWhitespace$1(cp))
    type = Tokenizer$6.WHITESPACE_CHARACTER_TOKEN;
  else if (cp === $$9.NULL)
    type = Tokenizer$6.NULL_CHARACTER_TOKEN;
  this._appendCharToCurrentCharacterToken(type, toChar(cp));
};
Tokenizer$6.prototype._emitSeveralCodePoints = function(codePoints) {
  for (var i2 = 0; i2 < codePoints.length; i2++)
    this._emitCodePoint(codePoints[i2]);
};
Tokenizer$6.prototype._emitChar = function(ch) {
  this._appendCharToCurrentCharacterToken(Tokenizer$6.CHARACTER_TOKEN, ch);
};
Tokenizer$6.prototype._consumeNumericEntity = function(isHex) {
  var digits = "", nextCp = void 0;
  do {
    digits += toChar(this._consume());
    nextCp = this._lookahead();
  } while (nextCp !== $$9.EOF && isDigit(nextCp, isHex));
  if (this._lookahead() === $$9.SEMICOLON)
    this._consume();
  var referencedCp = parseInt(digits, isHex ? 16 : 10), replacement = NUMERIC_ENTITY_REPLACEMENTS[referencedCp];
  if (replacement)
    return replacement;
  if (isReservedCodePoint(referencedCp))
    return $$9.REPLACEMENT_CHARACTER;
  return referencedCp;
};
Tokenizer$6.prototype._consumeNamedEntity = function(inAttr) {
  var referencedCodePoints = null, referenceSize = 0, cp = null, consumedCount = 0, semicolonTerminated = false;
  for (var i2 = 0; i2 > -1; ) {
    var current = neTree[i2], inNode = current < MAX_BRANCH_MARKER_VALUE, nodeWithData = inNode && current & HAS_DATA_FLAG;
    if (nodeWithData) {
      referencedCodePoints = current & DATA_DUPLET_FLAG ? [neTree[++i2], neTree[++i2]] : [neTree[++i2]];
      referenceSize = consumedCount;
      if (cp === $$9.SEMICOLON) {
        semicolonTerminated = true;
        break;
      }
    }
    cp = this._consume();
    consumedCount++;
    if (cp === $$9.EOF)
      break;
    if (inNode)
      i2 = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i2, cp) : -1;
    else
      i2 = cp === current ? ++i2 : -1;
  }
  if (referencedCodePoints) {
    if (!semicolonTerminated) {
      this._unconsumeSeveral(consumedCount - referenceSize);
      if (inAttr) {
        var nextCp = this._lookahead();
        if (nextCp === $$9.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp)) {
          this._unconsumeSeveral(referenceSize);
          return null;
        }
      }
    }
    return referencedCodePoints;
  }
  this._unconsumeSeveral(consumedCount);
  return null;
};
Tokenizer$6.prototype._consumeCharacterReference = function(startCp, inAttr) {
  if (isWhitespace$1(startCp) || startCp === $$9.GREATER_THAN_SIGN || startCp === $$9.AMPERSAND || startCp === this.additionalAllowedCp || startCp === $$9.EOF) {
    this._unconsume();
    return null;
  }
  if (startCp === $$9.NUMBER_SIGN) {
    var isHex = false, nextCp = this._lookahead();
    if (nextCp === $$9.LATIN_SMALL_X || nextCp === $$9.LATIN_CAPITAL_X) {
      this._consume();
      isHex = true;
    }
    nextCp = this._lookahead();
    if (nextCp !== $$9.EOF && isDigit(nextCp, isHex))
      return [this._consumeNumericEntity(isHex)];
    this._unconsumeSeveral(isHex ? 2 : 1);
    return null;
  }
  this._unconsume();
  return this._consumeNamedEntity(inAttr);
};
var _$3 = Tokenizer$6.prototype;
_$3[DATA_STATE] = function dataState(cp) {
  this.preprocessor.dropParsedChunk();
  if (cp === $$9.AMPERSAND)
    this.state = CHARACTER_REFERENCE_IN_DATA_STATE;
  else if (cp === $$9.LESS_THAN_SIGN)
    this.state = TAG_OPEN_STATE;
  else if (cp === $$9.NULL)
    this._emitCodePoint(cp);
  else if (cp === $$9.EOF)
    this._emitEOFToken();
  else
    this._emitCodePoint(cp);
};
_$3[CHARACTER_REFERENCE_IN_DATA_STATE] = function characterReferenceInDataState(cp) {
  this.additionalAllowedCp = void 0;
  var referencedCodePoints = this._consumeCharacterReference(cp, false);
  if (!this._ensureHibernation()) {
    if (referencedCodePoints)
      this._emitSeveralCodePoints(referencedCodePoints);
    else
      this._emitChar("&");
    this.state = DATA_STATE;
  }
};
_$3[RCDATA_STATE] = function rcdataState(cp) {
  this.preprocessor.dropParsedChunk();
  if (cp === $$9.AMPERSAND)
    this.state = CHARACTER_REFERENCE_IN_RCDATA_STATE;
  else if (cp === $$9.LESS_THAN_SIGN)
    this.state = RCDATA_LESS_THAN_SIGN_STATE;
  else if (cp === $$9.NULL)
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  else if (cp === $$9.EOF)
    this._emitEOFToken();
  else
    this._emitCodePoint(cp);
};
_$3[CHARACTER_REFERENCE_IN_RCDATA_STATE] = function characterReferenceInRcdataState(cp) {
  this.additionalAllowedCp = void 0;
  var referencedCodePoints = this._consumeCharacterReference(cp, false);
  if (!this._ensureHibernation()) {
    if (referencedCodePoints)
      this._emitSeveralCodePoints(referencedCodePoints);
    else
      this._emitChar("&");
    this.state = RCDATA_STATE;
  }
};
_$3[RAWTEXT_STATE] = function rawtextState(cp) {
  this.preprocessor.dropParsedChunk();
  if (cp === $$9.LESS_THAN_SIGN)
    this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
  else if (cp === $$9.NULL)
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  else if (cp === $$9.EOF)
    this._emitEOFToken();
  else
    this._emitCodePoint(cp);
};
_$3[SCRIPT_DATA_STATE] = function scriptDataState(cp) {
  this.preprocessor.dropParsedChunk();
  if (cp === $$9.LESS_THAN_SIGN)
    this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
  else if (cp === $$9.NULL)
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  else if (cp === $$9.EOF)
    this._emitEOFToken();
  else
    this._emitCodePoint(cp);
};
_$3[PLAINTEXT_STATE] = function plaintextState(cp) {
  this.preprocessor.dropParsedChunk();
  if (cp === $$9.NULL)
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  else if (cp === $$9.EOF)
    this._emitEOFToken();
  else
    this._emitCodePoint(cp);
};
_$3[TAG_OPEN_STATE] = function tagOpenState(cp) {
  if (cp === $$9.EXCLAMATION_MARK)
    this.state = MARKUP_DECLARATION_OPEN_STATE;
  else if (cp === $$9.SOLIDUS)
    this.state = END_TAG_OPEN_STATE;
  else if (isAsciiLetter(cp)) {
    this._createStartTagToken();
    this._reconsumeInState(TAG_NAME_STATE);
  } else if (cp === $$9.QUESTION_MARK)
    this._reconsumeInState(BOGUS_COMMENT_STATE);
  else {
    this._emitChar("<");
    this._reconsumeInState(DATA_STATE);
  }
};
_$3[END_TAG_OPEN_STATE] = function endTagOpenState(cp) {
  if (isAsciiLetter(cp)) {
    this._createEndTagToken();
    this._reconsumeInState(TAG_NAME_STATE);
  } else if (cp === $$9.GREATER_THAN_SIGN)
    this.state = DATA_STATE;
  else if (cp === $$9.EOF) {
    this._reconsumeInState(DATA_STATE);
    this._emitChar("<");
    this._emitChar("/");
  } else
    this._reconsumeInState(BOGUS_COMMENT_STATE);
};
_$3[TAG_NAME_STATE] = function tagNameState(cp) {
  if (isWhitespace$1(cp))
    this.state = BEFORE_ATTRIBUTE_NAME_STATE;
  else if (cp === $$9.SOLIDUS)
    this.state = SELF_CLOSING_START_TAG_STATE;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (isAsciiUpper(cp))
    this.currentToken.tagName += toAsciiLowerChar(cp);
  else if (cp === $$9.NULL)
    this.currentToken.tagName += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this.currentToken.tagName += toChar(cp);
};
_$3[RCDATA_LESS_THAN_SIGN_STATE] = function rcdataLessThanSignState(cp) {
  if (cp === $$9.SOLIDUS) {
    this.tempBuff = [];
    this.state = RCDATA_END_TAG_OPEN_STATE;
  } else {
    this._emitChar("<");
    this._reconsumeInState(RCDATA_STATE);
  }
};
_$3[RCDATA_END_TAG_OPEN_STATE] = function rcdataEndTagOpenState(cp) {
  if (isAsciiLetter(cp)) {
    this._createEndTagToken();
    this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
  } else {
    this._emitChar("<");
    this._emitChar("/");
    this._reconsumeInState(RCDATA_STATE);
  }
};
_$3[RCDATA_END_TAG_NAME_STATE] = function rcdataEndTagNameState(cp) {
  if (isAsciiUpper(cp)) {
    this.currentToken.tagName += toAsciiLowerChar(cp);
    this.tempBuff.push(cp);
  } else if (isAsciiLower(cp)) {
    this.currentToken.tagName += toChar(cp);
    this.tempBuff.push(cp);
  } else {
    if (this._isAppropriateEndTagToken()) {
      if (isWhitespace$1(cp)) {
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        return;
      }
      if (cp === $$9.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
        return;
      }
      if (cp === $$9.GREATER_THAN_SIGN) {
        this.state = DATA_STATE;
        this._emitCurrentToken();
        return;
      }
    }
    this._emitChar("<");
    this._emitChar("/");
    this._emitSeveralCodePoints(this.tempBuff);
    this._reconsumeInState(RCDATA_STATE);
  }
};
_$3[RAWTEXT_LESS_THAN_SIGN_STATE] = function rawtextLessThanSignState(cp) {
  if (cp === $$9.SOLIDUS) {
    this.tempBuff = [];
    this.state = RAWTEXT_END_TAG_OPEN_STATE;
  } else {
    this._emitChar("<");
    this._reconsumeInState(RAWTEXT_STATE);
  }
};
_$3[RAWTEXT_END_TAG_OPEN_STATE] = function rawtextEndTagOpenState(cp) {
  if (isAsciiLetter(cp)) {
    this._createEndTagToken();
    this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
  } else {
    this._emitChar("<");
    this._emitChar("/");
    this._reconsumeInState(RAWTEXT_STATE);
  }
};
_$3[RAWTEXT_END_TAG_NAME_STATE] = function rawtextEndTagNameState(cp) {
  if (isAsciiUpper(cp)) {
    this.currentToken.tagName += toAsciiLowerChar(cp);
    this.tempBuff.push(cp);
  } else if (isAsciiLower(cp)) {
    this.currentToken.tagName += toChar(cp);
    this.tempBuff.push(cp);
  } else {
    if (this._isAppropriateEndTagToken()) {
      if (isWhitespace$1(cp)) {
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        return;
      }
      if (cp === $$9.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
        return;
      }
      if (cp === $$9.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
        return;
      }
    }
    this._emitChar("<");
    this._emitChar("/");
    this._emitSeveralCodePoints(this.tempBuff);
    this._reconsumeInState(RAWTEXT_STATE);
  }
};
_$3[SCRIPT_DATA_LESS_THAN_SIGN_STATE] = function scriptDataLessThanSignState(cp) {
  if (cp === $$9.SOLIDUS) {
    this.tempBuff = [];
    this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
  } else if (cp === $$9.EXCLAMATION_MARK) {
    this.state = SCRIPT_DATA_ESCAPE_START_STATE;
    this._emitChar("<");
    this._emitChar("!");
  } else {
    this._emitChar("<");
    this._reconsumeInState(SCRIPT_DATA_STATE);
  }
};
_$3[SCRIPT_DATA_END_TAG_OPEN_STATE] = function scriptDataEndTagOpenState(cp) {
  if (isAsciiLetter(cp)) {
    this._createEndTagToken();
    this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
  } else {
    this._emitChar("<");
    this._emitChar("/");
    this._reconsumeInState(SCRIPT_DATA_STATE);
  }
};
_$3[SCRIPT_DATA_END_TAG_NAME_STATE] = function scriptDataEndTagNameState(cp) {
  if (isAsciiUpper(cp)) {
    this.currentToken.tagName += toAsciiLowerChar(cp);
    this.tempBuff.push(cp);
  } else if (isAsciiLower(cp)) {
    this.currentToken.tagName += toChar(cp);
    this.tempBuff.push(cp);
  } else {
    if (this._isAppropriateEndTagToken()) {
      if (isWhitespace$1(cp)) {
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        return;
      } else if (cp === $$9.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
        return;
      } else if (cp === $$9.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
        return;
      }
    }
    this._emitChar("<");
    this._emitChar("/");
    this._emitSeveralCodePoints(this.tempBuff);
    this._reconsumeInState(SCRIPT_DATA_STATE);
  }
};
_$3[SCRIPT_DATA_ESCAPE_START_STATE] = function scriptDataEscapeStartState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
    this._emitChar("-");
  } else
    this._reconsumeInState(SCRIPT_DATA_STATE);
};
_$3[SCRIPT_DATA_ESCAPE_START_DASH_STATE] = function scriptDataEscapeStartDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
    this._emitChar("-");
  } else
    this._reconsumeInState(SCRIPT_DATA_STATE);
};
_$3[SCRIPT_DATA_ESCAPED_STATE] = function scriptDataEscapedState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
    this._emitChar("-");
  } else if (cp === $$9.LESS_THAN_SIGN)
    this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  else if (cp === $$9.NULL)
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this._emitCodePoint(cp);
};
_$3[SCRIPT_DATA_ESCAPED_DASH_STATE] = function scriptDataEscapedDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
    this._emitChar("-");
  } else if (cp === $$9.LESS_THAN_SIGN)
    this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  else if (cp === $$9.NULL) {
    this.state = SCRIPT_DATA_ESCAPED_STATE;
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else {
    this.state = SCRIPT_DATA_ESCAPED_STATE;
    this._emitCodePoint(cp);
  }
};
_$3[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE] = function scriptDataEscapedDashDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS)
    this._emitChar("-");
  else if (cp === $$9.LESS_THAN_SIGN)
    this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = SCRIPT_DATA_STATE;
    this._emitChar(">");
  } else if (cp === $$9.NULL) {
    this.state = SCRIPT_DATA_ESCAPED_STATE;
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else {
    this.state = SCRIPT_DATA_ESCAPED_STATE;
    this._emitCodePoint(cp);
  }
};
_$3[SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE] = function scriptDataEscapedLessThanSignState(cp) {
  if (cp === $$9.SOLIDUS) {
    this.tempBuff = [];
    this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
  } else if (isAsciiLetter(cp)) {
    this.tempBuff = [];
    this._emitChar("<");
    this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
  } else {
    this._emitChar("<");
    this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
  }
};
_$3[SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE] = function scriptDataEscapedEndTagOpenState(cp) {
  if (isAsciiLetter(cp)) {
    this._createEndTagToken();
    this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
  } else {
    this._emitChar("<");
    this._emitChar("/");
    this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
  }
};
_$3[SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE] = function scriptDataEscapedEndTagNameState(cp) {
  if (isAsciiUpper(cp)) {
    this.currentToken.tagName += toAsciiLowerChar(cp);
    this.tempBuff.push(cp);
  } else if (isAsciiLower(cp)) {
    this.currentToken.tagName += toChar(cp);
    this.tempBuff.push(cp);
  } else {
    if (this._isAppropriateEndTagToken()) {
      if (isWhitespace$1(cp)) {
        this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        return;
      }
      if (cp === $$9.SOLIDUS) {
        this.state = SELF_CLOSING_START_TAG_STATE;
        return;
      }
      if (cp === $$9.GREATER_THAN_SIGN) {
        this._emitCurrentToken();
        this.state = DATA_STATE;
        return;
      }
    }
    this._emitChar("<");
    this._emitChar("/");
    this._emitSeveralCodePoints(this.tempBuff);
    this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
  }
};
_$3[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE] = function scriptDataDoubleEscapeStartState(cp) {
  if (isWhitespace$1(cp) || cp === $$9.SOLIDUS || cp === $$9.GREATER_THAN_SIGN) {
    this.state = this.isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
    this._emitCodePoint(cp);
  } else if (isAsciiUpper(cp)) {
    this.tempBuff.push(toAsciiLowerCodePoint(cp));
    this._emitCodePoint(cp);
  } else if (isAsciiLower(cp)) {
    this.tempBuff.push(cp);
    this._emitCodePoint(cp);
  } else
    this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
};
_$3[SCRIPT_DATA_DOUBLE_ESCAPED_STATE] = function scriptDataDoubleEscapedState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
    this._emitChar("-");
  } else if (cp === $$9.LESS_THAN_SIGN) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
    this._emitChar("<");
  } else if (cp === $$9.NULL)
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this._emitCodePoint(cp);
};
_$3[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE] = function scriptDataDoubleEscapedDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
    this._emitChar("-");
  } else if (cp === $$9.LESS_THAN_SIGN) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
    this._emitChar("<");
  } else if (cp === $$9.NULL) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
    this._emitCodePoint(cp);
  }
};
_$3[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE] = function scriptDataDoubleEscapedDashDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS)
    this._emitChar("-");
  else if (cp === $$9.LESS_THAN_SIGN) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
    this._emitChar("<");
  } else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = SCRIPT_DATA_STATE;
    this._emitChar(">");
  } else if (cp === $$9.NULL) {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
    this._emitChar(UNICODE$3.REPLACEMENT_CHARACTER);
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else {
    this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
    this._emitCodePoint(cp);
  }
};
_$3[SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE] = function scriptDataDoubleEscapedLessThanSignState(cp) {
  if (cp === $$9.SOLIDUS) {
    this.tempBuff = [];
    this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
    this._emitChar("/");
  } else
    this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
};
_$3[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE] = function scriptDataDoubleEscapeEndState(cp) {
  if (isWhitespace$1(cp) || cp === $$9.SOLIDUS || cp === $$9.GREATER_THAN_SIGN) {
    this.state = this.isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
    this._emitCodePoint(cp);
  } else if (isAsciiUpper(cp)) {
    this.tempBuff.push(toAsciiLowerCodePoint(cp));
    this._emitCodePoint(cp);
  } else if (isAsciiLower(cp)) {
    this.tempBuff.push(cp);
    this._emitCodePoint(cp);
  } else
    this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
};
_$3[BEFORE_ATTRIBUTE_NAME_STATE] = function beforeAttributeNameState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.SOLIDUS || cp === $$9.GREATER_THAN_SIGN || cp === $$9.EOF)
    this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
  else if (cp === $$9.EQUALS_SIGN) {
    this._createAttr("=");
    this.state = ATTRIBUTE_NAME_STATE;
  } else {
    this._createAttr("");
    this._reconsumeInState(ATTRIBUTE_NAME_STATE);
  }
};
_$3[ATTRIBUTE_NAME_STATE] = function attributeNameState(cp) {
  if (isWhitespace$1(cp) || cp === $$9.SOLIDUS || cp === $$9.GREATER_THAN_SIGN || cp === $$9.EOF) {
    this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
    this._unconsume();
  } else if (cp === $$9.EQUALS_SIGN)
    this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
  else if (isAsciiUpper(cp))
    this.currentAttr.name += toAsciiLowerChar(cp);
  else if (cp === $$9.QUOTATION_MARK || cp === $$9.APOSTROPHE || cp === $$9.LESS_THAN_SIGN)
    this.currentAttr.name += toChar(cp);
  else if (cp === $$9.NULL)
    this.currentAttr.name += UNICODE$3.REPLACEMENT_CHARACTER;
  else
    this.currentAttr.name += toChar(cp);
};
_$3[AFTER_ATTRIBUTE_NAME_STATE] = function afterAttributeNameState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.SOLIDUS)
    this.state = SELF_CLOSING_START_TAG_STATE;
  else if (cp === $$9.EQUALS_SIGN)
    this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else {
    this._createAttr("");
    this._reconsumeInState(ATTRIBUTE_NAME_STATE);
  }
};
_$3[BEFORE_ATTRIBUTE_VALUE_STATE] = function beforeAttributeValueState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.QUOTATION_MARK)
    this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
  else if (cp === $$9.APOSTROPHE)
    this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
  else
    this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
};
_$3[ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE] = function attributeValueDoubleQuotedState(cp) {
  if (cp === $$9.QUOTATION_MARK)
    this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
  else if (cp === $$9.AMPERSAND) {
    this.additionalAllowedCp = $$9.QUOTATION_MARK;
    this.returnState = this.state;
    this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
  } else if (cp === $$9.NULL)
    this.currentAttr.value += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this.currentAttr.value += toChar(cp);
};
_$3[ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE] = function attributeValueSingleQuotedState(cp) {
  if (cp === $$9.APOSTROPHE)
    this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
  else if (cp === $$9.AMPERSAND) {
    this.additionalAllowedCp = $$9.APOSTROPHE;
    this.returnState = this.state;
    this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
  } else if (cp === $$9.NULL)
    this.currentAttr.value += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this.currentAttr.value += toChar(cp);
};
_$3[ATTRIBUTE_VALUE_UNQUOTED_STATE] = function attributeValueUnquotedState(cp) {
  if (isWhitespace$1(cp))
    this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
  else if (cp === $$9.AMPERSAND) {
    this.additionalAllowedCp = $$9.GREATER_THAN_SIGN;
    this.returnState = this.state;
    this.state = CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE;
  } else if (cp === $$9.GREATER_THAN_SIGN) {
    this._leaveAttrValue(DATA_STATE);
    this._emitCurrentToken();
  } else if (cp === $$9.NULL)
    this.currentAttr.value += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.QUOTATION_MARK || cp === $$9.APOSTROPHE || cp === $$9.LESS_THAN_SIGN || cp === $$9.EQUALS_SIGN || cp === $$9.GRAVE_ACCENT)
    this.currentAttr.value += toChar(cp);
  else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this.currentAttr.value += toChar(cp);
};
_$3[CHARACTER_REFERENCE_IN_ATTRIBUTE_VALUE_STATE] = function characterReferenceInAttributeValueState(cp) {
  var referencedCodePoints = this._consumeCharacterReference(cp, true);
  if (!this._ensureHibernation()) {
    if (referencedCodePoints) {
      for (var i2 = 0; i2 < referencedCodePoints.length; i2++)
        this.currentAttr.value += toChar(referencedCodePoints[i2]);
    } else
      this.currentAttr.value += "&";
    this.state = this.returnState;
  }
};
_$3[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE] = function afterAttributeValueQuotedState(cp) {
  if (isWhitespace$1(cp))
    this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
  else if (cp === $$9.SOLIDUS)
    this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this._leaveAttrValue(DATA_STATE);
    this._emitCurrentToken();
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
};
_$3[SELF_CLOSING_START_TAG_STATE] = function selfClosingStartTagState(cp) {
  if (cp === $$9.GREATER_THAN_SIGN) {
    this.currentToken.selfClosing = true;
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (cp === $$9.EOF)
    this._reconsumeInState(DATA_STATE);
  else
    this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
};
_$3[BOGUS_COMMENT_STATE] = function bogusCommentState() {
  this._createCommentToken();
  this._reconsumeInState(BOGUS_COMMENT_STATE_CONTINUATION);
};
_$3[BOGUS_COMMENT_STATE_CONTINUATION] = function bogusCommentStateContinuation(cp) {
  while (true) {
    if (cp === $$9.GREATER_THAN_SIGN) {
      this.state = DATA_STATE;
      break;
    } else if (cp === $$9.EOF) {
      this._reconsumeInState(DATA_STATE);
      break;
    } else {
      this.currentToken.data += cp === $$9.NULL ? UNICODE$3.REPLACEMENT_CHARACTER : toChar(cp);
      this._hibernationSnapshot();
      cp = this._consume();
      if (this._ensureHibernation())
        return;
    }
  }
  this._emitCurrentToken();
};
_$3[MARKUP_DECLARATION_OPEN_STATE] = function markupDeclarationOpenState(cp) {
  var dashDashMatch = this._consumeSubsequentIfMatch($$.DASH_DASH_STRING, cp, true), doctypeMatch = !dashDashMatch && this._consumeSubsequentIfMatch($$.DOCTYPE_STRING, cp, false), cdataMatch = !dashDashMatch && !doctypeMatch && this.allowCDATA && this._consumeSubsequentIfMatch($$.CDATA_START_STRING, cp, true);
  if (!this._ensureHibernation()) {
    if (dashDashMatch) {
      this._createCommentToken();
      this.state = COMMENT_START_STATE;
    } else if (doctypeMatch)
      this.state = DOCTYPE_STATE;
    else if (cdataMatch)
      this.state = CDATA_SECTION_STATE;
    else
      this._reconsumeInState(BOGUS_COMMENT_STATE);
  }
};
_$3[COMMENT_START_STATE] = function commentStartState(cp) {
  if (cp === $$9.HYPHEN_MINUS)
    this.state = COMMENT_START_DASH_STATE;
  else if (cp === $$9.NULL) {
    this.currentToken.data += UNICODE$3.REPLACEMENT_CHARACTER;
    this.state = COMMENT_STATE;
  } else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (cp === $$9.EOF) {
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else {
    this.currentToken.data += toChar(cp);
    this.state = COMMENT_STATE;
  }
};
_$3[COMMENT_START_DASH_STATE] = function commentStartDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS)
    this.state = COMMENT_END_STATE;
  else if (cp === $$9.NULL) {
    this.currentToken.data += "-";
    this.currentToken.data += UNICODE$3.REPLACEMENT_CHARACTER;
    this.state = COMMENT_STATE;
  } else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (cp === $$9.EOF) {
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else {
    this.currentToken.data += "-";
    this.currentToken.data += toChar(cp);
    this.state = COMMENT_STATE;
  }
};
_$3[COMMENT_STATE] = function commentState(cp) {
  if (cp === $$9.HYPHEN_MINUS)
    this.state = COMMENT_END_DASH_STATE;
  else if (cp === $$9.NULL)
    this.currentToken.data += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.EOF) {
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else
    this.currentToken.data += toChar(cp);
};
_$3[COMMENT_END_DASH_STATE] = function commentEndDashState(cp) {
  if (cp === $$9.HYPHEN_MINUS)
    this.state = COMMENT_END_STATE;
  else if (cp === $$9.NULL) {
    this.currentToken.data += "-";
    this.currentToken.data += UNICODE$3.REPLACEMENT_CHARACTER;
    this.state = COMMENT_STATE;
  } else if (cp === $$9.EOF) {
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else {
    this.currentToken.data += "-";
    this.currentToken.data += toChar(cp);
    this.state = COMMENT_STATE;
  }
};
_$3[COMMENT_END_STATE] = function commentEndState(cp) {
  if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (cp === $$9.EXCLAMATION_MARK)
    this.state = COMMENT_END_BANG_STATE;
  else if (cp === $$9.HYPHEN_MINUS)
    this.currentToken.data += "-";
  else if (cp === $$9.NULL) {
    this.currentToken.data += "--";
    this.currentToken.data += UNICODE$3.REPLACEMENT_CHARACTER;
    this.state = COMMENT_STATE;
  } else if (cp === $$9.EOF) {
    this._reconsumeInState(DATA_STATE);
    this._emitCurrentToken();
  } else {
    this.currentToken.data += "--";
    this.currentToken.data += toChar(cp);
    this.state = COMMENT_STATE;
  }
};
_$3[COMMENT_END_BANG_STATE] = function commentEndBangState(cp) {
  if (cp === $$9.HYPHEN_MINUS) {
    this.currentToken.data += "--!";
    this.state = COMMENT_END_DASH_STATE;
  } else if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else if (cp === $$9.NULL) {
    this.currentToken.data += "--!";
    this.currentToken.data += UNICODE$3.REPLACEMENT_CHARACTER;
    this.state = COMMENT_STATE;
  } else if (cp === $$9.EOF) {
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else {
    this.currentToken.data += "--!";
    this.currentToken.data += toChar(cp);
    this.state = COMMENT_STATE;
  }
};
_$3[DOCTYPE_STATE] = function doctypeState(cp) {
  if (isWhitespace$1(cp))
    return;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this._createDoctypeToken(null);
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.EOF) {
    this._createDoctypeToken(null);
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else {
    this._createDoctypeToken("");
    this._reconsumeInState(DOCTYPE_NAME_STATE);
  }
};
_$3[DOCTYPE_NAME_STATE] = function doctypeNameState(cp) {
  if (isWhitespace$1(cp) || cp === $$9.GREATER_THAN_SIGN || cp === $$9.EOF)
    this._reconsumeInState(AFTER_DOCTYPE_NAME_STATE);
  else if (isAsciiUpper(cp))
    this.currentToken.name += toAsciiLowerChar(cp);
  else if (cp === $$9.NULL)
    this.currentToken.name += UNICODE$3.REPLACEMENT_CHARACTER;
  else
    this.currentToken.name += toChar(cp);
};
_$3[AFTER_DOCTYPE_NAME_STATE] = function afterDoctypeNameState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.GREATER_THAN_SIGN) {
    this.state = DATA_STATE;
    this._emitCurrentToken();
  } else {
    var publicMatch = this._consumeSubsequentIfMatch($$.PUBLIC_STRING, cp, false), systemMatch = !publicMatch && this._consumeSubsequentIfMatch($$.SYSTEM_STRING, cp, false);
    if (!this._ensureHibernation()) {
      if (publicMatch)
        this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
      else if (systemMatch)
        this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
      else {
        this.currentToken.forceQuirks = true;
        this.state = BOGUS_DOCTYPE_STATE;
      }
    }
  }
};
_$3[BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE] = function beforeDoctypePublicIdentifierState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.QUOTATION_MARK) {
    this.currentToken.publicId = "";
    this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
  } else if (cp === $$9.APOSTROPHE) {
    this.currentToken.publicId = "";
    this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
  } else {
    this.currentToken.forceQuirks = true;
    this._reconsumeInState(BOGUS_DOCTYPE_STATE);
  }
};
_$3[DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE] = function doctypePublicIdentifierDoubleQuotedState(cp) {
  if (cp === $$9.QUOTATION_MARK)
    this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
  else if (cp === $$9.NULL)
    this.currentToken.publicId += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.EOF) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else
    this.currentToken.publicId += toChar(cp);
};
_$3[DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE] = function doctypePublicIdentifierSingleQuotedState(cp) {
  if (cp === $$9.APOSTROPHE)
    this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
  else if (cp === $$9.NULL)
    this.currentToken.publicId += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.EOF) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else
    this.currentToken.publicId += toChar(cp);
};
_$3[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE] = function betweenDoctypePublicAndSystemIdentifiersState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.GREATER_THAN_SIGN) {
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.QUOTATION_MARK) {
    this.currentToken.systemId = "";
    this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
  } else if (cp === $$9.APOSTROPHE) {
    this.currentToken.systemId = "";
    this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
  } else {
    this.currentToken.forceQuirks = true;
    this._reconsumeInState(BOGUS_DOCTYPE_STATE);
  }
};
_$3[BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE] = function beforeDoctypeSystemIdentifierState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.QUOTATION_MARK) {
    this.currentToken.systemId = "";
    this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
  } else if (cp === $$9.APOSTROPHE) {
    this.currentToken.systemId = "";
    this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
  } else {
    this.currentToken.forceQuirks = true;
    this._reconsumeInState(BOGUS_DOCTYPE_STATE);
  }
};
_$3[DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE] = function doctypeSystemIdentifierDoubleQuotedState(cp) {
  if (cp === $$9.QUOTATION_MARK)
    this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.NULL)
    this.currentToken.systemId += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.EOF) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else
    this.currentToken.systemId += toChar(cp);
};
_$3[DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE] = function doctypeSystemIdentifierSingleQuotedState(cp) {
  if (cp === $$9.APOSTROPHE)
    this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
  else if (cp === $$9.GREATER_THAN_SIGN) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.NULL)
    this.currentToken.systemId += UNICODE$3.REPLACEMENT_CHARACTER;
  else if (cp === $$9.EOF) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else
    this.currentToken.systemId += toChar(cp);
};
_$3[AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE] = function afterDoctypeSystemIdentifierState(cp) {
  if (isWhitespace$1(cp))
    return;
  if (cp === $$9.GREATER_THAN_SIGN) {
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.EOF) {
    this.currentToken.forceQuirks = true;
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  } else
    this.state = BOGUS_DOCTYPE_STATE;
};
_$3[BOGUS_DOCTYPE_STATE] = function bogusDoctypeState(cp) {
  if (cp === $$9.GREATER_THAN_SIGN) {
    this._emitCurrentToken();
    this.state = DATA_STATE;
  } else if (cp === $$9.EOF) {
    this._emitCurrentToken();
    this._reconsumeInState(DATA_STATE);
  }
};
_$3[CDATA_SECTION_STATE] = function cdataSectionState(cp) {
  while (true) {
    if (cp === $$9.EOF) {
      this._reconsumeInState(DATA_STATE);
      break;
    } else {
      var cdataEndMatch = this._consumeSubsequentIfMatch($$.CDATA_END_STRING, cp, true);
      if (this._ensureHibernation())
        break;
      if (cdataEndMatch) {
        this.state = DATA_STATE;
        break;
      }
      this._emitCodePoint(cp);
      this._hibernationSnapshot();
      cp = this._consume();
      if (this._ensureHibernation())
        break;
    }
  }
};
var open_element_stackExports = {};
var open_element_stack = {
  get exports() {
    return open_element_stackExports;
  },
  set exports(v) {
    open_element_stackExports = v;
  }
};
var html = {};
var NS$5 = html.NAMESPACES = {
  HTML: "http://www.w3.org/1999/xhtml",
  MATHML: "http://www.w3.org/1998/Math/MathML",
  SVG: "http://www.w3.org/2000/svg",
  XLINK: "http://www.w3.org/1999/xlink",
  XML: "http://www.w3.org/XML/1998/namespace",
  XMLNS: "http://www.w3.org/2000/xmlns/"
};
html.ATTRS = {
  TYPE: "type",
  ACTION: "action",
  ENCODING: "encoding",
  PROMPT: "prompt",
  NAME: "name",
  COLOR: "color",
  FACE: "face",
  SIZE: "size"
};
html.DOCUMENT_MODE = {
  NO_QUIRKS: "no-quirks",
  QUIRKS: "quirks",
  LIMITED_QUIRKS: "limited-quirks"
};
var $$8 = html.TAG_NAMES = {
  A: "a",
  ADDRESS: "address",
  ANNOTATION_XML: "annotation-xml",
  APPLET: "applet",
  AREA: "area",
  ARTICLE: "article",
  ASIDE: "aside",
  B: "b",
  BASE: "base",
  BASEFONT: "basefont",
  BGSOUND: "bgsound",
  BIG: "big",
  BLOCKQUOTE: "blockquote",
  BODY: "body",
  BR: "br",
  BUTTON: "button",
  CAPTION: "caption",
  CENTER: "center",
  CODE: "code",
  COL: "col",
  COLGROUP: "colgroup",
  DD: "dd",
  DESC: "desc",
  DETAILS: "details",
  DIALOG: "dialog",
  DIR: "dir",
  DIV: "div",
  DL: "dl",
  DT: "dt",
  EM: "em",
  EMBED: "embed",
  FIELDSET: "fieldset",
  FIGCAPTION: "figcaption",
  FIGURE: "figure",
  FONT: "font",
  FOOTER: "footer",
  FOREIGN_OBJECT: "foreignObject",
  FORM: "form",
  FRAME: "frame",
  FRAMESET: "frameset",
  H1: "h1",
  H2: "h2",
  H3: "h3",
  H4: "h4",
  H5: "h5",
  H6: "h6",
  HEAD: "head",
  HEADER: "header",
  HGROUP: "hgroup",
  HR: "hr",
  HTML: "html",
  I: "i",
  IMG: "img",
  IMAGE: "image",
  INPUT: "input",
  IFRAME: "iframe",
  KEYGEN: "keygen",
  LABEL: "label",
  LI: "li",
  LINK: "link",
  LISTING: "listing",
  MAIN: "main",
  MALIGNMARK: "malignmark",
  MARQUEE: "marquee",
  MATH: "math",
  MENU: "menu",
  MENUITEM: "menuitem",
  META: "meta",
  MGLYPH: "mglyph",
  MI: "mi",
  MO: "mo",
  MN: "mn",
  MS: "ms",
  MTEXT: "mtext",
  NAV: "nav",
  NOBR: "nobr",
  NOFRAMES: "noframes",
  NOEMBED: "noembed",
  NOSCRIPT: "noscript",
  OBJECT: "object",
  OL: "ol",
  OPTGROUP: "optgroup",
  OPTION: "option",
  P: "p",
  PARAM: "param",
  PLAINTEXT: "plaintext",
  PRE: "pre",
  RB: "rb",
  RP: "rp",
  RT: "rt",
  RTC: "rtc",
  RUBY: "ruby",
  S: "s",
  SCRIPT: "script",
  SECTION: "section",
  SELECT: "select",
  SOURCE: "source",
  SMALL: "small",
  SPAN: "span",
  STRIKE: "strike",
  STRONG: "strong",
  STYLE: "style",
  SUB: "sub",
  SUMMARY: "summary",
  SUP: "sup",
  TABLE: "table",
  TBODY: "tbody",
  TEMPLATE: "template",
  TEXTAREA: "textarea",
  TFOOT: "tfoot",
  TD: "td",
  TH: "th",
  THEAD: "thead",
  TITLE: "title",
  TR: "tr",
  TRACK: "track",
  TT: "tt",
  U: "u",
  UL: "ul",
  SVG: "svg",
  VAR: "var",
  WBR: "wbr",
  XMP: "xmp"
};
var SPECIAL_ELEMENTS = html.SPECIAL_ELEMENTS = /* @__PURE__ */ Object.create(null);
SPECIAL_ELEMENTS[NS$5.HTML] = /* @__PURE__ */ Object.create(null);
SPECIAL_ELEMENTS[NS$5.HTML][$$8.ADDRESS] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.APPLET] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.AREA] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.ARTICLE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.ASIDE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BASE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BASEFONT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BGSOUND] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BLOCKQUOTE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BODY] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BR] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.BUTTON] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.CAPTION] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.CENTER] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.COL] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.COLGROUP] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.DD] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.DETAILS] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.DIR] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.DIV] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.DL] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.DT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.EMBED] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FIELDSET] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FIGCAPTION] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FIGURE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FOOTER] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FORM] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FRAME] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.FRAMESET] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.H1] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.H2] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.H3] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.H4] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.H5] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.H6] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.HEAD] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.HEADER] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.HGROUP] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.HR] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.HTML] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.IFRAME] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.IMG] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.INPUT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.LI] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.LINK] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.LISTING] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.MAIN] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.MARQUEE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.MENU] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.META] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.NAV] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.NOEMBED] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.NOFRAMES] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.NOSCRIPT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.OBJECT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.OL] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.P] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.PARAM] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.PLAINTEXT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.PRE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.SCRIPT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.SECTION] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.SELECT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.SOURCE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.STYLE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.SUMMARY] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TABLE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TBODY] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TD] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TEMPLATE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TEXTAREA] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TFOOT] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TH] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.THEAD] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TITLE] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TR] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.TRACK] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.UL] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.WBR] = true;
SPECIAL_ELEMENTS[NS$5.HTML][$$8.XMP] = true;
SPECIAL_ELEMENTS[NS$5.MATHML] = /* @__PURE__ */ Object.create(null);
SPECIAL_ELEMENTS[NS$5.MATHML][$$8.MI] = true;
SPECIAL_ELEMENTS[NS$5.MATHML][$$8.MO] = true;
SPECIAL_ELEMENTS[NS$5.MATHML][$$8.MN] = true;
SPECIAL_ELEMENTS[NS$5.MATHML][$$8.MS] = true;
SPECIAL_ELEMENTS[NS$5.MATHML][$$8.MTEXT] = true;
SPECIAL_ELEMENTS[NS$5.MATHML][$$8.ANNOTATION_XML] = true;
SPECIAL_ELEMENTS[NS$5.SVG] = /* @__PURE__ */ Object.create(null);
SPECIAL_ELEMENTS[NS$5.SVG][$$8.TITLE] = true;
SPECIAL_ELEMENTS[NS$5.SVG][$$8.FOREIGN_OBJECT] = true;
SPECIAL_ELEMENTS[NS$5.SVG][$$8.DESC] = true;
var HTML$5 = html;
var $$7 = HTML$5.TAG_NAMES, NS$4 = HTML$5.NAMESPACES;
function isImpliedEndTagRequired(tn) {
  switch (tn.length) {
    case 1:
      return tn === $$7.P;
    case 2:
      return tn === $$7.RB || tn === $$7.RP || tn === $$7.RT || tn === $$7.DD || tn === $$7.DT || tn === $$7.LI;
    case 3:
      return tn === $$7.RTC;
    case 6:
      return tn === $$7.OPTION;
    case 8:
      return tn === $$7.OPTGROUP || tn === $$7.MENUITEM;
  }
  return false;
}
function isScopingElement(tn, ns) {
  switch (tn.length) {
    case 2:
      if (tn === $$7.TD || tn === $$7.TH)
        return ns === NS$4.HTML;
      else if (tn === $$7.MI || tn === $$7.MO || tn === $$7.MN || tn === $$7.MS)
        return ns === NS$4.MATHML;
      break;
    case 4:
      if (tn === $$7.HTML)
        return ns === NS$4.HTML;
      else if (tn === $$7.DESC)
        return ns === NS$4.SVG;
      break;
    case 5:
      if (tn === $$7.TABLE)
        return ns === NS$4.HTML;
      else if (tn === $$7.MTEXT)
        return ns === NS$4.MATHML;
      else if (tn === $$7.TITLE)
        return ns === NS$4.SVG;
      break;
    case 6:
      return (tn === $$7.APPLET || tn === $$7.OBJECT) && ns === NS$4.HTML;
    case 7:
      return (tn === $$7.CAPTION || tn === $$7.MARQUEE) && ns === NS$4.HTML;
    case 8:
      return tn === $$7.TEMPLATE && ns === NS$4.HTML;
    case 13:
      return tn === $$7.FOREIGN_OBJECT && ns === NS$4.SVG;
    case 14:
      return tn === $$7.ANNOTATION_XML && ns === NS$4.MATHML;
  }
  return false;
}
var OpenElementStack$1 = open_element_stack.exports = function(document, treeAdapter) {
  this.stackTop = -1;
  this.items = [];
  this.current = document;
  this.currentTagName = null;
  this.currentTmplContent = null;
  this.tmplCount = 0;
  this.treeAdapter = treeAdapter;
};
OpenElementStack$1.prototype._indexOf = function(element2) {
  var idx = -1;
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    if (this.items[i2] === element2) {
      idx = i2;
      break;
    }
  }
  return idx;
};
OpenElementStack$1.prototype._isInTemplate = function() {
  return this.currentTagName === $$7.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$4.HTML;
};
OpenElementStack$1.prototype._updateCurrentElement = function() {
  this.current = this.items[this.stackTop];
  this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
  this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
};
OpenElementStack$1.prototype.push = function(element2) {
  this.items[++this.stackTop] = element2;
  this._updateCurrentElement();
  if (this._isInTemplate())
    this.tmplCount++;
};
OpenElementStack$1.prototype.pop = function() {
  this.stackTop--;
  if (this.tmplCount > 0 && this._isInTemplate())
    this.tmplCount--;
  this._updateCurrentElement();
};
OpenElementStack$1.prototype.replace = function(oldElement, newElement) {
  var idx = this._indexOf(oldElement);
  this.items[idx] = newElement;
  if (idx === this.stackTop)
    this._updateCurrentElement();
};
OpenElementStack$1.prototype.insertAfter = function(referenceElement, newElement) {
  var insertionIdx = this._indexOf(referenceElement) + 1;
  this.items.splice(insertionIdx, 0, newElement);
  if (insertionIdx === ++this.stackTop)
    this._updateCurrentElement();
};
OpenElementStack$1.prototype.popUntilTagNamePopped = function(tagName) {
  while (this.stackTop > -1) {
    var tn = this.currentTagName, ns = this.treeAdapter.getNamespaceURI(this.current);
    this.pop();
    if (tn === tagName && ns === NS$4.HTML)
      break;
  }
};
OpenElementStack$1.prototype.popUntilElementPopped = function(element2) {
  while (this.stackTop > -1) {
    var poppedElement = this.current;
    this.pop();
    if (poppedElement === element2)
      break;
  }
};
OpenElementStack$1.prototype.popUntilNumberedHeaderPopped = function() {
  while (this.stackTop > -1) {
    var tn = this.currentTagName, ns = this.treeAdapter.getNamespaceURI(this.current);
    this.pop();
    if (tn === $$7.H1 || tn === $$7.H2 || tn === $$7.H3 || tn === $$7.H4 || tn === $$7.H5 || tn === $$7.H6 && ns === NS$4.HTML)
      break;
  }
};
OpenElementStack$1.prototype.popUntilTableCellPopped = function() {
  while (this.stackTop > -1) {
    var tn = this.currentTagName, ns = this.treeAdapter.getNamespaceURI(this.current);
    this.pop();
    if (tn === $$7.TD || tn === $$7.TH && ns === NS$4.HTML)
      break;
  }
};
OpenElementStack$1.prototype.popAllUpToHtmlElement = function() {
  this.stackTop = 0;
  this._updateCurrentElement();
};
OpenElementStack$1.prototype.clearBackToTableContext = function() {
  while (this.currentTagName !== $$7.TABLE && this.currentTagName !== $$7.TEMPLATE && this.currentTagName !== $$7.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$4.HTML)
    this.pop();
};
OpenElementStack$1.prototype.clearBackToTableBodyContext = function() {
  while (this.currentTagName !== $$7.TBODY && this.currentTagName !== $$7.TFOOT && this.currentTagName !== $$7.THEAD && this.currentTagName !== $$7.TEMPLATE && this.currentTagName !== $$7.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$4.HTML)
    this.pop();
};
OpenElementStack$1.prototype.clearBackToTableRowContext = function() {
  while (this.currentTagName !== $$7.TR && this.currentTagName !== $$7.TEMPLATE && this.currentTagName !== $$7.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$4.HTML)
    this.pop();
};
OpenElementStack$1.prototype.remove = function(element2) {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    if (this.items[i2] === element2) {
      this.items.splice(i2, 1);
      this.stackTop--;
      this._updateCurrentElement();
      break;
    }
  }
};
OpenElementStack$1.prototype.tryPeekProperlyNestedBodyElement = function() {
  var element2 = this.items[1];
  return element2 && this.treeAdapter.getTagName(element2) === $$7.BODY ? element2 : null;
};
OpenElementStack$1.prototype.contains = function(element2) {
  return this._indexOf(element2) > -1;
};
OpenElementStack$1.prototype.getCommonAncestor = function(element2) {
  var elementIdx = this._indexOf(element2);
  return --elementIdx >= 0 ? this.items[elementIdx] : null;
};
OpenElementStack$1.prototype.isRootHtmlElementCurrent = function() {
  return this.stackTop === 0 && this.currentTagName === $$7.HTML;
};
OpenElementStack$1.prototype.hasInScope = function(tagName) {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if (tn === tagName && ns === NS$4.HTML)
      return true;
    if (isScopingElement(tn, ns))
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.hasNumberedHeaderInScope = function() {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if ((tn === $$7.H1 || tn === $$7.H2 || tn === $$7.H3 || tn === $$7.H4 || tn === $$7.H5 || tn === $$7.H6) && ns === NS$4.HTML)
      return true;
    if (isScopingElement(tn, ns))
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.hasInListItemScope = function(tagName) {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if (tn === tagName && ns === NS$4.HTML)
      return true;
    if ((tn === $$7.UL || tn === $$7.OL) && ns === NS$4.HTML || isScopingElement(tn, ns))
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.hasInButtonScope = function(tagName) {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if (tn === tagName && ns === NS$4.HTML)
      return true;
    if (tn === $$7.BUTTON && ns === NS$4.HTML || isScopingElement(tn, ns))
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.hasInTableScope = function(tagName) {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if (ns !== NS$4.HTML)
      continue;
    if (tn === tagName)
      return true;
    if (tn === $$7.TABLE || tn === $$7.TEMPLATE || tn === $$7.HTML)
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.hasTableBodyContextInTableScope = function() {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if (ns !== NS$4.HTML)
      continue;
    if (tn === $$7.TBODY || tn === $$7.THEAD || tn === $$7.TFOOT)
      return true;
    if (tn === $$7.TABLE || tn === $$7.HTML)
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.hasInSelectScope = function(tagName) {
  for (var i2 = this.stackTop; i2 >= 0; i2--) {
    var tn = this.treeAdapter.getTagName(this.items[i2]), ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
    if (ns !== NS$4.HTML)
      continue;
    if (tn === tagName)
      return true;
    if (tn !== $$7.OPTION && tn !== $$7.OPTGROUP)
      return false;
  }
  return true;
};
OpenElementStack$1.prototype.generateImpliedEndTags = function() {
  while (isImpliedEndTagRequired(this.currentTagName))
    this.pop();
};
OpenElementStack$1.prototype.generateImpliedEndTagsWithExclusion = function(exclusionTagName) {
  while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName)
    this.pop();
};
var formatting_element_listExports = {};
var formatting_element_list = {
  get exports() {
    return formatting_element_listExports;
  },
  set exports(v) {
    formatting_element_listExports = v;
  }
};
var NOAH_ARK_CAPACITY = 3;
var FormattingElementList$1 = formatting_element_list.exports = function(treeAdapter) {
  this.length = 0;
  this.entries = [];
  this.treeAdapter = treeAdapter;
  this.bookmark = null;
};
FormattingElementList$1.MARKER_ENTRY = "MARKER_ENTRY";
FormattingElementList$1.ELEMENT_ENTRY = "ELEMENT_ENTRY";
FormattingElementList$1.prototype._getNoahArkConditionCandidates = function(newElement) {
  var candidates = [];
  if (this.length >= NOAH_ARK_CAPACITY) {
    var neAttrsLength = this.treeAdapter.getAttrList(newElement).length, neTagName = this.treeAdapter.getTagName(newElement), neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
    for (var i2 = this.length - 1; i2 >= 0; i2--) {
      var entry = this.entries[i2];
      if (entry.type === FormattingElementList$1.MARKER_ENTRY)
        break;
      var element2 = entry.element, elementAttrs = this.treeAdapter.getAttrList(element2), isCandidate = this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI && elementAttrs.length === neAttrsLength;
      if (isCandidate)
        candidates.push({ idx: i2, attrs: elementAttrs });
    }
  }
  return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
};
FormattingElementList$1.prototype._ensureNoahArkCondition = function(newElement) {
  var candidates = this._getNoahArkConditionCandidates(newElement), cLength = candidates.length;
  if (cLength) {
    var neAttrs = this.treeAdapter.getAttrList(newElement), neAttrsLength = neAttrs.length, neAttrsMap = /* @__PURE__ */ Object.create(null);
    for (var i2 = 0; i2 < neAttrsLength; i2++) {
      var neAttr = neAttrs[i2];
      neAttrsMap[neAttr.name] = neAttr.value;
    }
    for (i2 = 0; i2 < neAttrsLength; i2++) {
      for (var j2 = 0; j2 < cLength; j2++) {
        var cAttr = candidates[j2].attrs[i2];
        if (neAttrsMap[cAttr.name] !== cAttr.value) {
          candidates.splice(j2, 1);
          cLength--;
        }
        if (candidates.length < NOAH_ARK_CAPACITY)
          return;
      }
    }
    for (i2 = cLength - 1; i2 >= NOAH_ARK_CAPACITY - 1; i2--) {
      this.entries.splice(candidates[i2].idx, 1);
      this.length--;
    }
  }
};
FormattingElementList$1.prototype.insertMarker = function() {
  this.entries.push({ type: FormattingElementList$1.MARKER_ENTRY });
  this.length++;
};
FormattingElementList$1.prototype.pushElement = function(element2, token) {
  this._ensureNoahArkCondition(element2);
  this.entries.push({
    type: FormattingElementList$1.ELEMENT_ENTRY,
    element: element2,
    token
  });
  this.length++;
};
FormattingElementList$1.prototype.insertElementAfterBookmark = function(element2, token) {
  var bookmarkIdx = this.length - 1;
  for (; bookmarkIdx >= 0; bookmarkIdx--) {
    if (this.entries[bookmarkIdx] === this.bookmark)
      break;
  }
  this.entries.splice(bookmarkIdx + 1, 0, {
    type: FormattingElementList$1.ELEMENT_ENTRY,
    element: element2,
    token
  });
  this.length++;
};
FormattingElementList$1.prototype.removeEntry = function(entry) {
  for (var i2 = this.length - 1; i2 >= 0; i2--) {
    if (this.entries[i2] === entry) {
      this.entries.splice(i2, 1);
      this.length--;
      break;
    }
  }
};
FormattingElementList$1.prototype.clearToLastMarker = function() {
  while (this.length) {
    var entry = this.entries.pop();
    this.length--;
    if (entry.type === FormattingElementList$1.MARKER_ENTRY)
      break;
  }
};
FormattingElementList$1.prototype.getElementEntryInScopeWithTagName = function(tagName) {
  for (var i2 = this.length - 1; i2 >= 0; i2--) {
    var entry = this.entries[i2];
    if (entry.type === FormattingElementList$1.MARKER_ENTRY)
      return null;
    if (this.treeAdapter.getTagName(entry.element) === tagName)
      return entry;
  }
  return null;
};
FormattingElementList$1.prototype.getElementEntry = function(element2) {
  for (var i2 = this.length - 1; i2 >= 0; i2--) {
    var entry = this.entries[i2];
    if (entry.type === FormattingElementList$1.ELEMENT_ENTRY && entry.element === element2)
      return entry;
  }
  return null;
};
var parser_mixinExports = {};
var parser_mixin = {
  get exports() {
    return parser_mixinExports;
  },
  set exports(v) {
    parser_mixinExports = v;
  }
};
var mixinExports = {};
var mixin = {
  get exports() {
    return mixinExports;
  },
  set exports(v) {
    mixinExports = v;
  }
};
var Mixin$4 = mixin.exports = function(host) {
  var originalMethods = {}, overriddenMethods = this._getOverriddenMethods(this, originalMethods);
  Object.keys(overriddenMethods).forEach(function(key) {
    if (typeof overriddenMethods[key] === "function") {
      originalMethods[key] = host[key];
      host[key] = overriddenMethods[key];
    }
  });
};
Mixin$4.prototype._getOverriddenMethods = function() {
  throw new Error("Not implemented");
};
var tokenizer_mixinExports = {};
var tokenizer_mixin = {
  get exports() {
    return tokenizer_mixinExports;
  },
  set exports(v) {
    tokenizer_mixinExports = v;
  }
};
var preprocessor_mixinExports = {};
var preprocessor_mixin = {
  get exports() {
    return preprocessor_mixinExports;
  },
  set exports(v) {
    preprocessor_mixinExports = v;
  }
};
var Mixin$3 = mixinExports, inherits$7 = require$$1$3.inherits, UNICODE$2 = unicode;
var $$6 = UNICODE$2.CODE_POINTS;
var PositionTrackingPreprocessorMixin$2 = preprocessor_mixin.exports = function(preprocessor2) {
  if (!preprocessor2.__locTracker) {
    preprocessor2.__locTracker = this;
    Mixin$3.call(this, preprocessor2);
    this.preprocessor = preprocessor2;
    this.isEol = false;
    this.lineStartPos = 0;
    this.droppedBufferSize = 0;
    this.col = -1;
    this.line = 1;
  }
  return preprocessor2.__locTracker;
};
inherits$7(PositionTrackingPreprocessorMixin$2, Mixin$3);
Object.defineProperty(PositionTrackingPreprocessorMixin$2.prototype, "offset", {
  get: function() {
    return this.droppedBufferSize + this.preprocessor.pos;
  }
});
PositionTrackingPreprocessorMixin$2.prototype._getOverriddenMethods = function(mxn, orig) {
  return {
    advance: function() {
      var cp = orig.advance.call(this);
      if (mxn.isEol) {
        mxn.isEol = false;
        mxn.line++;
        mxn.lineStartPos = mxn.offset;
      }
      if (cp === $$6.LINE_FEED)
        mxn.isEol = true;
      mxn.col = mxn.offset - mxn.lineStartPos + 1;
      return cp;
    },
    retreat: function() {
      orig.retreat.call(this);
      mxn.isEol = false;
      mxn.col = mxn.offset - mxn.lineStartPos + 1;
    },
    dropParsedChunk: function() {
      var prevPos = this.pos;
      orig.dropParsedChunk.call(this);
      mxn.droppedBufferSize += prevPos - this.pos;
    }
  };
};
var Mixin$2 = mixinExports, Tokenizer$5 = tokenizerExports, PositionTrackingPreprocessorMixin$1 = preprocessor_mixinExports, inherits$6 = require$$1$3.inherits;
var LocationInfoTokenizerMixin$2 = tokenizer_mixin.exports = function(tokenizer2) {
  Mixin$2.call(this, tokenizer2);
  this.tokenizer = tokenizer2;
  this.posTracker = new PositionTrackingPreprocessorMixin$1(tokenizer2.preprocessor);
  this.currentAttrLocation = null;
  this.currentTokenLocation = null;
};
inherits$6(LocationInfoTokenizerMixin$2, Mixin$2);
LocationInfoTokenizerMixin$2.prototype._getCurrentLocation = function() {
  return {
    line: this.posTracker.line,
    col: this.posTracker.col,
    startOffset: this.posTracker.offset,
    endOffset: -1
  };
};
LocationInfoTokenizerMixin$2.prototype._attachCurrentAttrLocationInfo = function() {
  this.currentAttrLocation.endOffset = this.posTracker.offset;
  var currentToken = this.tokenizer.currentToken, currentAttr = this.tokenizer.currentAttr;
  if (!currentToken.location.attrs)
    currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
  currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
};
LocationInfoTokenizerMixin$2.prototype._getOverriddenMethods = function(mxn, orig) {
  var methods = {
    _createStartTagToken: function() {
      orig._createStartTagToken.call(this);
      this.currentToken.location = mxn.currentTokenLocation;
    },
    _createEndTagToken: function() {
      orig._createEndTagToken.call(this);
      this.currentToken.location = mxn.currentTokenLocation;
    },
    _createCommentToken: function() {
      orig._createCommentToken.call(this);
      this.currentToken.location = mxn.currentTokenLocation;
    },
    _createDoctypeToken: function(initialName) {
      orig._createDoctypeToken.call(this, initialName);
      this.currentToken.location = mxn.currentTokenLocation;
    },
    _createCharacterToken: function(type, ch) {
      orig._createCharacterToken.call(this, type, ch);
      this.currentCharacterToken.location = mxn.currentTokenLocation;
    },
    _createAttr: function(attrNameFirstCh) {
      orig._createAttr.call(this, attrNameFirstCh);
      mxn.currentAttrLocation = mxn._getCurrentLocation();
    },
    _leaveAttrName: function(toState) {
      orig._leaveAttrName.call(this, toState);
      mxn._attachCurrentAttrLocationInfo();
    },
    _leaveAttrValue: function(toState) {
      orig._leaveAttrValue.call(this, toState);
      mxn._attachCurrentAttrLocationInfo();
    },
    _emitCurrentToken: function() {
      if (this.currentCharacterToken)
        this.currentCharacterToken.location.endOffset = this.currentToken.location.startOffset;
      this.currentToken.location.endOffset = mxn.posTracker.offset + 1;
      orig._emitCurrentToken.call(this);
    },
    _emitCurrentCharacterToken: function() {
      if (this.currentCharacterToken && this.currentCharacterToken.location.endOffset === -1)
        this.currentCharacterToken.location.endOffset = mxn.posTracker.offset;
      orig._emitCurrentCharacterToken.call(this);
    }
  };
  Object.keys(Tokenizer$5.MODE).forEach(function(modeName) {
    var state = Tokenizer$5.MODE[modeName];
    methods[state] = function(cp) {
      mxn.currentTokenLocation = mxn._getCurrentLocation();
      orig[state].call(this, cp);
    };
  });
  return methods;
};
var open_element_stack_mixinExports = {};
var open_element_stack_mixin = {
  get exports() {
    return open_element_stack_mixinExports;
  },
  set exports(v) {
    open_element_stack_mixinExports = v;
  }
};
var Mixin$1 = mixinExports, inherits$5 = require$$1$3.inherits;
var LocationInfoOpenElementStackMixin$1 = open_element_stack_mixin.exports = function(stack, options2) {
  Mixin$1.call(this, stack);
  this.onItemPop = options2.onItemPop;
};
inherits$5(LocationInfoOpenElementStackMixin$1, Mixin$1);
LocationInfoOpenElementStackMixin$1.prototype._getOverriddenMethods = function(mxn, orig) {
  return {
    pop: function() {
      mxn.onItemPop(this.current);
      orig.pop.call(this);
    },
    popAllUpToHtmlElement: function() {
      for (var i2 = this.stackTop; i2 > 0; i2--)
        mxn.onItemPop(this.items[i2]);
      orig.popAllUpToHtmlElement.call(this);
    },
    remove: function(element2) {
      mxn.onItemPop(this.current);
      orig.remove.call(this, element2);
    }
  };
};
var Mixin = mixinExports, Tokenizer$4 = tokenizerExports, LocationInfoTokenizerMixin$1 = tokenizer_mixinExports, PositionTrackingPreprocessorMixin = preprocessor_mixinExports, LocationInfoOpenElementStackMixin = open_element_stack_mixinExports, HTML$4 = html, inherits$4 = require$$1$3.inherits;
var $$5 = HTML$4.TAG_NAMES;
var LocationInfoParserMixin$1 = parser_mixin.exports = function(parser2) {
  Mixin.call(this, parser2);
  this.parser = parser2;
  this.posTracker = null;
  this.lastStartTagToken = null;
  this.lastFosterParentingLocation = null;
  this.currentToken = null;
};
inherits$4(LocationInfoParserMixin$1, Mixin);
LocationInfoParserMixin$1.prototype._setStartLocation = function(element2) {
  if (this.lastStartTagToken) {
    element2.__location = Object.create(this.lastStartTagToken.location);
    element2.__location.startTag = this.lastStartTagToken.location;
  } else
    element2.__location = null;
};
LocationInfoParserMixin$1.prototype._setEndLocation = function(element2, closingToken) {
  var loc = element2.__location;
  if (loc) {
    if (closingToken.location) {
      var ctLoc = closingToken.location, tn = this.parser.treeAdapter.getTagName(element2);
      var isClosingEndTag = closingToken.type === Tokenizer$4.END_TAG_TOKEN && tn === closingToken.tagName;
      if (isClosingEndTag) {
        loc.endTag = Object.create(ctLoc);
        loc.endOffset = ctLoc.endOffset;
      } else
        loc.endOffset = ctLoc.startOffset;
    } else if (closingToken.type === Tokenizer$4.EOF_TOKEN)
      loc.endOffset = this.posTracker.offset;
  }
};
LocationInfoParserMixin$1.prototype._getOverriddenMethods = function(mxn, orig) {
  return {
    _bootstrap: function(document, fragmentContext) {
      orig._bootstrap.call(this, document, fragmentContext);
      mxn.lastStartTagToken = null;
      mxn.lastFosterParentingLocation = null;
      mxn.currentToken = null;
      mxn.posTracker = new PositionTrackingPreprocessorMixin(this.tokenizer.preprocessor);
      new LocationInfoTokenizerMixin$1(this.tokenizer);
      new LocationInfoOpenElementStackMixin(this.openElements, {
        onItemPop: function(element2) {
          mxn._setEndLocation(element2, mxn.currentToken);
        }
      });
    },
    _runParsingLoop: function(scriptHandler) {
      orig._runParsingLoop.call(this, scriptHandler);
      for (var i2 = this.openElements.stackTop; i2 >= 0; i2--)
        mxn._setEndLocation(this.openElements.items[i2], mxn.currentToken);
    },
    //Token processing
    _processTokenInForeignContent: function(token) {
      mxn.currentToken = token;
      orig._processTokenInForeignContent.call(this, token);
    },
    _processToken: function(token) {
      mxn.currentToken = token;
      orig._processToken.call(this, token);
      var requireExplicitUpdate = token.type === Tokenizer$4.END_TAG_TOKEN && (token.tagName === $$5.HTML || token.tagName === $$5.BODY && this.openElements.hasInScope($$5.BODY));
      if (requireExplicitUpdate) {
        for (var i2 = this.openElements.stackTop; i2 >= 0; i2--) {
          var element2 = this.openElements.items[i2];
          if (this.treeAdapter.getTagName(element2) === token.tagName) {
            mxn._setEndLocation(element2, token);
            break;
          }
        }
      }
    },
    //Doctype
    _setDocumentType: function(token) {
      orig._setDocumentType.call(this, token);
      var documentChildren = this.treeAdapter.getChildNodes(this.document), cnLength = documentChildren.length;
      for (var i2 = 0; i2 < cnLength; i2++) {
        var node2 = documentChildren[i2];
        if (this.treeAdapter.isDocumentTypeNode(node2)) {
          node2.__location = token.location;
          break;
        }
      }
    },
    //Elements
    _attachElementToTree: function(element2) {
      mxn._setStartLocation(element2);
      mxn.lastStartTagToken = null;
      orig._attachElementToTree.call(this, element2);
    },
    _appendElement: function(token, namespaceURI) {
      mxn.lastStartTagToken = token;
      orig._appendElement.call(this, token, namespaceURI);
    },
    _insertElement: function(token, namespaceURI) {
      mxn.lastStartTagToken = token;
      orig._insertElement.call(this, token, namespaceURI);
    },
    _insertTemplate: function(token) {
      mxn.lastStartTagToken = token;
      orig._insertTemplate.call(this, token);
      var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
      tmplContent.__location = null;
    },
    _insertFakeRootElement: function() {
      orig._insertFakeRootElement.call(this);
      this.openElements.current.__location = null;
    },
    //Comments
    _appendCommentNode: function(token, parent2) {
      orig._appendCommentNode.call(this, token, parent2);
      var children2 = this.treeAdapter.getChildNodes(parent2), commentNode = children2[children2.length - 1];
      commentNode.__location = token.location;
    },
    //Text
    _findFosterParentingLocation: function() {
      mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
      return mxn.lastFosterParentingLocation;
    },
    _insertCharacters: function(token) {
      orig._insertCharacters.call(this, token);
      var hasFosterParent = this._shouldFosterParentOnInsertion(), parent2 = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current, siblings2 = this.treeAdapter.getChildNodes(parent2), textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings2.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings2.length - 1, textNode = siblings2[textNodeIdx];
      if (textNode.__location)
        textNode.__location.endOffset = token.location.endOffset;
      else
        textNode.__location = token.location;
    }
  };
};
var _default = {};
var DOCUMENT_MODE$2 = html.DOCUMENT_MODE;
_default.createDocument = function() {
  return {
    nodeName: "#document",
    mode: DOCUMENT_MODE$2.NO_QUIRKS,
    childNodes: []
  };
};
_default.createDocumentFragment = function() {
  return {
    nodeName: "#document-fragment",
    childNodes: []
  };
};
_default.createElement = function(tagName, namespaceURI, attrs) {
  return {
    nodeName: tagName,
    tagName,
    attrs,
    namespaceURI,
    childNodes: [],
    parentNode: null
  };
};
_default.createCommentNode = function(data2) {
  return {
    nodeName: "#comment",
    data: data2,
    parentNode: null
  };
};
var createTextNode$1 = function(value) {
  return {
    nodeName: "#text",
    value,
    parentNode: null
  };
};
var appendChild$1 = _default.appendChild = function(parentNode, newNode) {
  parentNode.childNodes.push(newNode);
  newNode.parentNode = parentNode;
};
var insertBefore$1 = _default.insertBefore = function(parentNode, newNode, referenceNode) {
  var insertionIdx = parentNode.childNodes.indexOf(referenceNode);
  parentNode.childNodes.splice(insertionIdx, 0, newNode);
  newNode.parentNode = parentNode;
};
_default.setTemplateContent = function(templateElement, contentElement) {
  templateElement.content = contentElement;
};
_default.getTemplateContent = function(templateElement) {
  return templateElement.content;
};
_default.setDocumentType = function(document, name2, publicId, systemId) {
  var doctypeNode = null;
  for (var i2 = 0; i2 < document.childNodes.length; i2++) {
    if (document.childNodes[i2].nodeName === "#documentType") {
      doctypeNode = document.childNodes[i2];
      break;
    }
  }
  if (doctypeNode) {
    doctypeNode.name = name2;
    doctypeNode.publicId = publicId;
    doctypeNode.systemId = systemId;
  } else {
    appendChild$1(document, {
      nodeName: "#documentType",
      name: name2,
      publicId,
      systemId
    });
  }
};
_default.setDocumentMode = function(document, mode) {
  document.mode = mode;
};
_default.getDocumentMode = function(document) {
  return document.mode;
};
_default.detachNode = function(node2) {
  if (node2.parentNode) {
    var idx = node2.parentNode.childNodes.indexOf(node2);
    node2.parentNode.childNodes.splice(idx, 1);
    node2.parentNode = null;
  }
};
_default.insertText = function(parentNode, text2) {
  if (parentNode.childNodes.length) {
    var prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
    if (prevNode.nodeName === "#text") {
      prevNode.value += text2;
      return;
    }
  }
  appendChild$1(parentNode, createTextNode$1(text2));
};
_default.insertTextBefore = function(parentNode, text2, referenceNode) {
  var prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
  if (prevNode && prevNode.nodeName === "#text")
    prevNode.value += text2;
  else
    insertBefore$1(parentNode, createTextNode$1(text2), referenceNode);
};
_default.adoptAttributes = function(recipient, attrs) {
  var recipientAttrsMap = [];
  for (var i2 = 0; i2 < recipient.attrs.length; i2++)
    recipientAttrsMap.push(recipient.attrs[i2].name);
  for (var j2 = 0; j2 < attrs.length; j2++) {
    if (recipientAttrsMap.indexOf(attrs[j2].name) === -1)
      recipient.attrs.push(attrs[j2]);
  }
};
_default.getFirstChild = function(node2) {
  return node2.childNodes[0];
};
_default.getChildNodes = function(node2) {
  return node2.childNodes;
};
_default.getParentNode = function(node2) {
  return node2.parentNode;
};
_default.getAttrList = function(element2) {
  return element2.attrs;
};
_default.getTagName = function(element2) {
  return element2.tagName;
};
_default.getNamespaceURI = function(element2) {
  return element2.namespaceURI;
};
_default.getTextNodeContent = function(textNode) {
  return textNode.value;
};
_default.getCommentNodeContent = function(commentNode) {
  return commentNode.data;
};
_default.getDocumentTypeNodeName = function(doctypeNode) {
  return doctypeNode.name;
};
_default.getDocumentTypeNodePublicId = function(doctypeNode) {
  return doctypeNode.publicId;
};
_default.getDocumentTypeNodeSystemId = function(doctypeNode) {
  return doctypeNode.systemId;
};
_default.isTextNode = function(node2) {
  return node2.nodeName === "#text";
};
_default.isCommentNode = function(node2) {
  return node2.nodeName === "#comment";
};
_default.isDocumentTypeNode = function(node2) {
  return node2.nodeName === "#documentType";
};
_default.isElementNode = function(node2) {
  return !!node2.tagName;
};
var merge_options = function mergeOptions(defaults2, options2) {
  options2 = options2 || /* @__PURE__ */ Object.create(null);
  return [defaults2, options2].reduce(function(merged, optObj) {
    Object.keys(optObj).forEach(function(key) {
      merged[key] = optObj[key];
    });
    return merged;
  }, /* @__PURE__ */ Object.create(null));
};
var doctype$3 = {};
var DOCUMENT_MODE$1 = html.DOCUMENT_MODE;
var VALID_DOCTYPE_NAME = "html", QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
  "+//silmaril//dtd html pro v0r11 19970101//en",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//en",
  "-//as//dtd html 3.0 aswedit + extensions//en",
  "-//ietf//dtd html 2.0 level 1//en",
  "-//ietf//dtd html 2.0 level 2//en",
  "-//ietf//dtd html 2.0 strict level 1//en",
  "-//ietf//dtd html 2.0 strict level 2//en",
  "-//ietf//dtd html 2.0 strict//en",
  "-//ietf//dtd html 2.0//en",
  "-//ietf//dtd html 2.1e//en",
  "-//ietf//dtd html 3.0//en",
  "-//ietf//dtd html 3.0//en//",
  "-//ietf//dtd html 3.2 final//en",
  "-//ietf//dtd html 3.2//en",
  "-//ietf//dtd html 3//en",
  "-//ietf//dtd html level 0//en",
  "-//ietf//dtd html level 0//en//2.0",
  "-//ietf//dtd html level 1//en",
  "-//ietf//dtd html level 1//en//2.0",
  "-//ietf//dtd html level 2//en",
  "-//ietf//dtd html level 2//en//2.0",
  "-//ietf//dtd html level 3//en",
  "-//ietf//dtd html level 3//en//3.0",
  "-//ietf//dtd html strict level 0//en",
  "-//ietf//dtd html strict level 0//en//2.0",
  "-//ietf//dtd html strict level 1//en",
  "-//ietf//dtd html strict level 1//en//2.0",
  "-//ietf//dtd html strict level 2//en",
  "-//ietf//dtd html strict level 2//en//2.0",
  "-//ietf//dtd html strict level 3//en",
  "-//ietf//dtd html strict level 3//en//3.0",
  "-//ietf//dtd html strict//en",
  "-//ietf//dtd html strict//en//2.0",
  "-//ietf//dtd html strict//en//3.0",
  "-//ietf//dtd html//en",
  "-//ietf//dtd html//en//2.0",
  "-//ietf//dtd html//en//3.0",
  "-//metrius//dtd metrius presentational//en",
  "-//microsoft//dtd internet explorer 2.0 html strict//en",
  "-//microsoft//dtd internet explorer 2.0 html//en",
  "-//microsoft//dtd internet explorer 2.0 tables//en",
  "-//microsoft//dtd internet explorer 3.0 html strict//en",
  "-//microsoft//dtd internet explorer 3.0 html//en",
  "-//microsoft//dtd internet explorer 3.0 tables//en",
  "-//netscape comm. corp.//dtd html//en",
  "-//netscape comm. corp.//dtd strict html//en",
  "-//o'reilly and associates//dtd html 2.0//en",
  "-//o'reilly and associates//dtd html extended 1.0//en",
  "-//spyglass//dtd html 2.0 extended//en",
  "-//sq//dtd html 2.0 hotmetal + extensions//en",
  "-//sun microsystems corp.//dtd hotjava html//en",
  "-//sun microsystems corp.//dtd hotjava strict html//en",
  "-//w3c//dtd html 3 1995-03-24//en",
  "-//w3c//dtd html 3.2 draft//en",
  "-//w3c//dtd html 3.2 final//en",
  "-//w3c//dtd html 3.2//en",
  "-//w3c//dtd html 3.2s draft//en",
  "-//w3c//dtd html 4.0 frameset//en",
  "-//w3c//dtd html 4.0 transitional//en",
  "-//w3c//dtd html experimental 19960712//en",
  "-//w3c//dtd html experimental 970421//en",
  "-//w3c//dtd w3 html//en",
  "-//w3o//dtd w3 html 3.0//en",
  "-//w3o//dtd w3 html 3.0//en//",
  "-//webtechs//dtd mozilla html 2.0//en",
  "-//webtechs//dtd mozilla html//en"
], QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
]), QUIRKS_MODE_PUBLIC_IDS = [
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
], LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = [
  "-//W3C//DTD XHTML 1.0 Frameset//",
  "-//W3C//DTD XHTML 1.0 Transitional//"
], LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
  "-//W3C//DTD HTML 4.01 Frameset//",
  "-//W3C//DTD HTML 4.01 Transitional//"
]);
function enquoteDoctypeId(id) {
  var quote = id.indexOf('"') !== -1 ? "'" : '"';
  return quote + id + quote;
}
function hasPrefix(publicId, prefixes) {
  for (var i2 = 0; i2 < prefixes.length; i2++) {
    if (publicId.indexOf(prefixes[i2]) === 0)
      return true;
  }
  return false;
}
doctype$3.getDocumentMode = function(name2, publicId, systemId) {
  if (name2 !== VALID_DOCTYPE_NAME)
    return DOCUMENT_MODE$1.QUIRKS;
  if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID)
    return DOCUMENT_MODE$1.QUIRKS;
  if (publicId !== null) {
    publicId = publicId.toLowerCase();
    if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1)
      return DOCUMENT_MODE$1.QUIRKS;
    var prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes))
      return DOCUMENT_MODE$1.QUIRKS;
    prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
    if (hasPrefix(publicId, prefixes))
      return DOCUMENT_MODE$1.LIMITED_QUIRKS;
  }
  return DOCUMENT_MODE$1.NO_QUIRKS;
};
doctype$3.serializeContent = function(name2, publicId, systemId) {
  var str = "!DOCTYPE ";
  if (name2)
    str += name2;
  if (publicId !== null)
    str += " PUBLIC " + enquoteDoctypeId(publicId);
  else if (systemId !== null)
    str += " SYSTEM";
  if (systemId !== null)
    str += " " + enquoteDoctypeId(systemId);
  return str;
};
var foreign_content = {};
var Tokenizer$3 = tokenizerExports, HTML$3 = html;
var $$4 = HTML$3.TAG_NAMES, NS$3 = HTML$3.NAMESPACES, ATTRS$1 = HTML$3.ATTRS;
var MIME_TYPES = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var DEFINITION_URL_ATTR = "definitionurl", ADJUSTED_DEFINITION_URL_ATTR = "definitionURL", SVG_ATTRS_ADJUSTMENT_MAP = {
  "attributename": "attributeName",
  "attributetype": "attributeType",
  "basefrequency": "baseFrequency",
  "baseprofile": "baseProfile",
  "calcmode": "calcMode",
  "clippathunits": "clipPathUnits",
  "diffuseconstant": "diffuseConstant",
  "edgemode": "edgeMode",
  "filterunits": "filterUnits",
  "glyphref": "glyphRef",
  "gradienttransform": "gradientTransform",
  "gradientunits": "gradientUnits",
  "kernelmatrix": "kernelMatrix",
  "kernelunitlength": "kernelUnitLength",
  "keypoints": "keyPoints",
  "keysplines": "keySplines",
  "keytimes": "keyTimes",
  "lengthadjust": "lengthAdjust",
  "limitingconeangle": "limitingConeAngle",
  "markerheight": "markerHeight",
  "markerunits": "markerUnits",
  "markerwidth": "markerWidth",
  "maskcontentunits": "maskContentUnits",
  "maskunits": "maskUnits",
  "numoctaves": "numOctaves",
  "pathlength": "pathLength",
  "patterncontentunits": "patternContentUnits",
  "patterntransform": "patternTransform",
  "patternunits": "patternUnits",
  "pointsatx": "pointsAtX",
  "pointsaty": "pointsAtY",
  "pointsatz": "pointsAtZ",
  "preservealpha": "preserveAlpha",
  "preserveaspectratio": "preserveAspectRatio",
  "primitiveunits": "primitiveUnits",
  "refx": "refX",
  "refy": "refY",
  "repeatcount": "repeatCount",
  "repeatdur": "repeatDur",
  "requiredextensions": "requiredExtensions",
  "requiredfeatures": "requiredFeatures",
  "specularconstant": "specularConstant",
  "specularexponent": "specularExponent",
  "spreadmethod": "spreadMethod",
  "startoffset": "startOffset",
  "stddeviation": "stdDeviation",
  "stitchtiles": "stitchTiles",
  "surfacescale": "surfaceScale",
  "systemlanguage": "systemLanguage",
  "tablevalues": "tableValues",
  "targetx": "targetX",
  "targety": "targetY",
  "textlength": "textLength",
  "viewbox": "viewBox",
  "viewtarget": "viewTarget",
  "xchannelselector": "xChannelSelector",
  "ychannelselector": "yChannelSelector",
  "zoomandpan": "zoomAndPan"
}, XML_ATTRS_ADJUSTMENT_MAP = {
  "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: NS$3.XLINK },
  "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: NS$3.XLINK },
  "xlink:href": { prefix: "xlink", name: "href", namespace: NS$3.XLINK },
  "xlink:role": { prefix: "xlink", name: "role", namespace: NS$3.XLINK },
  "xlink:show": { prefix: "xlink", name: "show", namespace: NS$3.XLINK },
  "xlink:title": { prefix: "xlink", name: "title", namespace: NS$3.XLINK },
  "xlink:type": { prefix: "xlink", name: "type", namespace: NS$3.XLINK },
  "xml:base": { prefix: "xml", name: "base", namespace: NS$3.XML },
  "xml:lang": { prefix: "xml", name: "lang", namespace: NS$3.XML },
  "xml:space": { prefix: "xml", name: "space", namespace: NS$3.XML },
  "xmlns": { prefix: "", name: "xmlns", namespace: NS$3.XMLNS },
  "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: NS$3.XMLNS }
};
var SVG_TAG_NAMES_ADJUSTMENT_MAP = foreign_content.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
  "altglyph": "altGlyph",
  "altglyphdef": "altGlyphDef",
  "altglyphitem": "altGlyphItem",
  "animatecolor": "animateColor",
  "animatemotion": "animateMotion",
  "animatetransform": "animateTransform",
  "clippath": "clipPath",
  "feblend": "feBlend",
  "fecolormatrix": "feColorMatrix",
  "fecomponenttransfer": "feComponentTransfer",
  "fecomposite": "feComposite",
  "feconvolvematrix": "feConvolveMatrix",
  "fediffuselighting": "feDiffuseLighting",
  "fedisplacementmap": "feDisplacementMap",
  "fedistantlight": "feDistantLight",
  "feflood": "feFlood",
  "fefunca": "feFuncA",
  "fefuncb": "feFuncB",
  "fefuncg": "feFuncG",
  "fefuncr": "feFuncR",
  "fegaussianblur": "feGaussianBlur",
  "feimage": "feImage",
  "femerge": "feMerge",
  "femergenode": "feMergeNode",
  "femorphology": "feMorphology",
  "feoffset": "feOffset",
  "fepointlight": "fePointLight",
  "fespecularlighting": "feSpecularLighting",
  "fespotlight": "feSpotLight",
  "fetile": "feTile",
  "feturbulence": "feTurbulence",
  "foreignobject": "foreignObject",
  "glyphref": "glyphRef",
  "lineargradient": "linearGradient",
  "radialgradient": "radialGradient",
  "textpath": "textPath"
};
var EXITS_FOREIGN_CONTENT = /* @__PURE__ */ Object.create(null);
EXITS_FOREIGN_CONTENT[$$4.B] = true;
EXITS_FOREIGN_CONTENT[$$4.BIG] = true;
EXITS_FOREIGN_CONTENT[$$4.BLOCKQUOTE] = true;
EXITS_FOREIGN_CONTENT[$$4.BODY] = true;
EXITS_FOREIGN_CONTENT[$$4.BR] = true;
EXITS_FOREIGN_CONTENT[$$4.CENTER] = true;
EXITS_FOREIGN_CONTENT[$$4.CODE] = true;
EXITS_FOREIGN_CONTENT[$$4.DD] = true;
EXITS_FOREIGN_CONTENT[$$4.DIV] = true;
EXITS_FOREIGN_CONTENT[$$4.DL] = true;
EXITS_FOREIGN_CONTENT[$$4.DT] = true;
EXITS_FOREIGN_CONTENT[$$4.EM] = true;
EXITS_FOREIGN_CONTENT[$$4.EMBED] = true;
EXITS_FOREIGN_CONTENT[$$4.H1] = true;
EXITS_FOREIGN_CONTENT[$$4.H2] = true;
EXITS_FOREIGN_CONTENT[$$4.H3] = true;
EXITS_FOREIGN_CONTENT[$$4.H4] = true;
EXITS_FOREIGN_CONTENT[$$4.H5] = true;
EXITS_FOREIGN_CONTENT[$$4.H6] = true;
EXITS_FOREIGN_CONTENT[$$4.HEAD] = true;
EXITS_FOREIGN_CONTENT[$$4.HR] = true;
EXITS_FOREIGN_CONTENT[$$4.I] = true;
EXITS_FOREIGN_CONTENT[$$4.IMG] = true;
EXITS_FOREIGN_CONTENT[$$4.LI] = true;
EXITS_FOREIGN_CONTENT[$$4.LISTING] = true;
EXITS_FOREIGN_CONTENT[$$4.MENU] = true;
EXITS_FOREIGN_CONTENT[$$4.META] = true;
EXITS_FOREIGN_CONTENT[$$4.NOBR] = true;
EXITS_FOREIGN_CONTENT[$$4.OL] = true;
EXITS_FOREIGN_CONTENT[$$4.P] = true;
EXITS_FOREIGN_CONTENT[$$4.PRE] = true;
EXITS_FOREIGN_CONTENT[$$4.RUBY] = true;
EXITS_FOREIGN_CONTENT[$$4.S] = true;
EXITS_FOREIGN_CONTENT[$$4.SMALL] = true;
EXITS_FOREIGN_CONTENT[$$4.SPAN] = true;
EXITS_FOREIGN_CONTENT[$$4.STRONG] = true;
EXITS_FOREIGN_CONTENT[$$4.STRIKE] = true;
EXITS_FOREIGN_CONTENT[$$4.SUB] = true;
EXITS_FOREIGN_CONTENT[$$4.SUP] = true;
EXITS_FOREIGN_CONTENT[$$4.TABLE] = true;
EXITS_FOREIGN_CONTENT[$$4.TT] = true;
EXITS_FOREIGN_CONTENT[$$4.U] = true;
EXITS_FOREIGN_CONTENT[$$4.UL] = true;
EXITS_FOREIGN_CONTENT[$$4.VAR] = true;
foreign_content.causesExit = function(startTagToken) {
  var tn = startTagToken.tagName;
  var isFontWithAttrs = tn === $$4.FONT && (Tokenizer$3.getTokenAttr(startTagToken, ATTRS$1.COLOR) !== null || Tokenizer$3.getTokenAttr(startTagToken, ATTRS$1.SIZE) !== null || Tokenizer$3.getTokenAttr(startTagToken, ATTRS$1.FACE) !== null);
  return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
};
foreign_content.adjustTokenMathMLAttrs = function(token) {
  for (var i2 = 0; i2 < token.attrs.length; i2++) {
    if (token.attrs[i2].name === DEFINITION_URL_ATTR) {
      token.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR;
      break;
    }
  }
};
foreign_content.adjustTokenSVGAttrs = function(token) {
  for (var i2 = 0; i2 < token.attrs.length; i2++) {
    var adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i2].name];
    if (adjustedAttrName)
      token.attrs[i2].name = adjustedAttrName;
  }
};
foreign_content.adjustTokenXMLAttrs = function(token) {
  for (var i2 = 0; i2 < token.attrs.length; i2++) {
    var adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i2].name];
    if (adjustedAttrEntry) {
      token.attrs[i2].prefix = adjustedAttrEntry.prefix;
      token.attrs[i2].name = adjustedAttrEntry.name;
      token.attrs[i2].namespace = adjustedAttrEntry.namespace;
    }
  }
};
foreign_content.adjustTokenSVGTagName = function(token) {
  var adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
  if (adjustedTagName)
    token.tagName = adjustedTagName;
};
function isMathMLTextIntegrationPoint(tn, ns) {
  return ns === NS$3.MATHML && (tn === $$4.MI || tn === $$4.MO || tn === $$4.MN || tn === $$4.MS || tn === $$4.MTEXT);
}
function isHtmlIntegrationPoint(tn, ns, attrs) {
  if (ns === NS$3.MATHML && tn === $$4.ANNOTATION_XML) {
    for (var i2 = 0; i2 < attrs.length; i2++) {
      if (attrs[i2].name === ATTRS$1.ENCODING) {
        var value = attrs[i2].value.toLowerCase();
        return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
      }
    }
  }
  return ns === NS$3.SVG && (tn === $$4.FOREIGN_OBJECT || tn === $$4.DESC || tn === $$4.TITLE);
}
foreign_content.isIntegrationPoint = function(tn, ns, attrs, foreignNS) {
  if ((!foreignNS || foreignNS === NS$3.HTML) && isHtmlIntegrationPoint(tn, ns, attrs))
    return true;
  if ((!foreignNS || foreignNS === NS$3.MATHML) && isMathMLTextIntegrationPoint(tn, ns))
    return true;
  return false;
};
var Tokenizer$2 = tokenizerExports, OpenElementStack2 = open_element_stackExports, FormattingElementList2 = formatting_element_listExports, LocationInfoParserMixin = parser_mixinExports, defaultTreeAdapter$1 = _default, mergeOptions$2 = merge_options, doctype$2 = doctype$3, foreignContent$1 = foreign_content, UNICODE$1 = unicode, HTML$2 = html;
var $$3 = HTML$2.TAG_NAMES, NS$2 = HTML$2.NAMESPACES, ATTRS = HTML$2.ATTRS;
var DEFAULT_OPTIONS$2 = {
  locationInfo: false,
  treeAdapter: defaultTreeAdapter$1
};
var HIDDEN_INPUT_TYPE = "hidden";
var AA_OUTER_LOOP_ITER = 8, AA_INNER_LOOP_ITER = 3;
var INITIAL_MODE = "INITIAL_MODE", BEFORE_HTML_MODE = "BEFORE_HTML_MODE", BEFORE_HEAD_MODE = "BEFORE_HEAD_MODE", IN_HEAD_MODE = "IN_HEAD_MODE", AFTER_HEAD_MODE = "AFTER_HEAD_MODE", IN_BODY_MODE = "IN_BODY_MODE", TEXT_MODE = "TEXT_MODE", IN_TABLE_MODE = "IN_TABLE_MODE", IN_TABLE_TEXT_MODE = "IN_TABLE_TEXT_MODE", IN_CAPTION_MODE = "IN_CAPTION_MODE", IN_COLUMN_GROUP_MODE = "IN_COLUMN_GROUP_MODE", IN_TABLE_BODY_MODE = "IN_TABLE_BODY_MODE", IN_ROW_MODE = "IN_ROW_MODE", IN_CELL_MODE = "IN_CELL_MODE", IN_SELECT_MODE = "IN_SELECT_MODE", IN_SELECT_IN_TABLE_MODE = "IN_SELECT_IN_TABLE_MODE", IN_TEMPLATE_MODE = "IN_TEMPLATE_MODE", AFTER_BODY_MODE = "AFTER_BODY_MODE", IN_FRAMESET_MODE = "IN_FRAMESET_MODE", AFTER_FRAMESET_MODE = "AFTER_FRAMESET_MODE", AFTER_AFTER_BODY_MODE = "AFTER_AFTER_BODY_MODE", AFTER_AFTER_FRAMESET_MODE = "AFTER_AFTER_FRAMESET_MODE";
var INSERTION_MODE_RESET_MAP = /* @__PURE__ */ Object.create(null);
INSERTION_MODE_RESET_MAP[$$3.TR] = IN_ROW_MODE;
INSERTION_MODE_RESET_MAP[$$3.TBODY] = INSERTION_MODE_RESET_MAP[$$3.THEAD] = INSERTION_MODE_RESET_MAP[$$3.TFOOT] = IN_TABLE_BODY_MODE;
INSERTION_MODE_RESET_MAP[$$3.CAPTION] = IN_CAPTION_MODE;
INSERTION_MODE_RESET_MAP[$$3.COLGROUP] = IN_COLUMN_GROUP_MODE;
INSERTION_MODE_RESET_MAP[$$3.TABLE] = IN_TABLE_MODE;
INSERTION_MODE_RESET_MAP[$$3.BODY] = IN_BODY_MODE;
INSERTION_MODE_RESET_MAP[$$3.FRAMESET] = IN_FRAMESET_MODE;
var TEMPLATE_INSERTION_MODE_SWITCH_MAP = /* @__PURE__ */ Object.create(null);
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.CAPTION] = TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.COLGROUP] = TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.TBODY] = TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.TFOOT] = TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.THEAD] = IN_TABLE_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.COL] = IN_COLUMN_GROUP_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.TR] = IN_TABLE_BODY_MODE;
TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.TD] = TEMPLATE_INSERTION_MODE_SWITCH_MAP[$$3.TH] = IN_ROW_MODE;
var _$2 = /* @__PURE__ */ Object.create(null);
_$2[INITIAL_MODE] = /* @__PURE__ */ Object.create(null);
_$2[INITIAL_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[INITIAL_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenInInitialMode;
_$2[INITIAL_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_$2[INITIAL_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[INITIAL_MODE][Tokenizer$2.DOCTYPE_TOKEN] = doctypeInInitialMode;
_$2[INITIAL_MODE][Tokenizer$2.START_TAG_TOKEN] = _$2[INITIAL_MODE][Tokenizer$2.END_TAG_TOKEN] = _$2[INITIAL_MODE][Tokenizer$2.EOF_TOKEN] = tokenInInitialMode;
_$2[BEFORE_HTML_MODE] = /* @__PURE__ */ Object.create(null);
_$2[BEFORE_HTML_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[BEFORE_HTML_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenBeforeHtml;
_$2[BEFORE_HTML_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_$2[BEFORE_HTML_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[BEFORE_HTML_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[BEFORE_HTML_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagBeforeHtml;
_$2[BEFORE_HTML_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagBeforeHtml;
_$2[BEFORE_HTML_MODE][Tokenizer$2.EOF_TOKEN] = tokenBeforeHtml;
_$2[BEFORE_HEAD_MODE] = /* @__PURE__ */ Object.create(null);
_$2[BEFORE_HEAD_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[BEFORE_HEAD_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenBeforeHead;
_$2[BEFORE_HEAD_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = ignoreToken;
_$2[BEFORE_HEAD_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[BEFORE_HEAD_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[BEFORE_HEAD_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagBeforeHead;
_$2[BEFORE_HEAD_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagBeforeHead;
_$2[BEFORE_HEAD_MODE][Tokenizer$2.EOF_TOKEN] = tokenBeforeHead;
_$2[IN_HEAD_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_HEAD_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[IN_HEAD_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenInHead;
_$2[IN_HEAD_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[IN_HEAD_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_HEAD_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_HEAD_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInHead;
_$2[IN_HEAD_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInHead;
_$2[IN_HEAD_MODE][Tokenizer$2.EOF_TOKEN] = tokenInHead;
_$2[AFTER_HEAD_MODE] = /* @__PURE__ */ Object.create(null);
_$2[AFTER_HEAD_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[AFTER_HEAD_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenAfterHead;
_$2[AFTER_HEAD_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[AFTER_HEAD_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[AFTER_HEAD_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[AFTER_HEAD_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagAfterHead;
_$2[AFTER_HEAD_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagAfterHead;
_$2[AFTER_HEAD_MODE][Tokenizer$2.EOF_TOKEN] = tokenAfterHead;
_$2[IN_BODY_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_BODY_MODE][Tokenizer$2.CHARACTER_TOKEN] = characterInBody;
_$2[IN_BODY_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_BODY_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[IN_BODY_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_BODY_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_BODY_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInBody;
_$2[IN_BODY_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInBody;
_$2[IN_BODY_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[TEXT_MODE] = /* @__PURE__ */ Object.create(null);
_$2[TEXT_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[TEXT_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = _$2[TEXT_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[TEXT_MODE][Tokenizer$2.COMMENT_TOKEN] = _$2[TEXT_MODE][Tokenizer$2.DOCTYPE_TOKEN] = _$2[TEXT_MODE][Tokenizer$2.START_TAG_TOKEN] = ignoreToken;
_$2[TEXT_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInText;
_$2[TEXT_MODE][Tokenizer$2.EOF_TOKEN] = eofInText;
_$2[IN_TABLE_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_TABLE_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[IN_TABLE_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = _$2[IN_TABLE_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_$2[IN_TABLE_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_TABLE_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_TABLE_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInTable;
_$2[IN_TABLE_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInTable;
_$2[IN_TABLE_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_TABLE_TEXT_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_TABLE_TEXT_MODE][Tokenizer$2.CHARACTER_TOKEN] = characterInTableText;
_$2[IN_TABLE_TEXT_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_TABLE_TEXT_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInTableText;
_$2[IN_TABLE_TEXT_MODE][Tokenizer$2.COMMENT_TOKEN] = _$2[IN_TABLE_TEXT_MODE][Tokenizer$2.DOCTYPE_TOKEN] = _$2[IN_TABLE_TEXT_MODE][Tokenizer$2.START_TAG_TOKEN] = _$2[IN_TABLE_TEXT_MODE][Tokenizer$2.END_TAG_TOKEN] = _$2[IN_TABLE_TEXT_MODE][Tokenizer$2.EOF_TOKEN] = tokenInTableText;
_$2[IN_CAPTION_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_CAPTION_MODE][Tokenizer$2.CHARACTER_TOKEN] = characterInBody;
_$2[IN_CAPTION_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_CAPTION_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[IN_CAPTION_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_CAPTION_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_CAPTION_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInCaption;
_$2[IN_CAPTION_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInCaption;
_$2[IN_CAPTION_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_COLUMN_GROUP_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenInColumnGroup;
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInColumnGroup;
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInColumnGroup;
_$2[IN_COLUMN_GROUP_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_TABLE_BODY_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_TABLE_BODY_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[IN_TABLE_BODY_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = _$2[IN_TABLE_BODY_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_$2[IN_TABLE_BODY_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_TABLE_BODY_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_TABLE_BODY_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInTableBody;
_$2[IN_TABLE_BODY_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInTableBody;
_$2[IN_TABLE_BODY_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_ROW_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_ROW_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[IN_ROW_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = _$2[IN_ROW_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = characterInTable;
_$2[IN_ROW_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_ROW_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_ROW_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInRow;
_$2[IN_ROW_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInRow;
_$2[IN_ROW_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_CELL_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_CELL_MODE][Tokenizer$2.CHARACTER_TOKEN] = characterInBody;
_$2[IN_CELL_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_CELL_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[IN_CELL_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_CELL_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_CELL_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInCell;
_$2[IN_CELL_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInCell;
_$2[IN_CELL_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_SELECT_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_SELECT_MODE][Tokenizer$2.CHARACTER_TOKEN] = insertCharacters;
_$2[IN_SELECT_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_SELECT_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[IN_SELECT_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_SELECT_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_SELECT_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInSelect;
_$2[IN_SELECT_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInSelect;
_$2[IN_SELECT_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_SELECT_IN_TABLE_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.CHARACTER_TOKEN] = insertCharacters;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInSelectInTable;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInSelectInTable;
_$2[IN_SELECT_IN_TABLE_MODE][Tokenizer$2.EOF_TOKEN] = eofInBody;
_$2[IN_TEMPLATE_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_TEMPLATE_MODE][Tokenizer$2.CHARACTER_TOKEN] = characterInBody;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInTemplate;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInTemplate;
_$2[IN_TEMPLATE_MODE][Tokenizer$2.EOF_TOKEN] = eofInTemplate;
_$2[AFTER_BODY_MODE] = /* @__PURE__ */ Object.create(null);
_$2[AFTER_BODY_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[AFTER_BODY_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenAfterBody;
_$2[AFTER_BODY_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[AFTER_BODY_MODE][Tokenizer$2.COMMENT_TOKEN] = appendCommentToRootHtmlElement;
_$2[AFTER_BODY_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[AFTER_BODY_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagAfterBody;
_$2[AFTER_BODY_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagAfterBody;
_$2[AFTER_BODY_MODE][Tokenizer$2.EOF_TOKEN] = stopParsing;
_$2[IN_FRAMESET_MODE] = /* @__PURE__ */ Object.create(null);
_$2[IN_FRAMESET_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[IN_FRAMESET_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[IN_FRAMESET_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[IN_FRAMESET_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[IN_FRAMESET_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[IN_FRAMESET_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagInFrameset;
_$2[IN_FRAMESET_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagInFrameset;
_$2[IN_FRAMESET_MODE][Tokenizer$2.EOF_TOKEN] = stopParsing;
_$2[AFTER_FRAMESET_MODE] = /* @__PURE__ */ Object.create(null);
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[AFTER_FRAMESET_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = insertCharacters;
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.COMMENT_TOKEN] = appendComment;
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagAfterFrameset;
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.END_TAG_TOKEN] = endTagAfterFrameset;
_$2[AFTER_FRAMESET_MODE][Tokenizer$2.EOF_TOKEN] = stopParsing;
_$2[AFTER_AFTER_BODY_MODE] = /* @__PURE__ */ Object.create(null);
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.CHARACTER_TOKEN] = tokenAfterAfterBody;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = tokenAfterAfterBody;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.COMMENT_TOKEN] = appendCommentToDocument;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagAfterAfterBody;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.END_TAG_TOKEN] = tokenAfterAfterBody;
_$2[AFTER_AFTER_BODY_MODE][Tokenizer$2.EOF_TOKEN] = stopParsing;
_$2[AFTER_AFTER_FRAMESET_MODE] = /* @__PURE__ */ Object.create(null);
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.CHARACTER_TOKEN] = _$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.NULL_CHARACTER_TOKEN] = ignoreToken;
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.WHITESPACE_CHARACTER_TOKEN] = whitespaceCharacterInBody;
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.COMMENT_TOKEN] = appendCommentToDocument;
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.DOCTYPE_TOKEN] = ignoreToken;
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.START_TAG_TOKEN] = startTagAfterAfterFrameset;
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.END_TAG_TOKEN] = ignoreToken;
_$2[AFTER_AFTER_FRAMESET_MODE][Tokenizer$2.EOF_TOKEN] = stopParsing;
var Parser$2 = parser.exports = function(options2) {
  this.options = mergeOptions$2(DEFAULT_OPTIONS$2, options2);
  this.treeAdapter = this.options.treeAdapter;
  this.pendingScript = null;
  if (this.options.locationInfo)
    new LocationInfoParserMixin(this);
};
Parser$2.prototype.parse = function(html2) {
  var document = this.treeAdapter.createDocument();
  this._bootstrap(document, null);
  this.tokenizer.write(html2, true);
  this._runParsingLoop(null);
  return document;
};
Parser$2.prototype.parseFragment = function(html2, fragmentContext) {
  if (!fragmentContext)
    fragmentContext = this.treeAdapter.createElement($$3.TEMPLATE, NS$2.HTML, []);
  var documentMock = this.treeAdapter.createElement("documentmock", NS$2.HTML, []);
  this._bootstrap(documentMock, fragmentContext);
  if (this.treeAdapter.getTagName(fragmentContext) === $$3.TEMPLATE)
    this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
  this._initTokenizerForFragmentParsing();
  this._insertFakeRootElement();
  this._resetInsertionMode();
  this._findFormInFragmentContext();
  this.tokenizer.write(html2, true);
  this._runParsingLoop(null);
  var rootElement = this.treeAdapter.getFirstChild(documentMock), fragment = this.treeAdapter.createDocumentFragment();
  this._adoptNodes(rootElement, fragment);
  return fragment;
};
Parser$2.prototype._bootstrap = function(document, fragmentContext) {
  this.tokenizer = new Tokenizer$2(this.options);
  this.stopped = false;
  this.insertionMode = INITIAL_MODE;
  this.originalInsertionMode = "";
  this.document = document;
  this.fragmentContext = fragmentContext;
  this.headElement = null;
  this.formElement = null;
  this.openElements = new OpenElementStack2(this.document, this.treeAdapter);
  this.activeFormattingElements = new FormattingElementList2(this.treeAdapter);
  this.tmplInsertionModeStack = [];
  this.tmplInsertionModeStackTop = -1;
  this.currentTmplInsertionMode = null;
  this.pendingCharacterTokens = [];
  this.hasNonWhitespacePendingCharacterToken = false;
  this.framesetOk = true;
  this.skipNextNewLine = false;
  this.fosterParentingEnabled = false;
};
Parser$2.prototype._runParsingLoop = function(scriptHandler) {
  while (!this.stopped) {
    this._setupTokenizerCDATAMode();
    var token = this.tokenizer.getNextToken();
    if (token.type === Tokenizer$2.HIBERNATION_TOKEN)
      break;
    if (this.skipNextNewLine) {
      this.skipNextNewLine = false;
      if (token.type === Tokenizer$2.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === "\n") {
        if (token.chars.length === 1)
          continue;
        token.chars = token.chars.substr(1);
      }
    }
    this._processInputToken(token);
    if (scriptHandler && this.pendingScript)
      break;
  }
};
Parser$2.prototype.runParsingLoopForCurrentChunk = function(writeCallback, scriptHandler) {
  this._runParsingLoop(scriptHandler);
  if (scriptHandler && this.pendingScript) {
    var script = this.pendingScript;
    this.pendingScript = null;
    scriptHandler(script);
    return;
  }
  if (writeCallback)
    writeCallback();
};
Parser$2.prototype._setupTokenizerCDATAMode = function() {
  var current = this._getAdjustedCurrentElement();
  this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS$2.HTML && !this._isIntegrationPoint(current);
};
Parser$2.prototype._switchToTextParsing = function(currentToken, nextTokenizerState) {
  this._insertElement(currentToken, NS$2.HTML);
  this.tokenizer.state = nextTokenizerState;
  this.originalInsertionMode = this.insertionMode;
  this.insertionMode = TEXT_MODE;
};
Parser$2.prototype.switchToPlaintextParsing = function() {
  this.insertionMode = TEXT_MODE;
  this.originalInsertionMode = IN_BODY_MODE;
  this.tokenizer.state = Tokenizer$2.MODE.PLAINTEXT;
};
Parser$2.prototype._getAdjustedCurrentElement = function() {
  return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
};
Parser$2.prototype._findFormInFragmentContext = function() {
  var node2 = this.fragmentContext;
  do {
    if (this.treeAdapter.getTagName(node2) === $$3.FORM) {
      this.formElement = node2;
      break;
    }
    node2 = this.treeAdapter.getParentNode(node2);
  } while (node2);
};
Parser$2.prototype._initTokenizerForFragmentParsing = function() {
  if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS$2.HTML) {
    var tn = this.treeAdapter.getTagName(this.fragmentContext);
    if (tn === $$3.TITLE || tn === $$3.TEXTAREA)
      this.tokenizer.state = Tokenizer$2.MODE.RCDATA;
    else if (tn === $$3.STYLE || tn === $$3.XMP || tn === $$3.IFRAME || tn === $$3.NOEMBED || tn === $$3.NOFRAMES || tn === $$3.NOSCRIPT)
      this.tokenizer.state = Tokenizer$2.MODE.RAWTEXT;
    else if (tn === $$3.SCRIPT)
      this.tokenizer.state = Tokenizer$2.MODE.SCRIPT_DATA;
    else if (tn === $$3.PLAINTEXT)
      this.tokenizer.state = Tokenizer$2.MODE.PLAINTEXT;
  }
};
Parser$2.prototype._setDocumentType = function(token) {
  this.treeAdapter.setDocumentType(this.document, token.name, token.publicId, token.systemId);
};
Parser$2.prototype._attachElementToTree = function(element2) {
  if (this._shouldFosterParentOnInsertion())
    this._fosterParentElement(element2);
  else {
    var parent2 = this.openElements.currentTmplContent || this.openElements.current;
    this.treeAdapter.appendChild(parent2, element2);
  }
};
Parser$2.prototype._appendElement = function(token, namespaceURI) {
  var element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
  this._attachElementToTree(element2);
};
Parser$2.prototype._insertElement = function(token, namespaceURI) {
  var element2 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
  this._attachElementToTree(element2);
  this.openElements.push(element2);
};
Parser$2.prototype._insertFakeElement = function(tagName) {
  var element2 = this.treeAdapter.createElement(tagName, NS$2.HTML, []);
  this._attachElementToTree(element2);
  this.openElements.push(element2);
};
Parser$2.prototype._insertTemplate = function(token) {
  var tmpl = this.treeAdapter.createElement(token.tagName, NS$2.HTML, token.attrs), content = this.treeAdapter.createDocumentFragment();
  this.treeAdapter.setTemplateContent(tmpl, content);
  this._attachElementToTree(tmpl);
  this.openElements.push(tmpl);
};
Parser$2.prototype._insertFakeRootElement = function() {
  var element2 = this.treeAdapter.createElement($$3.HTML, NS$2.HTML, []);
  this.treeAdapter.appendChild(this.openElements.current, element2);
  this.openElements.push(element2);
};
Parser$2.prototype._appendCommentNode = function(token, parent2) {
  var commentNode = this.treeAdapter.createCommentNode(token.data);
  this.treeAdapter.appendChild(parent2, commentNode);
};
Parser$2.prototype._insertCharacters = function(token) {
  if (this._shouldFosterParentOnInsertion())
    this._fosterParentText(token.chars);
  else {
    var parent2 = this.openElements.currentTmplContent || this.openElements.current;
    this.treeAdapter.insertText(parent2, token.chars);
  }
};
Parser$2.prototype._adoptNodes = function(donor, recipient) {
  while (true) {
    var child2 = this.treeAdapter.getFirstChild(donor);
    if (!child2)
      break;
    this.treeAdapter.detachNode(child2);
    this.treeAdapter.appendChild(recipient, child2);
  }
};
Parser$2.prototype._shouldProcessTokenInForeignContent = function(token) {
  var current = this._getAdjustedCurrentElement();
  if (!current || current === this.document)
    return false;
  var ns = this.treeAdapter.getNamespaceURI(current);
  if (ns === NS$2.HTML)
    return false;
  if (this.treeAdapter.getTagName(current) === $$3.ANNOTATION_XML && ns === NS$2.MATHML && token.type === Tokenizer$2.START_TAG_TOKEN && token.tagName === $$3.SVG)
    return false;
  var isCharacterToken = token.type === Tokenizer$2.CHARACTER_TOKEN || token.type === Tokenizer$2.NULL_CHARACTER_TOKEN || token.type === Tokenizer$2.WHITESPACE_CHARACTER_TOKEN, isMathMLTextStartTag = token.type === Tokenizer$2.START_TAG_TOKEN && token.tagName !== $$3.MGLYPH && token.tagName !== $$3.MALIGNMARK;
  if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS$2.MATHML))
    return false;
  if ((token.type === Tokenizer$2.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS$2.HTML))
    return false;
  return token.type !== Tokenizer$2.EOF_TOKEN;
};
Parser$2.prototype._processToken = function(token) {
  _$2[this.insertionMode][token.type](this, token);
};
Parser$2.prototype._processTokenInBodyMode = function(token) {
  _$2[IN_BODY_MODE][token.type](this, token);
};
Parser$2.prototype._processTokenInForeignContent = function(token) {
  if (token.type === Tokenizer$2.CHARACTER_TOKEN)
    characterInForeignContent(this, token);
  else if (token.type === Tokenizer$2.NULL_CHARACTER_TOKEN)
    nullCharacterInForeignContent(this, token);
  else if (token.type === Tokenizer$2.WHITESPACE_CHARACTER_TOKEN)
    insertCharacters(this, token);
  else if (token.type === Tokenizer$2.COMMENT_TOKEN)
    appendComment(this, token);
  else if (token.type === Tokenizer$2.START_TAG_TOKEN)
    startTagInForeignContent(this, token);
  else if (token.type === Tokenizer$2.END_TAG_TOKEN)
    endTagInForeignContent(this, token);
};
Parser$2.prototype._processInputToken = function(token) {
  if (this._shouldProcessTokenInForeignContent(token))
    this._processTokenInForeignContent(token);
  else
    this._processToken(token);
};
Parser$2.prototype._isIntegrationPoint = function(element2, foreignNS) {
  var tn = this.treeAdapter.getTagName(element2), ns = this.treeAdapter.getNamespaceURI(element2), attrs = this.treeAdapter.getAttrList(element2);
  return foreignContent$1.isIntegrationPoint(tn, ns, attrs, foreignNS);
};
Parser$2.prototype._reconstructActiveFormattingElements = function() {
  var listLength = this.activeFormattingElements.length;
  if (listLength) {
    var unopenIdx = listLength, entry = null;
    do {
      unopenIdx--;
      entry = this.activeFormattingElements.entries[unopenIdx];
      if (entry.type === FormattingElementList2.MARKER_ENTRY || this.openElements.contains(entry.element)) {
        unopenIdx++;
        break;
      }
    } while (unopenIdx > 0);
    for (var i2 = unopenIdx; i2 < listLength; i2++) {
      entry = this.activeFormattingElements.entries[i2];
      this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
      entry.element = this.openElements.current;
    }
  }
};
Parser$2.prototype._closeTableCell = function() {
  this.openElements.generateImpliedEndTags();
  this.openElements.popUntilTableCellPopped();
  this.activeFormattingElements.clearToLastMarker();
  this.insertionMode = IN_ROW_MODE;
};
Parser$2.prototype._closePElement = function() {
  this.openElements.generateImpliedEndTagsWithExclusion($$3.P);
  this.openElements.popUntilTagNamePopped($$3.P);
};
Parser$2.prototype._resetInsertionMode = function() {
  for (var i2 = this.openElements.stackTop, last2 = false; i2 >= 0; i2--) {
    var element2 = this.openElements.items[i2];
    if (i2 === 0) {
      last2 = true;
      if (this.fragmentContext)
        element2 = this.fragmentContext;
    }
    var tn = this.treeAdapter.getTagName(element2), newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
    if (newInsertionMode) {
      this.insertionMode = newInsertionMode;
      break;
    } else if (!last2 && (tn === $$3.TD || tn === $$3.TH)) {
      this.insertionMode = IN_CELL_MODE;
      break;
    } else if (!last2 && tn === $$3.HEAD) {
      this.insertionMode = IN_HEAD_MODE;
      break;
    } else if (tn === $$3.SELECT) {
      this._resetInsertionModeForSelect(i2);
      break;
    } else if (tn === $$3.TEMPLATE) {
      this.insertionMode = this.currentTmplInsertionMode;
      break;
    } else if (tn === $$3.HTML) {
      this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
      break;
    } else if (last2) {
      this.insertionMode = IN_BODY_MODE;
      break;
    }
  }
};
Parser$2.prototype._resetInsertionModeForSelect = function(selectIdx) {
  if (selectIdx > 0) {
    for (var i2 = selectIdx - 1; i2 > 0; i2--) {
      var ancestor = this.openElements.items[i2], tn = this.treeAdapter.getTagName(ancestor);
      if (tn === $$3.TEMPLATE)
        break;
      else if (tn === $$3.TABLE) {
        this.insertionMode = IN_SELECT_IN_TABLE_MODE;
        return;
      }
    }
  }
  this.insertionMode = IN_SELECT_MODE;
};
Parser$2.prototype._pushTmplInsertionMode = function(mode) {
  this.tmplInsertionModeStack.push(mode);
  this.tmplInsertionModeStackTop++;
  this.currentTmplInsertionMode = mode;
};
Parser$2.prototype._popTmplInsertionMode = function() {
  this.tmplInsertionModeStack.pop();
  this.tmplInsertionModeStackTop--;
  this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
};
Parser$2.prototype._isElementCausesFosterParenting = function(element2) {
  var tn = this.treeAdapter.getTagName(element2);
  return tn === $$3.TABLE || tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD || tn === $$3.TR;
};
Parser$2.prototype._shouldFosterParentOnInsertion = function() {
  return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
};
Parser$2.prototype._findFosterParentingLocation = function() {
  var location = {
    parent: null,
    beforeElement: null
  };
  for (var i2 = this.openElements.stackTop; i2 >= 0; i2--) {
    var openElement = this.openElements.items[i2], tn = this.treeAdapter.getTagName(openElement), ns = this.treeAdapter.getNamespaceURI(openElement);
    if (tn === $$3.TEMPLATE && ns === NS$2.HTML) {
      location.parent = this.treeAdapter.getTemplateContent(openElement);
      break;
    } else if (tn === $$3.TABLE) {
      location.parent = this.treeAdapter.getParentNode(openElement);
      if (location.parent)
        location.beforeElement = openElement;
      else
        location.parent = this.openElements.items[i2 - 1];
      break;
    }
  }
  if (!location.parent)
    location.parent = this.openElements.items[0];
  return location;
};
Parser$2.prototype._fosterParentElement = function(element2) {
  var location = this._findFosterParentingLocation();
  if (location.beforeElement)
    this.treeAdapter.insertBefore(location.parent, element2, location.beforeElement);
  else
    this.treeAdapter.appendChild(location.parent, element2);
};
Parser$2.prototype._fosterParentText = function(chars) {
  var location = this._findFosterParentingLocation();
  if (location.beforeElement)
    this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);
  else
    this.treeAdapter.insertText(location.parent, chars);
};
Parser$2.prototype._isSpecialElement = function(element2) {
  var tn = this.treeAdapter.getTagName(element2), ns = this.treeAdapter.getNamespaceURI(element2);
  return HTML$2.SPECIAL_ELEMENTS[ns][tn];
};
function aaObtainFormattingElementEntry(p, token) {
  var formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
  if (formattingElementEntry) {
    if (!p.openElements.contains(formattingElementEntry.element)) {
      p.activeFormattingElements.removeEntry(formattingElementEntry);
      formattingElementEntry = null;
    } else if (!p.openElements.hasInScope(token.tagName))
      formattingElementEntry = null;
  } else
    genericEndTagInBody(p, token);
  return formattingElementEntry;
}
function aaObtainFurthestBlock(p, formattingElementEntry) {
  var furthestBlock = null;
  for (var i2 = p.openElements.stackTop; i2 >= 0; i2--) {
    var element2 = p.openElements.items[i2];
    if (element2 === formattingElementEntry.element)
      break;
    if (p._isSpecialElement(element2))
      furthestBlock = element2;
  }
  if (!furthestBlock) {
    p.openElements.popUntilElementPopped(formattingElementEntry.element);
    p.activeFormattingElements.removeEntry(formattingElementEntry);
  }
  return furthestBlock;
}
function aaInnerLoop(p, furthestBlock, formattingElement) {
  var lastElement = furthestBlock, nextElement = p.openElements.getCommonAncestor(furthestBlock);
  for (var i2 = 0, element2 = nextElement; element2 !== formattingElement; i2++, element2 = nextElement) {
    nextElement = p.openElements.getCommonAncestor(element2);
    var elementEntry = p.activeFormattingElements.getElementEntry(element2), counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER, shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
    if (shouldRemoveFromOpenElements) {
      if (counterOverflow)
        p.activeFormattingElements.removeEntry(elementEntry);
      p.openElements.remove(element2);
    } else {
      element2 = aaRecreateElementFromEntry(p, elementEntry);
      if (lastElement === furthestBlock)
        p.activeFormattingElements.bookmark = elementEntry;
      p.treeAdapter.detachNode(lastElement);
      p.treeAdapter.appendChild(element2, lastElement);
      lastElement = element2;
    }
  }
  return lastElement;
}
function aaRecreateElementFromEntry(p, elementEntry) {
  var ns = p.treeAdapter.getNamespaceURI(elementEntry.element), newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
  p.openElements.replace(elementEntry.element, newElement);
  elementEntry.element = newElement;
  return newElement;
}
function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
  if (p._isElementCausesFosterParenting(commonAncestor))
    p._fosterParentElement(lastElement);
  else {
    var tn = p.treeAdapter.getTagName(commonAncestor), ns = p.treeAdapter.getNamespaceURI(commonAncestor);
    if (tn === $$3.TEMPLATE && ns === NS$2.HTML)
      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
    p.treeAdapter.appendChild(commonAncestor, lastElement);
  }
}
function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
  var ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element), token = formattingElementEntry.token, newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
  p._adoptNodes(furthestBlock, newElement);
  p.treeAdapter.appendChild(furthestBlock, newElement);
  p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
  p.activeFormattingElements.removeEntry(formattingElementEntry);
  p.openElements.remove(formattingElementEntry.element);
  p.openElements.insertAfter(furthestBlock, newElement);
}
function callAdoptionAgency(p, token) {
  var formattingElementEntry;
  for (var i2 = 0; i2 < AA_OUTER_LOOP_ITER; i2++) {
    formattingElementEntry = aaObtainFormattingElementEntry(p, token);
    if (!formattingElementEntry)
      break;
    var furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
    if (!furthestBlock)
      break;
    p.activeFormattingElements.bookmark = formattingElementEntry;
    var lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element), commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
    p.treeAdapter.detachNode(lastElement);
    aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
  }
}
function ignoreToken() {
}
function appendComment(p, token) {
  p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);
}
function appendCommentToRootHtmlElement(p, token) {
  p._appendCommentNode(token, p.openElements.items[0]);
}
function appendCommentToDocument(p, token) {
  p._appendCommentNode(token, p.document);
}
function insertCharacters(p, token) {
  p._insertCharacters(token);
}
function stopParsing(p) {
  p.stopped = true;
}
function doctypeInInitialMode(p, token) {
  p._setDocumentType(token);
  var mode = token.forceQuirks ? HTML$2.DOCUMENT_MODE.QUIRKS : doctype$2.getDocumentMode(token.name, token.publicId, token.systemId);
  p.treeAdapter.setDocumentMode(p.document, mode);
  p.insertionMode = BEFORE_HTML_MODE;
}
function tokenInInitialMode(p, token) {
  p.treeAdapter.setDocumentMode(p.document, HTML$2.DOCUMENT_MODE.QUIRKS);
  p.insertionMode = BEFORE_HTML_MODE;
  p._processToken(token);
}
function startTagBeforeHtml(p, token) {
  if (token.tagName === $$3.HTML) {
    p._insertElement(token, NS$2.HTML);
    p.insertionMode = BEFORE_HEAD_MODE;
  } else
    tokenBeforeHtml(p, token);
}
function endTagBeforeHtml(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML || tn === $$3.HEAD || tn === $$3.BODY || tn === $$3.BR)
    tokenBeforeHtml(p, token);
}
function tokenBeforeHtml(p, token) {
  p._insertFakeRootElement();
  p.insertionMode = BEFORE_HEAD_MODE;
  p._processToken(token);
}
function startTagBeforeHead(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.HEAD) {
    p._insertElement(token, NS$2.HTML);
    p.headElement = p.openElements.current;
    p.insertionMode = IN_HEAD_MODE;
  } else
    tokenBeforeHead(p, token);
}
function endTagBeforeHead(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HEAD || tn === $$3.BODY || tn === $$3.HTML || tn === $$3.BR)
    tokenBeforeHead(p, token);
}
function tokenBeforeHead(p, token) {
  p._insertFakeElement($$3.HEAD);
  p.headElement = p.openElements.current;
  p.insertionMode = IN_HEAD_MODE;
  p._processToken(token);
}
function startTagInHead(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.BASE || tn === $$3.BASEFONT || tn === $$3.BGSOUND || tn === $$3.LINK || tn === $$3.META)
    p._appendElement(token, NS$2.HTML);
  else if (tn === $$3.TITLE)
    p._switchToTextParsing(token, Tokenizer$2.MODE.RCDATA);
  else if (tn === $$3.NOSCRIPT || tn === $$3.NOFRAMES || tn === $$3.STYLE)
    p._switchToTextParsing(token, Tokenizer$2.MODE.RAWTEXT);
  else if (tn === $$3.SCRIPT)
    p._switchToTextParsing(token, Tokenizer$2.MODE.SCRIPT_DATA);
  else if (tn === $$3.TEMPLATE) {
    p._insertTemplate(token, NS$2.HTML);
    p.activeFormattingElements.insertMarker();
    p.framesetOk = false;
    p.insertionMode = IN_TEMPLATE_MODE;
    p._pushTmplInsertionMode(IN_TEMPLATE_MODE);
  } else if (tn !== $$3.HEAD)
    tokenInHead(p, token);
}
function endTagInHead(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HEAD) {
    p.openElements.pop();
    p.insertionMode = AFTER_HEAD_MODE;
  } else if (tn === $$3.BODY || tn === $$3.BR || tn === $$3.HTML)
    tokenInHead(p, token);
  else if (tn === $$3.TEMPLATE && p.openElements.tmplCount > 0) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped($$3.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p._popTmplInsertionMode();
    p._resetInsertionMode();
  }
}
function tokenInHead(p, token) {
  p.openElements.pop();
  p.insertionMode = AFTER_HEAD_MODE;
  p._processToken(token);
}
function startTagAfterHead(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.BODY) {
    p._insertElement(token, NS$2.HTML);
    p.framesetOk = false;
    p.insertionMode = IN_BODY_MODE;
  } else if (tn === $$3.FRAMESET) {
    p._insertElement(token, NS$2.HTML);
    p.insertionMode = IN_FRAMESET_MODE;
  } else if (tn === $$3.BASE || tn === $$3.BASEFONT || tn === $$3.BGSOUND || tn === $$3.LINK || tn === $$3.META || tn === $$3.NOFRAMES || tn === $$3.SCRIPT || tn === $$3.STYLE || tn === $$3.TEMPLATE || tn === $$3.TITLE) {
    p.openElements.push(p.headElement);
    startTagInHead(p, token);
    p.openElements.remove(p.headElement);
  } else if (tn !== $$3.HEAD)
    tokenAfterHead(p, token);
}
function endTagAfterHead(p, token) {
  var tn = token.tagName;
  if (tn === $$3.BODY || tn === $$3.HTML || tn === $$3.BR)
    tokenAfterHead(p, token);
  else if (tn === $$3.TEMPLATE)
    endTagInHead(p, token);
}
function tokenAfterHead(p, token) {
  p._insertFakeElement($$3.BODY);
  p.insertionMode = IN_BODY_MODE;
  p._processToken(token);
}
function whitespaceCharacterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
}
function characterInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertCharacters(token);
  p.framesetOk = false;
}
function htmlStartTagInBody(p, token) {
  if (p.openElements.tmplCount === 0)
    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
}
function bodyStartTagInBody(p, token) {
  var bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (bodyElement && p.openElements.tmplCount === 0) {
    p.framesetOk = false;
    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
  }
}
function framesetStartTagInBody(p, token) {
  var bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
  if (p.framesetOk && bodyElement) {
    p.treeAdapter.detachNode(bodyElement);
    p.openElements.popAllUpToHtmlElement();
    p._insertElement(token, NS$2.HTML);
    p.insertionMode = IN_FRAMESET_MODE;
  }
}
function addressStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  p._insertElement(token, NS$2.HTML);
}
function numberedHeaderStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  var tn = p.openElements.currentTagName;
  if (tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6)
    p.openElements.pop();
  p._insertElement(token, NS$2.HTML);
}
function preStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  p._insertElement(token, NS$2.HTML);
  p.skipNextNewLine = true;
  p.framesetOk = false;
}
function formStartTagInBody(p, token) {
  var inTemplate = p.openElements.tmplCount > 0;
  if (!p.formElement || inTemplate) {
    if (p.openElements.hasInButtonScope($$3.P))
      p._closePElement();
    p._insertElement(token, NS$2.HTML);
    if (!inTemplate)
      p.formElement = p.openElements.current;
  }
}
function listItemStartTagInBody(p, token) {
  p.framesetOk = false;
  var tn = token.tagName;
  for (var i2 = p.openElements.stackTop; i2 >= 0; i2--) {
    var element2 = p.openElements.items[i2], elementTn = p.treeAdapter.getTagName(element2), closeTn = null;
    if (tn === $$3.LI && elementTn === $$3.LI)
      closeTn = $$3.LI;
    else if ((tn === $$3.DD || tn === $$3.DT) && (elementTn === $$3.DD || elementTn === $$3.DT))
      closeTn = elementTn;
    if (closeTn) {
      p.openElements.generateImpliedEndTagsWithExclusion(closeTn);
      p.openElements.popUntilTagNamePopped(closeTn);
      break;
    }
    if (elementTn !== $$3.ADDRESS && elementTn !== $$3.DIV && elementTn !== $$3.P && p._isSpecialElement(element2))
      break;
  }
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  p._insertElement(token, NS$2.HTML);
}
function plaintextStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  p._insertElement(token, NS$2.HTML);
  p.tokenizer.state = Tokenizer$2.MODE.PLAINTEXT;
}
function buttonStartTagInBody(p, token) {
  if (p.openElements.hasInScope($$3.BUTTON)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped($$3.BUTTON);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
  p.framesetOk = false;
}
function aStartTagInBody(p, token) {
  var activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($$3.A);
  if (activeElementEntry) {
    callAdoptionAgency(p, token);
    p.openElements.remove(activeElementEntry.element);
    p.activeFormattingElements.removeEntry(activeElementEntry);
  }
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function bStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function nobrStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  if (p.openElements.hasInScope($$3.NOBR)) {
    callAdoptionAgency(p, token);
    p._reconstructActiveFormattingElements();
  }
  p._insertElement(token, NS$2.HTML);
  p.activeFormattingElements.pushElement(p.openElements.current, token);
}
function appletStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
  p.activeFormattingElements.insertMarker();
  p.framesetOk = false;
}
function tableStartTagInBody(p, token) {
  if (p.treeAdapter.getDocumentMode(p.document) !== HTML$2.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  p._insertElement(token, NS$2.HTML);
  p.framesetOk = false;
  p.insertionMode = IN_TABLE_MODE;
}
function areaStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS$2.HTML);
  p.framesetOk = false;
}
function inputStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._appendElement(token, NS$2.HTML);
  var inputType = Tokenizer$2.getTokenAttr(token, ATTRS.TYPE);
  if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE)
    p.framesetOk = false;
}
function paramStartTagInBody(p, token) {
  p._appendElement(token, NS$2.HTML);
}
function hrStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  if (p.openElements.currentTagName === $$3.MENUITEM)
    p.openElements.pop();
  p._appendElement(token, NS$2.HTML);
  p.framesetOk = false;
}
function imageStartTagInBody(p, token) {
  token.tagName = $$3.IMG;
  areaStartTagInBody(p, token);
}
function textareaStartTagInBody(p, token) {
  p._insertElement(token, NS$2.HTML);
  p.skipNextNewLine = true;
  p.tokenizer.state = Tokenizer$2.MODE.RCDATA;
  p.originalInsertionMode = p.insertionMode;
  p.framesetOk = false;
  p.insertionMode = TEXT_MODE;
}
function xmpStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  p._reconstructActiveFormattingElements();
  p.framesetOk = false;
  p._switchToTextParsing(token, Tokenizer$2.MODE.RAWTEXT);
}
function iframeStartTagInBody(p, token) {
  p.framesetOk = false;
  p._switchToTextParsing(token, Tokenizer$2.MODE.RAWTEXT);
}
function noembedStartTagInBody(p, token) {
  p._switchToTextParsing(token, Tokenizer$2.MODE.RAWTEXT);
}
function selectStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
  p.framesetOk = false;
  if (p.insertionMode === IN_TABLE_MODE || p.insertionMode === IN_CAPTION_MODE || p.insertionMode === IN_TABLE_BODY_MODE || p.insertionMode === IN_ROW_MODE || p.insertionMode === IN_CELL_MODE)
    p.insertionMode = IN_SELECT_IN_TABLE_MODE;
  else
    p.insertionMode = IN_SELECT_MODE;
}
function optgroupStartTagInBody(p, token) {
  if (p.openElements.currentTagName === $$3.OPTION)
    p.openElements.pop();
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
}
function rbStartTagInBody(p, token) {
  if (p.openElements.hasInScope($$3.RUBY))
    p.openElements.generateImpliedEndTags();
  p._insertElement(token, NS$2.HTML);
}
function rtStartTagInBody(p, token) {
  if (p.openElements.hasInScope($$3.RUBY))
    p.openElements.generateImpliedEndTagsWithExclusion($$3.RTC);
  p._insertElement(token, NS$2.HTML);
}
function menuitemStartTagInBody(p, token) {
  if (p.openElements.currentTagName === $$3.MENUITEM)
    p.openElements.pop();
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
}
function menuStartTagInBody(p, token) {
  if (p.openElements.hasInButtonScope($$3.P))
    p._closePElement();
  if (p.openElements.currentTagName === $$3.MENUITEM)
    p.openElements.pop();
  p._insertElement(token, NS$2.HTML);
}
function mathStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  foreignContent$1.adjustTokenMathMLAttrs(token);
  foreignContent$1.adjustTokenXMLAttrs(token);
  if (token.selfClosing)
    p._appendElement(token, NS$2.MATHML);
  else
    p._insertElement(token, NS$2.MATHML);
}
function svgStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  foreignContent$1.adjustTokenSVGAttrs(token);
  foreignContent$1.adjustTokenXMLAttrs(token);
  if (token.selfClosing)
    p._appendElement(token, NS$2.SVG);
  else
    p._insertElement(token, NS$2.SVG);
}
function genericStartTagInBody(p, token) {
  p._reconstructActiveFormattingElements();
  p._insertElement(token, NS$2.HTML);
}
function startTagInBody(p, token) {
  var tn = token.tagName;
  switch (tn.length) {
    case 1:
      if (tn === $$3.I || tn === $$3.S || tn === $$3.B || tn === $$3.U)
        bStartTagInBody(p, token);
      else if (tn === $$3.P)
        addressStartTagInBody(p, token);
      else if (tn === $$3.A)
        aStartTagInBody(p, token);
      else
        genericStartTagInBody(p, token);
      break;
    case 2:
      if (tn === $$3.DL || tn === $$3.OL || tn === $$3.UL)
        addressStartTagInBody(p, token);
      else if (tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6)
        numberedHeaderStartTagInBody(p, token);
      else if (tn === $$3.LI || tn === $$3.DD || tn === $$3.DT)
        listItemStartTagInBody(p, token);
      else if (tn === $$3.EM || tn === $$3.TT)
        bStartTagInBody(p, token);
      else if (tn === $$3.BR)
        areaStartTagInBody(p, token);
      else if (tn === $$3.HR)
        hrStartTagInBody(p, token);
      else if (tn === $$3.RB)
        rbStartTagInBody(p, token);
      else if (tn === $$3.RT || tn === $$3.RP)
        rtStartTagInBody(p, token);
      else if (tn !== $$3.TH && tn !== $$3.TD && tn !== $$3.TR)
        genericStartTagInBody(p, token);
      break;
    case 3:
      if (tn === $$3.DIV || tn === $$3.DIR || tn === $$3.NAV)
        addressStartTagInBody(p, token);
      else if (tn === $$3.PRE)
        preStartTagInBody(p, token);
      else if (tn === $$3.BIG)
        bStartTagInBody(p, token);
      else if (tn === $$3.IMG || tn === $$3.WBR)
        areaStartTagInBody(p, token);
      else if (tn === $$3.XMP)
        xmpStartTagInBody(p, token);
      else if (tn === $$3.SVG)
        svgStartTagInBody(p, token);
      else if (tn === $$3.RTC)
        rbStartTagInBody(p, token);
      else if (tn !== $$3.COL)
        genericStartTagInBody(p, token);
      break;
    case 4:
      if (tn === $$3.HTML)
        htmlStartTagInBody(p, token);
      else if (tn === $$3.BASE || tn === $$3.LINK || tn === $$3.META)
        startTagInHead(p, token);
      else if (tn === $$3.BODY)
        bodyStartTagInBody(p, token);
      else if (tn === $$3.MAIN)
        addressStartTagInBody(p, token);
      else if (tn === $$3.FORM)
        formStartTagInBody(p, token);
      else if (tn === $$3.CODE || tn === $$3.FONT)
        bStartTagInBody(p, token);
      else if (tn === $$3.NOBR)
        nobrStartTagInBody(p, token);
      else if (tn === $$3.AREA)
        areaStartTagInBody(p, token);
      else if (tn === $$3.MATH)
        mathStartTagInBody(p, token);
      else if (tn === $$3.MENU)
        menuStartTagInBody(p, token);
      else if (tn !== $$3.HEAD)
        genericStartTagInBody(p, token);
      break;
    case 5:
      if (tn === $$3.STYLE || tn === $$3.TITLE)
        startTagInHead(p, token);
      else if (tn === $$3.ASIDE)
        addressStartTagInBody(p, token);
      else if (tn === $$3.SMALL)
        bStartTagInBody(p, token);
      else if (tn === $$3.TABLE)
        tableStartTagInBody(p, token);
      else if (tn === $$3.EMBED)
        areaStartTagInBody(p, token);
      else if (tn === $$3.INPUT)
        inputStartTagInBody(p, token);
      else if (tn === $$3.PARAM || tn === $$3.TRACK)
        paramStartTagInBody(p, token);
      else if (tn === $$3.IMAGE)
        imageStartTagInBody(p, token);
      else if (tn !== $$3.FRAME && tn !== $$3.TBODY && tn !== $$3.TFOOT && tn !== $$3.THEAD)
        genericStartTagInBody(p, token);
      break;
    case 6:
      if (tn === $$3.SCRIPT)
        startTagInHead(p, token);
      else if (tn === $$3.CENTER || tn === $$3.FIGURE || tn === $$3.FOOTER || tn === $$3.HEADER || tn === $$3.HGROUP)
        addressStartTagInBody(p, token);
      else if (tn === $$3.BUTTON)
        buttonStartTagInBody(p, token);
      else if (tn === $$3.STRIKE || tn === $$3.STRONG)
        bStartTagInBody(p, token);
      else if (tn === $$3.APPLET || tn === $$3.OBJECT)
        appletStartTagInBody(p, token);
      else if (tn === $$3.KEYGEN)
        areaStartTagInBody(p, token);
      else if (tn === $$3.SOURCE)
        paramStartTagInBody(p, token);
      else if (tn === $$3.IFRAME)
        iframeStartTagInBody(p, token);
      else if (tn === $$3.SELECT)
        selectStartTagInBody(p, token);
      else if (tn === $$3.OPTION)
        optgroupStartTagInBody(p, token);
      else
        genericStartTagInBody(p, token);
      break;
    case 7:
      if (tn === $$3.BGSOUND)
        startTagInHead(p, token);
      else if (tn === $$3.DETAILS || tn === $$3.ADDRESS || tn === $$3.ARTICLE || tn === $$3.SECTION || tn === $$3.SUMMARY)
        addressStartTagInBody(p, token);
      else if (tn === $$3.LISTING)
        preStartTagInBody(p, token);
      else if (tn === $$3.MARQUEE)
        appletStartTagInBody(p, token);
      else if (tn === $$3.NOEMBED)
        noembedStartTagInBody(p, token);
      else if (tn !== $$3.CAPTION)
        genericStartTagInBody(p, token);
      break;
    case 8:
      if (tn === $$3.BASEFONT)
        startTagInHead(p, token);
      else if (tn === $$3.MENUITEM)
        menuitemStartTagInBody(p, token);
      else if (tn === $$3.FRAMESET)
        framesetStartTagInBody(p, token);
      else if (tn === $$3.FIELDSET)
        addressStartTagInBody(p, token);
      else if (tn === $$3.TEXTAREA)
        textareaStartTagInBody(p, token);
      else if (tn === $$3.TEMPLATE)
        startTagInHead(p, token);
      else if (tn === $$3.NOSCRIPT)
        noembedStartTagInBody(p, token);
      else if (tn === $$3.OPTGROUP)
        optgroupStartTagInBody(p, token);
      else if (tn !== $$3.COLGROUP)
        genericStartTagInBody(p, token);
      break;
    case 9:
      if (tn === $$3.PLAINTEXT)
        plaintextStartTagInBody(p, token);
      else
        genericStartTagInBody(p, token);
      break;
    case 10:
      if (tn === $$3.BLOCKQUOTE || tn === $$3.FIGCAPTION)
        addressStartTagInBody(p, token);
      else
        genericStartTagInBody(p, token);
      break;
    default:
      genericStartTagInBody(p, token);
  }
}
function bodyEndTagInBody(p) {
  if (p.openElements.hasInScope($$3.BODY))
    p.insertionMode = AFTER_BODY_MODE;
}
function htmlEndTagInBody(p, token) {
  if (p.openElements.hasInScope($$3.BODY)) {
    p.insertionMode = AFTER_BODY_MODE;
    p._processToken(token);
  }
}
function addressEndTagInBody(p, token) {
  var tn = token.tagName;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function formEndTagInBody(p) {
  var inTemplate = p.openElements.tmplCount > 0, formElement = p.formElement;
  if (!inTemplate)
    p.formElement = null;
  if ((formElement || inTemplate) && p.openElements.hasInScope($$3.FORM)) {
    p.openElements.generateImpliedEndTags();
    if (inTemplate)
      p.openElements.popUntilTagNamePopped($$3.FORM);
    else
      p.openElements.remove(formElement);
  }
}
function pEndTagInBody(p) {
  if (!p.openElements.hasInButtonScope($$3.P))
    p._insertFakeElement($$3.P);
  p._closePElement();
}
function liEndTagInBody(p) {
  if (p.openElements.hasInListItemScope($$3.LI)) {
    p.openElements.generateImpliedEndTagsWithExclusion($$3.LI);
    p.openElements.popUntilTagNamePopped($$3.LI);
  }
}
function ddEndTagInBody(p, token) {
  var tn = token.tagName;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTagsWithExclusion(tn);
    p.openElements.popUntilTagNamePopped(tn);
  }
}
function numberedHeaderEndTagInBody(p) {
  if (p.openElements.hasNumberedHeaderInScope()) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilNumberedHeaderPopped();
  }
}
function appletEndTagInBody(p, token) {
  var tn = token.tagName;
  if (p.openElements.hasInScope(tn)) {
    p.openElements.generateImpliedEndTags();
    p.openElements.popUntilTagNamePopped(tn);
    p.activeFormattingElements.clearToLastMarker();
  }
}
function brEndTagInBody(p) {
  p._reconstructActiveFormattingElements();
  p._insertFakeElement($$3.BR);
  p.openElements.pop();
  p.framesetOk = false;
}
function genericEndTagInBody(p, token) {
  var tn = token.tagName;
  for (var i2 = p.openElements.stackTop; i2 > 0; i2--) {
    var element2 = p.openElements.items[i2];
    if (p.treeAdapter.getTagName(element2) === tn) {
      p.openElements.generateImpliedEndTagsWithExclusion(tn);
      p.openElements.popUntilElementPopped(element2);
      break;
    }
    if (p._isSpecialElement(element2))
      break;
  }
}
function endTagInBody(p, token) {
  var tn = token.tagName;
  switch (tn.length) {
    case 1:
      if (tn === $$3.A || tn === $$3.B || tn === $$3.I || tn === $$3.S || tn === $$3.U)
        callAdoptionAgency(p, token);
      else if (tn === $$3.P)
        pEndTagInBody(p);
      else
        genericEndTagInBody(p, token);
      break;
    case 2:
      if (tn === $$3.DL || tn === $$3.UL || tn === $$3.OL)
        addressEndTagInBody(p, token);
      else if (tn === $$3.LI)
        liEndTagInBody(p);
      else if (tn === $$3.DD || tn === $$3.DT)
        ddEndTagInBody(p, token);
      else if (tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6)
        numberedHeaderEndTagInBody(p);
      else if (tn === $$3.BR)
        brEndTagInBody(p);
      else if (tn === $$3.EM || tn === $$3.TT)
        callAdoptionAgency(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 3:
      if (tn === $$3.BIG)
        callAdoptionAgency(p, token);
      else if (tn === $$3.DIR || tn === $$3.DIV || tn === $$3.NAV)
        addressEndTagInBody(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 4:
      if (tn === $$3.BODY)
        bodyEndTagInBody(p);
      else if (tn === $$3.HTML)
        htmlEndTagInBody(p, token);
      else if (tn === $$3.FORM)
        formEndTagInBody(p);
      else if (tn === $$3.CODE || tn === $$3.FONT || tn === $$3.NOBR)
        callAdoptionAgency(p, token);
      else if (tn === $$3.MAIN || tn === $$3.MENU)
        addressEndTagInBody(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 5:
      if (tn === $$3.ASIDE)
        addressEndTagInBody(p, token);
      else if (tn === $$3.SMALL)
        callAdoptionAgency(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 6:
      if (tn === $$3.CENTER || tn === $$3.FIGURE || tn === $$3.FOOTER || tn === $$3.HEADER || tn === $$3.HGROUP)
        addressEndTagInBody(p, token);
      else if (tn === $$3.APPLET || tn === $$3.OBJECT)
        appletEndTagInBody(p, token);
      else if (tn === $$3.STRIKE || tn === $$3.STRONG)
        callAdoptionAgency(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 7:
      if (tn === $$3.ADDRESS || tn === $$3.ARTICLE || tn === $$3.DETAILS || tn === $$3.SECTION || tn === $$3.SUMMARY)
        addressEndTagInBody(p, token);
      else if (tn === $$3.MARQUEE)
        appletEndTagInBody(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 8:
      if (tn === $$3.FIELDSET)
        addressEndTagInBody(p, token);
      else if (tn === $$3.TEMPLATE)
        endTagInHead(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    case 10:
      if (tn === $$3.BLOCKQUOTE || tn === $$3.FIGCAPTION)
        addressEndTagInBody(p, token);
      else
        genericEndTagInBody(p, token);
      break;
    default:
      genericEndTagInBody(p, token);
  }
}
function eofInBody(p, token) {
  if (p.tmplInsertionModeStackTop > -1)
    eofInTemplate(p, token);
  else
    p.stopped = true;
}
function endTagInText(p, token) {
  if (token.tagName === $$3.SCRIPT)
    p.pendingScript = p.openElements.current;
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
}
function eofInText(p, token) {
  p.openElements.pop();
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
function characterInTable(p, token) {
  var curTn = p.openElements.currentTagName;
  if (curTn === $$3.TABLE || curTn === $$3.TBODY || curTn === $$3.TFOOT || curTn === $$3.THEAD || curTn === $$3.TR) {
    p.pendingCharacterTokens = [];
    p.hasNonWhitespacePendingCharacterToken = false;
    p.originalInsertionMode = p.insertionMode;
    p.insertionMode = IN_TABLE_TEXT_MODE;
    p._processToken(token);
  } else
    tokenInTable(p, token);
}
function captionStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p.activeFormattingElements.insertMarker();
  p._insertElement(token, NS$2.HTML);
  p.insertionMode = IN_CAPTION_MODE;
}
function colgroupStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS$2.HTML);
  p.insertionMode = IN_COLUMN_GROUP_MODE;
}
function colStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement($$3.COLGROUP);
  p.insertionMode = IN_COLUMN_GROUP_MODE;
  p._processToken(token);
}
function tbodyStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertElement(token, NS$2.HTML);
  p.insertionMode = IN_TABLE_BODY_MODE;
}
function tdStartTagInTable(p, token) {
  p.openElements.clearBackToTableContext();
  p._insertFakeElement($$3.TBODY);
  p.insertionMode = IN_TABLE_BODY_MODE;
  p._processToken(token);
}
function tableStartTagInTable(p, token) {
  if (p.openElements.hasInTableScope($$3.TABLE)) {
    p.openElements.popUntilTagNamePopped($$3.TABLE);
    p._resetInsertionMode();
    p._processToken(token);
  }
}
function inputStartTagInTable(p, token) {
  var inputType = Tokenizer$2.getTokenAttr(token, ATTRS.TYPE);
  if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE)
    p._appendElement(token, NS$2.HTML);
  else
    tokenInTable(p, token);
}
function formStartTagInTable(p, token) {
  if (!p.formElement && p.openElements.tmplCount === 0) {
    p._insertElement(token, NS$2.HTML);
    p.formElement = p.openElements.current;
    p.openElements.pop();
  }
}
function startTagInTable(p, token) {
  var tn = token.tagName;
  switch (tn.length) {
    case 2:
      if (tn === $$3.TD || tn === $$3.TH || tn === $$3.TR)
        tdStartTagInTable(p, token);
      else
        tokenInTable(p, token);
      break;
    case 3:
      if (tn === $$3.COL)
        colStartTagInTable(p, token);
      else
        tokenInTable(p, token);
      break;
    case 4:
      if (tn === $$3.FORM)
        formStartTagInTable(p, token);
      else
        tokenInTable(p, token);
      break;
    case 5:
      if (tn === $$3.TABLE)
        tableStartTagInTable(p, token);
      else if (tn === $$3.STYLE)
        startTagInHead(p, token);
      else if (tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD)
        tbodyStartTagInTable(p, token);
      else if (tn === $$3.INPUT)
        inputStartTagInTable(p, token);
      else
        tokenInTable(p, token);
      break;
    case 6:
      if (tn === $$3.SCRIPT)
        startTagInHead(p, token);
      else
        tokenInTable(p, token);
      break;
    case 7:
      if (tn === $$3.CAPTION)
        captionStartTagInTable(p, token);
      else
        tokenInTable(p, token);
      break;
    case 8:
      if (tn === $$3.COLGROUP)
        colgroupStartTagInTable(p, token);
      else if (tn === $$3.TEMPLATE)
        startTagInHead(p, token);
      else
        tokenInTable(p, token);
      break;
    default:
      tokenInTable(p, token);
  }
}
function endTagInTable(p, token) {
  var tn = token.tagName;
  if (tn === $$3.TABLE) {
    if (p.openElements.hasInTableScope($$3.TABLE)) {
      p.openElements.popUntilTagNamePopped($$3.TABLE);
      p._resetInsertionMode();
    }
  } else if (tn === $$3.TEMPLATE)
    endTagInHead(p, token);
  else if (tn !== $$3.BODY && tn !== $$3.CAPTION && tn !== $$3.COL && tn !== $$3.COLGROUP && tn !== $$3.HTML && tn !== $$3.TBODY && tn !== $$3.TD && tn !== $$3.TFOOT && tn !== $$3.TH && tn !== $$3.THEAD && tn !== $$3.TR)
    tokenInTable(p, token);
}
function tokenInTable(p, token) {
  var savedFosterParentingState = p.fosterParentingEnabled;
  p.fosterParentingEnabled = true;
  p._processTokenInBodyMode(token);
  p.fosterParentingEnabled = savedFosterParentingState;
}
function whitespaceCharacterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
}
function characterInTableText(p, token) {
  p.pendingCharacterTokens.push(token);
  p.hasNonWhitespacePendingCharacterToken = true;
}
function tokenInTableText(p, token) {
  var i2 = 0;
  if (p.hasNonWhitespacePendingCharacterToken) {
    for (; i2 < p.pendingCharacterTokens.length; i2++)
      tokenInTable(p, p.pendingCharacterTokens[i2]);
  } else {
    for (; i2 < p.pendingCharacterTokens.length; i2++)
      p._insertCharacters(p.pendingCharacterTokens[i2]);
  }
  p.insertionMode = p.originalInsertionMode;
  p._processToken(token);
}
function startTagInCaption(p, token) {
  var tn = token.tagName;
  if (tn === $$3.CAPTION || tn === $$3.COL || tn === $$3.COLGROUP || tn === $$3.TBODY || tn === $$3.TD || tn === $$3.TFOOT || tn === $$3.TH || tn === $$3.THEAD || tn === $$3.TR) {
    if (p.openElements.hasInTableScope($$3.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped($$3.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = IN_TABLE_MODE;
      p._processToken(token);
    }
  } else
    startTagInBody(p, token);
}
function endTagInCaption(p, token) {
  var tn = token.tagName;
  if (tn === $$3.CAPTION || tn === $$3.TABLE) {
    if (p.openElements.hasInTableScope($$3.CAPTION)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped($$3.CAPTION);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = IN_TABLE_MODE;
      if (tn === $$3.TABLE)
        p._processToken(token);
    }
  } else if (tn !== $$3.BODY && tn !== $$3.COL && tn !== $$3.COLGROUP && tn !== $$3.HTML && tn !== $$3.TBODY && tn !== $$3.TD && tn !== $$3.TFOOT && tn !== $$3.TH && tn !== $$3.THEAD && tn !== $$3.TR)
    endTagInBody(p, token);
}
function startTagInColumnGroup(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.COL)
    p._appendElement(token, NS$2.HTML);
  else if (tn === $$3.TEMPLATE)
    startTagInHead(p, token);
  else
    tokenInColumnGroup(p, token);
}
function endTagInColumnGroup(p, token) {
  var tn = token.tagName;
  if (tn === $$3.COLGROUP) {
    if (p.openElements.currentTagName === $$3.COLGROUP) {
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
    }
  } else if (tn === $$3.TEMPLATE)
    endTagInHead(p, token);
  else if (tn !== $$3.COL)
    tokenInColumnGroup(p, token);
}
function tokenInColumnGroup(p, token) {
  if (p.openElements.currentTagName === $$3.COLGROUP) {
    p.openElements.pop();
    p.insertionMode = IN_TABLE_MODE;
    p._processToken(token);
  }
}
function startTagInTableBody(p, token) {
  var tn = token.tagName;
  if (tn === $$3.TR) {
    p.openElements.clearBackToTableBodyContext();
    p._insertElement(token, NS$2.HTML);
    p.insertionMode = IN_ROW_MODE;
  } else if (tn === $$3.TH || tn === $$3.TD) {
    p.openElements.clearBackToTableBodyContext();
    p._insertFakeElement($$3.TR);
    p.insertionMode = IN_ROW_MODE;
    p._processToken(token);
  } else if (tn === $$3.CAPTION || tn === $$3.COL || tn === $$3.COLGROUP || tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD) {
    if (p.openElements.hasTableBodyContextInTableScope()) {
      p.openElements.clearBackToTableBodyContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
      p._processToken(token);
    }
  } else
    startTagInTable(p, token);
}
function endTagInTableBody(p, token) {
  var tn = token.tagName;
  if (tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.clearBackToTableBodyContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
    }
  } else if (tn === $$3.TABLE) {
    if (p.openElements.hasTableBodyContextInTableScope()) {
      p.openElements.clearBackToTableBodyContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_MODE;
      p._processToken(token);
    }
  } else if (tn !== $$3.BODY && tn !== $$3.CAPTION && tn !== $$3.COL && tn !== $$3.COLGROUP || tn !== $$3.HTML && tn !== $$3.TD && tn !== $$3.TH && tn !== $$3.TR)
    endTagInTable(p, token);
}
function startTagInRow(p, token) {
  var tn = token.tagName;
  if (tn === $$3.TH || tn === $$3.TD) {
    p.openElements.clearBackToTableRowContext();
    p._insertElement(token, NS$2.HTML);
    p.insertionMode = IN_CELL_MODE;
    p.activeFormattingElements.insertMarker();
  } else if (tn === $$3.CAPTION || tn === $$3.COL || tn === $$3.COLGROUP || tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD || tn === $$3.TR) {
    if (p.openElements.hasInTableScope($$3.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
      p._processToken(token);
    }
  } else
    startTagInTable(p, token);
}
function endTagInRow(p, token) {
  var tn = token.tagName;
  if (tn === $$3.TR) {
    if (p.openElements.hasInTableScope($$3.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
    }
  } else if (tn === $$3.TABLE) {
    if (p.openElements.hasInTableScope($$3.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
      p._processToken(token);
    }
  } else if (tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD) {
    if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($$3.TR)) {
      p.openElements.clearBackToTableRowContext();
      p.openElements.pop();
      p.insertionMode = IN_TABLE_BODY_MODE;
      p._processToken(token);
    }
  } else if (tn !== $$3.BODY && tn !== $$3.CAPTION && tn !== $$3.COL && tn !== $$3.COLGROUP || tn !== $$3.HTML && tn !== $$3.TD && tn !== $$3.TH)
    endTagInTable(p, token);
}
function startTagInCell(p, token) {
  var tn = token.tagName;
  if (tn === $$3.CAPTION || tn === $$3.COL || tn === $$3.COLGROUP || tn === $$3.TBODY || tn === $$3.TD || tn === $$3.TFOOT || tn === $$3.TH || tn === $$3.THEAD || tn === $$3.TR) {
    if (p.openElements.hasInTableScope($$3.TD) || p.openElements.hasInTableScope($$3.TH)) {
      p._closeTableCell();
      p._processToken(token);
    }
  } else
    startTagInBody(p, token);
}
function endTagInCell(p, token) {
  var tn = token.tagName;
  if (tn === $$3.TD || tn === $$3.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.generateImpliedEndTags();
      p.openElements.popUntilTagNamePopped(tn);
      p.activeFormattingElements.clearToLastMarker();
      p.insertionMode = IN_ROW_MODE;
    }
  } else if (tn === $$3.TABLE || tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD || tn === $$3.TR) {
    if (p.openElements.hasInTableScope(tn)) {
      p._closeTableCell();
      p._processToken(token);
    }
  } else if (tn !== $$3.BODY && tn !== $$3.CAPTION && tn !== $$3.COL && tn !== $$3.COLGROUP && tn !== $$3.HTML)
    endTagInBody(p, token);
}
function startTagInSelect(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.OPTION) {
    if (p.openElements.currentTagName === $$3.OPTION)
      p.openElements.pop();
    p._insertElement(token, NS$2.HTML);
  } else if (tn === $$3.OPTGROUP) {
    if (p.openElements.currentTagName === $$3.OPTION)
      p.openElements.pop();
    if (p.openElements.currentTagName === $$3.OPTGROUP)
      p.openElements.pop();
    p._insertElement(token, NS$2.HTML);
  } else if (tn === $$3.INPUT || tn === $$3.KEYGEN || tn === $$3.TEXTAREA || tn === $$3.SELECT) {
    if (p.openElements.hasInSelectScope($$3.SELECT)) {
      p.openElements.popUntilTagNamePopped($$3.SELECT);
      p._resetInsertionMode();
      if (tn !== $$3.SELECT)
        p._processToken(token);
    }
  } else if (tn === $$3.SCRIPT || tn === $$3.TEMPLATE)
    startTagInHead(p, token);
}
function endTagInSelect(p, token) {
  var tn = token.tagName;
  if (tn === $$3.OPTGROUP) {
    var prevOpenElement = p.openElements.items[p.openElements.stackTop - 1], prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);
    if (p.openElements.currentTagName === $$3.OPTION && prevOpenElementTn === $$3.OPTGROUP)
      p.openElements.pop();
    if (p.openElements.currentTagName === $$3.OPTGROUP)
      p.openElements.pop();
  } else if (tn === $$3.OPTION) {
    if (p.openElements.currentTagName === $$3.OPTION)
      p.openElements.pop();
  } else if (tn === $$3.SELECT && p.openElements.hasInSelectScope($$3.SELECT)) {
    p.openElements.popUntilTagNamePopped($$3.SELECT);
    p._resetInsertionMode();
  } else if (tn === $$3.TEMPLATE)
    endTagInHead(p, token);
}
function startTagInSelectInTable(p, token) {
  var tn = token.tagName;
  if (tn === $$3.CAPTION || tn === $$3.TABLE || tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD || tn === $$3.TR || tn === $$3.TD || tn === $$3.TH) {
    p.openElements.popUntilTagNamePopped($$3.SELECT);
    p._resetInsertionMode();
    p._processToken(token);
  } else
    startTagInSelect(p, token);
}
function endTagInSelectInTable(p, token) {
  var tn = token.tagName;
  if (tn === $$3.CAPTION || tn === $$3.TABLE || tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD || tn === $$3.TR || tn === $$3.TD || tn === $$3.TH) {
    if (p.openElements.hasInTableScope(tn)) {
      p.openElements.popUntilTagNamePopped($$3.SELECT);
      p._resetInsertionMode();
      p._processToken(token);
    }
  } else
    endTagInSelect(p, token);
}
function startTagInTemplate(p, token) {
  var tn = token.tagName;
  if (tn === $$3.BASE || tn === $$3.BASEFONT || tn === $$3.BGSOUND || tn === $$3.LINK || tn === $$3.META || tn === $$3.NOFRAMES || tn === $$3.SCRIPT || tn === $$3.STYLE || tn === $$3.TEMPLATE || tn === $$3.TITLE)
    startTagInHead(p, token);
  else {
    var newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
    p._popTmplInsertionMode();
    p._pushTmplInsertionMode(newInsertionMode);
    p.insertionMode = newInsertionMode;
    p._processToken(token);
  }
}
function endTagInTemplate(p, token) {
  if (token.tagName === $$3.TEMPLATE)
    endTagInHead(p, token);
}
function eofInTemplate(p, token) {
  if (p.openElements.tmplCount > 0) {
    p.openElements.popUntilTagNamePopped($$3.TEMPLATE);
    p.activeFormattingElements.clearToLastMarker();
    p._popTmplInsertionMode();
    p._resetInsertionMode();
    p._processToken(token);
  } else
    p.stopped = true;
}
function startTagAfterBody(p, token) {
  if (token.tagName === $$3.HTML)
    startTagInBody(p, token);
  else
    tokenAfterBody(p, token);
}
function endTagAfterBody(p, token) {
  if (token.tagName === $$3.HTML) {
    if (!p.fragmentContext)
      p.insertionMode = AFTER_AFTER_BODY_MODE;
  } else
    tokenAfterBody(p, token);
}
function tokenAfterBody(p, token) {
  p.insertionMode = IN_BODY_MODE;
  p._processToken(token);
}
function startTagInFrameset(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.FRAMESET)
    p._insertElement(token, NS$2.HTML);
  else if (tn === $$3.FRAME)
    p._appendElement(token, NS$2.HTML);
  else if (tn === $$3.NOFRAMES)
    startTagInHead(p, token);
}
function endTagInFrameset(p, token) {
  if (token.tagName === $$3.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
    p.openElements.pop();
    if (!p.fragmentContext && p.openElements.currentTagName !== $$3.FRAMESET)
      p.insertionMode = AFTER_FRAMESET_MODE;
  }
}
function startTagAfterFrameset(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.NOFRAMES)
    startTagInHead(p, token);
}
function endTagAfterFrameset(p, token) {
  if (token.tagName === $$3.HTML)
    p.insertionMode = AFTER_AFTER_FRAMESET_MODE;
}
function startTagAfterAfterBody(p, token) {
  if (token.tagName === $$3.HTML)
    startTagInBody(p, token);
  else
    tokenAfterAfterBody(p, token);
}
function tokenAfterAfterBody(p, token) {
  p.insertionMode = IN_BODY_MODE;
  p._processToken(token);
}
function startTagAfterAfterFrameset(p, token) {
  var tn = token.tagName;
  if (tn === $$3.HTML)
    startTagInBody(p, token);
  else if (tn === $$3.NOFRAMES)
    startTagInHead(p, token);
}
function nullCharacterInForeignContent(p, token) {
  token.chars = UNICODE$1.REPLACEMENT_CHARACTER;
  p._insertCharacters(token);
}
function characterInForeignContent(p, token) {
  p._insertCharacters(token);
  p.framesetOk = false;
}
function startTagInForeignContent(p, token) {
  if (foreignContent$1.causesExit(token) && !p.fragmentContext) {
    while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS$2.HTML && !p._isIntegrationPoint(p.openElements.current))
      p.openElements.pop();
    p._processToken(token);
  } else {
    var current = p._getAdjustedCurrentElement(), currentNs = p.treeAdapter.getNamespaceURI(current);
    if (currentNs === NS$2.MATHML)
      foreignContent$1.adjustTokenMathMLAttrs(token);
    else if (currentNs === NS$2.SVG) {
      foreignContent$1.adjustTokenSVGTagName(token);
      foreignContent$1.adjustTokenSVGAttrs(token);
    }
    foreignContent$1.adjustTokenXMLAttrs(token);
    if (token.selfClosing)
      p._appendElement(token, currentNs);
    else
      p._insertElement(token, currentNs);
  }
}
function endTagInForeignContent(p, token) {
  for (var i2 = p.openElements.stackTop; i2 > 0; i2--) {
    var element2 = p.openElements.items[i2];
    if (p.treeAdapter.getNamespaceURI(element2) === NS$2.HTML) {
      p._processToken(token);
      break;
    }
    if (p.treeAdapter.getTagName(element2).toLowerCase() === token.tagName) {
      p.openElements.popUntilElementPopped(element2);
      break;
    }
  }
}
var serializerExports = {};
var serializer = {
  get exports() {
    return serializerExports;
  },
  set exports(v) {
    serializerExports = v;
  }
};
var defaultTreeAdapter = _default, mergeOptions$1 = merge_options, doctype$1 = doctype$3, HTML$1 = html;
var $$2 = HTML$1.TAG_NAMES, NS$1 = HTML$1.NAMESPACES;
var DEFAULT_OPTIONS$1 = {
  treeAdapter: defaultTreeAdapter
};
var AMP_REGEX = /&/g, NBSP_REGEX = /\u00a0/g, DOUBLE_QUOTE_REGEX = /"/g, LT_REGEX = /</g, GT_REGEX = />/g;
var Serializer$2 = serializer.exports = function(node2, options2) {
  this.options = mergeOptions$1(DEFAULT_OPTIONS$1, options2);
  this.treeAdapter = this.options.treeAdapter;
  this.html = "";
  this.startNode = node2;
};
Serializer$2.escapeString = function(str, attrMode) {
  str = str.replace(AMP_REGEX, "&amp;").replace(NBSP_REGEX, "&nbsp;");
  if (attrMode)
    str = str.replace(DOUBLE_QUOTE_REGEX, "&quot;");
  else {
    str = str.replace(LT_REGEX, "&lt;").replace(GT_REGEX, "&gt;");
  }
  return str;
};
Serializer$2.prototype.serialize = function() {
  this._serializeChildNodes(this.startNode);
  return this.html;
};
Serializer$2.prototype._serializeChildNodes = function(parentNode) {
  var childNodes = this.treeAdapter.getChildNodes(parentNode);
  if (childNodes) {
    for (var i2 = 0, cnLength = childNodes.length; i2 < cnLength; i2++) {
      var currentNode = childNodes[i2];
      if (this.treeAdapter.isElementNode(currentNode))
        this._serializeElement(currentNode);
      else if (this.treeAdapter.isTextNode(currentNode))
        this._serializeTextNode(currentNode);
      else if (this.treeAdapter.isCommentNode(currentNode))
        this._serializeCommentNode(currentNode);
      else if (this.treeAdapter.isDocumentTypeNode(currentNode))
        this._serializeDocumentTypeNode(currentNode);
    }
  }
};
Serializer$2.prototype._serializeElement = function(node2) {
  var tn = this.treeAdapter.getTagName(node2), ns = this.treeAdapter.getNamespaceURI(node2);
  this.html += "<" + tn;
  this._serializeAttributes(node2);
  this.html += ">";
  if (tn !== $$2.AREA && tn !== $$2.BASE && tn !== $$2.BASEFONT && tn !== $$2.BGSOUND && tn !== $$2.BR && tn !== $$2.BR && tn !== $$2.COL && tn !== $$2.EMBED && tn !== $$2.FRAME && tn !== $$2.HR && tn !== $$2.IMG && tn !== $$2.INPUT && tn !== $$2.KEYGEN && tn !== $$2.LINK && tn !== $$2.MENUITEM && tn !== $$2.META && tn !== $$2.PARAM && tn !== $$2.SOURCE && tn !== $$2.TRACK && tn !== $$2.WBR) {
    var childNodesHolder = tn === $$2.TEMPLATE && ns === NS$1.HTML ? this.treeAdapter.getTemplateContent(node2) : node2;
    this._serializeChildNodes(childNodesHolder);
    this.html += "</" + tn + ">";
  }
};
Serializer$2.prototype._serializeAttributes = function(node2) {
  var attrs = this.treeAdapter.getAttrList(node2);
  for (var i2 = 0, attrsLength = attrs.length; i2 < attrsLength; i2++) {
    var attr2 = attrs[i2], value = Serializer$2.escapeString(attr2.value, true);
    this.html += " ";
    if (!attr2.namespace)
      this.html += attr2.name;
    else if (attr2.namespace === NS$1.XML)
      this.html += "xml:" + attr2.name;
    else if (attr2.namespace === NS$1.XMLNS) {
      if (attr2.name !== "xmlns")
        this.html += "xmlns:";
      this.html += attr2.name;
    } else if (attr2.namespace === NS$1.XLINK)
      this.html += "xlink:" + attr2.name;
    else
      this.html += attr2.namespace + ":" + attr2.name;
    this.html += '="' + value + '"';
  }
};
Serializer$2.prototype._serializeTextNode = function(node2) {
  var content = this.treeAdapter.getTextNodeContent(node2), parent2 = this.treeAdapter.getParentNode(node2), parentTn = void 0;
  if (parent2 && this.treeAdapter.isElementNode(parent2))
    parentTn = this.treeAdapter.getTagName(parent2);
  if (parentTn === $$2.STYLE || parentTn === $$2.SCRIPT || parentTn === $$2.XMP || parentTn === $$2.IFRAME || parentTn === $$2.NOEMBED || parentTn === $$2.NOFRAMES || parentTn === $$2.PLAINTEXT || parentTn === $$2.NOSCRIPT)
    this.html += content;
  else
    this.html += Serializer$2.escapeString(content, false);
};
Serializer$2.prototype._serializeCommentNode = function(node2) {
  this.html += "<!--" + this.treeAdapter.getCommentNodeContent(node2) + "-->";
};
Serializer$2.prototype._serializeDocumentTypeNode = function(node2) {
  var name2 = this.treeAdapter.getDocumentTypeNodeName(node2);
  this.html += "<" + doctype$1.serializeContent(name2, null, null) + ">";
};
var htmlparser2 = {};
var doctype = doctype$3, DOCUMENT_MODE = html.DOCUMENT_MODE;
var nodeTypes = {
  element: 1,
  text: 3,
  cdata: 4,
  comment: 8
};
var nodePropertyShorthands = {
  tagName: "name",
  childNodes: "children",
  parentNode: "parent",
  previousSibling: "prev",
  nextSibling: "next",
  nodeValue: "data"
};
var Node2 = function(props) {
  for (var key in props) {
    if (props.hasOwnProperty(key))
      this[key] = props[key];
  }
};
Node2.prototype = {
  get firstChild() {
    var children2 = this.children;
    return children2 && children2[0] || null;
  },
  get lastChild() {
    var children2 = this.children;
    return children2 && children2[children2.length - 1] || null;
  },
  get nodeType() {
    return nodeTypes[this.type] || nodeTypes.element;
  }
};
Object.keys(nodePropertyShorthands).forEach(function(key) {
  var shorthand = nodePropertyShorthands[key];
  Object.defineProperty(Node2.prototype, key, {
    get: function() {
      return this[shorthand] || null;
    },
    set: function(val2) {
      this[shorthand] = val2;
      return val2;
    }
  });
});
htmlparser2.createDocument = function() {
  return new Node2({
    type: "root",
    name: "root",
    parent: null,
    prev: null,
    next: null,
    children: [],
    "x-mode": DOCUMENT_MODE.NO_QUIRKS
  });
};
htmlparser2.createDocumentFragment = function() {
  return new Node2({
    type: "root",
    name: "root",
    parent: null,
    prev: null,
    next: null,
    children: []
  });
};
htmlparser2.createElement = function(tagName, namespaceURI, attrs) {
  var attribs = /* @__PURE__ */ Object.create(null), attribsNamespace = /* @__PURE__ */ Object.create(null), attribsPrefix = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0; i2 < attrs.length; i2++) {
    var attrName = attrs[i2].name;
    attribs[attrName] = attrs[i2].value;
    attribsNamespace[attrName] = attrs[i2].namespace;
    attribsPrefix[attrName] = attrs[i2].prefix;
  }
  return new Node2({
    type: tagName === "script" || tagName === "style" ? tagName : "tag",
    name: tagName,
    namespace: namespaceURI,
    attribs,
    "x-attribsNamespace": attribsNamespace,
    "x-attribsPrefix": attribsPrefix,
    children: [],
    parent: null,
    prev: null,
    next: null
  });
};
htmlparser2.createCommentNode = function(data2) {
  return new Node2({
    type: "comment",
    data: data2,
    parent: null,
    prev: null,
    next: null
  });
};
var createTextNode = function(value) {
  return new Node2({
    type: "text",
    data: value,
    parent: null,
    prev: null,
    next: null
  });
};
var appendChild = htmlparser2.appendChild = function(parentNode, newNode) {
  var prev2 = parentNode.children[parentNode.children.length - 1];
  if (prev2) {
    prev2.next = newNode;
    newNode.prev = prev2;
  }
  parentNode.children.push(newNode);
  newNode.parent = parentNode;
};
var insertBefore = htmlparser2.insertBefore = function(parentNode, newNode, referenceNode) {
  var insertionIdx = parentNode.children.indexOf(referenceNode), prev2 = referenceNode.prev;
  if (prev2) {
    prev2.next = newNode;
    newNode.prev = prev2;
  }
  referenceNode.prev = newNode;
  newNode.next = referenceNode;
  parentNode.children.splice(insertionIdx, 0, newNode);
  newNode.parent = parentNode;
};
htmlparser2.setTemplateContent = function(templateElement, contentElement) {
  appendChild(templateElement, contentElement);
};
htmlparser2.getTemplateContent = function(templateElement) {
  return templateElement.children[0];
};
htmlparser2.setDocumentType = function(document, name2, publicId, systemId) {
  var data2 = doctype.serializeContent(name2, publicId, systemId), doctypeNode = null;
  for (var i2 = 0; i2 < document.children.length; i2++) {
    if (document.children[i2].type === "directive" && document.children[i2].name === "!doctype") {
      doctypeNode = document.children[i2];
      break;
    }
  }
  if (doctypeNode) {
    doctypeNode.data = data2;
    doctypeNode["x-name"] = name2;
    doctypeNode["x-publicId"] = publicId;
    doctypeNode["x-systemId"] = systemId;
  } else {
    appendChild(document, new Node2({
      type: "directive",
      name: "!doctype",
      data: data2,
      "x-name": name2,
      "x-publicId": publicId,
      "x-systemId": systemId
    }));
  }
};
htmlparser2.setDocumentMode = function(document, mode) {
  document["x-mode"] = mode;
};
htmlparser2.getDocumentMode = function(document) {
  return document["x-mode"];
};
htmlparser2.detachNode = function(node2) {
  if (node2.parent) {
    var idx = node2.parent.children.indexOf(node2), prev2 = node2.prev, next2 = node2.next;
    node2.prev = null;
    node2.next = null;
    if (prev2)
      prev2.next = next2;
    if (next2)
      next2.prev = prev2;
    node2.parent.children.splice(idx, 1);
    node2.parent = null;
  }
};
htmlparser2.insertText = function(parentNode, text2) {
  var lastChild = parentNode.children[parentNode.children.length - 1];
  if (lastChild && lastChild.type === "text")
    lastChild.data += text2;
  else
    appendChild(parentNode, createTextNode(text2));
};
htmlparser2.insertTextBefore = function(parentNode, text2, referenceNode) {
  var prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
  if (prevNode && prevNode.type === "text")
    prevNode.data += text2;
  else
    insertBefore(parentNode, createTextNode(text2), referenceNode);
};
htmlparser2.adoptAttributes = function(recipient, attrs) {
  for (var i2 = 0; i2 < attrs.length; i2++) {
    var attrName = attrs[i2].name;
    if (typeof recipient.attribs[attrName] === "undefined") {
      recipient.attribs[attrName] = attrs[i2].value;
      recipient["x-attribsNamespace"][attrName] = attrs[i2].namespace;
      recipient["x-attribsPrefix"][attrName] = attrs[i2].prefix;
    }
  }
};
htmlparser2.getFirstChild = function(node2) {
  return node2.children[0];
};
htmlparser2.getChildNodes = function(node2) {
  return node2.children;
};
htmlparser2.getParentNode = function(node2) {
  return node2.parent;
};
htmlparser2.getAttrList = function(element2) {
  var attrList = [];
  for (var name2 in element2.attribs) {
    attrList.push({
      name: name2,
      value: element2.attribs[name2],
      namespace: element2["x-attribsNamespace"][name2],
      prefix: element2["x-attribsPrefix"][name2]
    });
  }
  return attrList;
};
htmlparser2.getTagName = function(element2) {
  return element2.name;
};
htmlparser2.getNamespaceURI = function(element2) {
  return element2.namespace;
};
htmlparser2.getTextNodeContent = function(textNode) {
  return textNode.data;
};
htmlparser2.getCommentNodeContent = function(commentNode) {
  return commentNode.data;
};
htmlparser2.getDocumentTypeNodeName = function(doctypeNode) {
  return doctypeNode["x-name"];
};
htmlparser2.getDocumentTypeNodePublicId = function(doctypeNode) {
  return doctypeNode["x-publicId"];
};
htmlparser2.getDocumentTypeNodeSystemId = function(doctypeNode) {
  return doctypeNode["x-systemId"];
};
htmlparser2.isTextNode = function(node2) {
  return node2.type === "text";
};
htmlparser2.isCommentNode = function(node2) {
  return node2.type === "comment";
};
htmlparser2.isDocumentTypeNode = function(node2) {
  return node2.type === "directive" && node2.name === "!doctype";
};
htmlparser2.isElementNode = function(node2) {
  return !!node2.attribs;
};
var parser_streamExports = {};
var parser_stream = {
  get exports() {
    return parser_streamExports;
  },
  set exports(v) {
    parser_streamExports = v;
  }
};
var WritableStream$1 = require$$0$2.Writable, inherits$3 = require$$1$3.inherits, Parser$1 = parserExports;
var ParserStream$1 = parser_stream.exports = function(options2) {
  WritableStream$1.call(this);
  this.parser = new Parser$1(options2);
  this.lastChunkWritten = false;
  this.writeCallback = null;
  this.pausedByScript = false;
  this.document = this.parser.treeAdapter.createDocument();
  this.pendingHtmlInsertions = [];
  this._resume = this._resume.bind(this);
  this._documentWrite = this._documentWrite.bind(this);
  this._scriptHandler = this._scriptHandler.bind(this);
  this.parser._bootstrap(this.document, null);
};
inherits$3(ParserStream$1, WritableStream$1);
ParserStream$1.prototype._write = function(chunk, encoding, callback) {
  this.writeCallback = callback;
  this.parser.tokenizer.write(chunk.toString("utf8"), this.lastChunkWritten);
  this._runParsingLoop();
};
ParserStream$1.prototype.end = function(chunk, encoding, callback) {
  this.lastChunkWritten = true;
  WritableStream$1.prototype.end.call(this, chunk || "", encoding, callback);
};
ParserStream$1.prototype._runParsingLoop = function() {
  this.parser.runParsingLoopForCurrentChunk(this.writeCallback, this._scriptHandler);
};
ParserStream$1.prototype._resume = function() {
  if (!this.pausedByScript)
    throw new Error("Parser was already resumed");
  while (this.pendingHtmlInsertions.length) {
    var html2 = this.pendingHtmlInsertions.pop();
    this.parser.tokenizer.insertHtmlAtCurrentPos(html2);
  }
  this.pausedByScript = false;
  if (this.parser.tokenizer.active)
    this._runParsingLoop();
};
ParserStream$1.prototype._documentWrite = function(html2) {
  if (!this.parser.stopped)
    this.pendingHtmlInsertions.push(html2);
};
ParserStream$1.prototype._scriptHandler = function(scriptElement) {
  if (this.listeners("script").length) {
    this.pausedByScript = true;
    this.emit("script", scriptElement, this._documentWrite, this._resume);
  } else
    this._runParsingLoop();
};
var plain_text_conversion_streamExports = {};
var plain_text_conversion_stream = {
  get exports() {
    return plain_text_conversion_streamExports;
  },
  set exports(v) {
    plain_text_conversion_streamExports = v;
  }
};
var ParserStream = parser_streamExports, inherits$2 = require$$1$3.inherits, $$1 = html.TAG_NAMES;
var PlainTextConversionStream = plain_text_conversion_stream.exports = function(options2) {
  ParserStream.call(this, options2);
  this.parser._insertFakeElement($$1.HTML);
  this.parser._insertFakeElement($$1.HEAD);
  this.parser.openElements.pop();
  this.parser._insertFakeElement($$1.BODY);
  this.parser._insertFakeElement($$1.PRE);
  this.parser.treeAdapter.insertText(this.parser.openElements.current, "\n");
  this.parser.switchToPlaintextParsing();
};
inherits$2(PlainTextConversionStream, ParserStream);
var serializer_streamExports = {};
var serializer_stream = {
  get exports() {
    return serializer_streamExports;
  },
  set exports(v) {
    serializer_streamExports = v;
  }
};
var ReadableStream = require$$0$2.Readable, inherits$1 = require$$1$3.inherits, Serializer$1 = serializerExports;
var SerializerStream = serializer_stream.exports = function(node2, options2) {
  ReadableStream.call(this);
  this.serializer = new Serializer$1(node2, options2);
  Object.defineProperty(this.serializer, "html", {
    //NOTE: To make `+=` concat operator work properly we define
    //getter which always returns empty string
    get: function() {
      return "";
    },
    set: this.push.bind(this)
  });
};
inherits$1(SerializerStream, ReadableStream);
SerializerStream.prototype._read = function() {
  this.serializer.serialize();
  this.push(null);
};
var saxExports = {};
var sax = {
  get exports() {
    return saxExports;
  },
  set exports(v) {
    saxExports = v;
  }
};
var dev_null_streamExports = {};
var dev_null_stream = {
  get exports() {
    return dev_null_streamExports;
  },
  set exports(v) {
    dev_null_streamExports = v;
  }
};
var WritableStream = require$$0$2.Writable, util = require$$1$3;
var DevNullStream$1 = dev_null_stream.exports = function() {
  WritableStream.call(this);
};
util.inherits(DevNullStream$1, WritableStream);
DevNullStream$1.prototype._write = function(chunk, encoding, cb) {
  cb();
};
var parser_feedback_simulatorExports = {};
var parser_feedback_simulator = {
  get exports() {
    return parser_feedback_simulatorExports;
  },
  set exports(v) {
    parser_feedback_simulatorExports = v;
  }
};
var Tokenizer$1 = tokenizerExports, foreignContent = foreign_content, UNICODE = unicode, HTML = html;
var $ = HTML.TAG_NAMES, NS = HTML.NAMESPACES;
var ParserFeedbackSimulator$1 = parser_feedback_simulator.exports = function(tokenizer2) {
  this.tokenizer = tokenizer2;
  this.namespaceStack = [];
  this.namespaceStackTop = -1;
  this._enterNamespace(NS.HTML);
};
ParserFeedbackSimulator$1.prototype.getNextToken = function() {
  var token = this.tokenizer.getNextToken();
  if (token.type === Tokenizer$1.START_TAG_TOKEN)
    this._handleStartTagToken(token);
  else if (token.type === Tokenizer$1.END_TAG_TOKEN)
    this._handleEndTagToken(token);
  else if (token.type === Tokenizer$1.NULL_CHARACTER_TOKEN && this.inForeignContent) {
    token.type = Tokenizer$1.CHARACTER_TOKEN;
    token.chars = UNICODE.REPLACEMENT_CHARACTER;
  } else if (this.skipNextNewLine) {
    if (token.type !== Tokenizer$1.HIBERNATION_TOKEN)
      this.skipNextNewLine = false;
    if (token.type === Tokenizer$1.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === "\n") {
      if (token.chars.length === 1)
        return this.getNextToken();
      token.chars = token.chars.substr(1);
    }
  }
  return token;
};
ParserFeedbackSimulator$1.prototype._enterNamespace = function(namespace) {
  this.namespaceStackTop++;
  this.namespaceStack.push(namespace);
  this.inForeignContent = namespace !== NS.HTML;
  this.currentNamespace = namespace;
  this.tokenizer.allowCDATA = this.inForeignContent;
};
ParserFeedbackSimulator$1.prototype._leaveCurrentNamespace = function() {
  this.namespaceStackTop--;
  this.namespaceStack.pop();
  this.currentNamespace = this.namespaceStack[this.namespaceStackTop];
  this.inForeignContent = this.currentNamespace !== NS.HTML;
  this.tokenizer.allowCDATA = this.inForeignContent;
};
ParserFeedbackSimulator$1.prototype._ensureTokenizerMode = function(tn) {
  if (tn === $.TEXTAREA || tn === $.TITLE)
    this.tokenizer.state = Tokenizer$1.MODE.RCDATA;
  else if (tn === $.PLAINTEXT)
    this.tokenizer.state = Tokenizer$1.MODE.PLAINTEXT;
  else if (tn === $.SCRIPT)
    this.tokenizer.state = Tokenizer$1.MODE.SCRIPT_DATA;
  else if (tn === $.STYLE || tn === $.IFRAME || tn === $.XMP || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT)
    this.tokenizer.state = Tokenizer$1.MODE.RAWTEXT;
};
ParserFeedbackSimulator$1.prototype._handleStartTagToken = function(token) {
  var tn = token.tagName;
  if (tn === $.SVG)
    this._enterNamespace(NS.SVG);
  else if (tn === $.MATH)
    this._enterNamespace(NS.MATHML);
  if (this.inForeignContent) {
    if (foreignContent.causesExit(token)) {
      this._leaveCurrentNamespace();
      return;
    }
    var currentNs = this.currentNamespace;
    if (currentNs === NS.MATHML)
      foreignContent.adjustTokenMathMLAttrs(token);
    else if (currentNs === NS.SVG) {
      foreignContent.adjustTokenSVGTagName(token);
      foreignContent.adjustTokenSVGAttrs(token);
    }
    foreignContent.adjustTokenXMLAttrs(token);
    tn = token.tagName;
    if (!token.selfClosing && foreignContent.isIntegrationPoint(tn, currentNs, token.attrs))
      this._enterNamespace(NS.HTML);
  } else {
    if (tn === $.PRE || tn === $.TEXTAREA || tn === $.LISTING)
      this.skipNextNewLine = true;
    else if (tn === $.IMAGE)
      token.tagName = $.IMG;
    this._ensureTokenizerMode(tn);
  }
};
ParserFeedbackSimulator$1.prototype._handleEndTagToken = function(token) {
  var tn = token.tagName;
  if (!this.inForeignContent) {
    var previousNs = this.namespaceStack[this.namespaceStackTop - 1];
    if (previousNs === NS.SVG && foreignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP[tn])
      tn = foreignContent.SVG_TAG_NAMES_ADJUSTMENT_MAP[tn];
    if (foreignContent.isIntegrationPoint(tn, previousNs, token.attrs))
      this._leaveCurrentNamespace();
  } else if (tn === $.SVG && this.currentNamespace === NS.SVG || tn === $.MATH && this.currentNamespace === NS.MATHML)
    this._leaveCurrentNamespace();
  if (this.currentNamespace === NS.SVG)
    foreignContent.adjustTokenSVGTagName(token);
};
var TransformStream = require$$0$2.Transform, DevNullStream = dev_null_streamExports, inherits = require$$1$3.inherits, Tokenizer3 = tokenizerExports, LocationInfoTokenizerMixin = tokenizer_mixinExports, ParserFeedbackSimulator = parser_feedback_simulatorExports, mergeOptions2 = merge_options;
var DEFAULT_OPTIONS = {
  locationInfo: false
};
var SAXParser = sax.exports = function(options2) {
  TransformStream.call(this);
  this.options = mergeOptions2(DEFAULT_OPTIONS, options2);
  this.tokenizer = new Tokenizer3(options2);
  if (this.options.locationInfo)
    new LocationInfoTokenizerMixin(this.tokenizer);
  this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);
  this.pendingText = null;
  this.currentTokenLocation = void 0;
  this.lastChunkWritten = false;
  this.stopped = false;
  this.pipe(new DevNullStream());
};
inherits(SAXParser, TransformStream);
SAXParser.prototype._transform = function(chunk, encoding, callback) {
  if (!this.stopped) {
    this.tokenizer.write(chunk.toString("utf8"), this.lastChunkWritten);
    this._runParsingLoop();
  }
  this.push(chunk);
  callback();
};
SAXParser.prototype._flush = function(callback) {
  callback();
};
SAXParser.prototype.end = function(chunk, encoding, callback) {
  this.lastChunkWritten = true;
  TransformStream.prototype.end.call(this, chunk, encoding, callback);
};
SAXParser.prototype.stop = function() {
  this.stopped = true;
};
SAXParser.prototype._runParsingLoop = function() {
  do {
    var token = this.parserFeedbackSimulator.getNextToken();
    if (token.type === Tokenizer3.HIBERNATION_TOKEN)
      break;
    if (token.type === Tokenizer3.CHARACTER_TOKEN || token.type === Tokenizer3.WHITESPACE_CHARACTER_TOKEN || token.type === Tokenizer3.NULL_CHARACTER_TOKEN) {
      if (this.options.locationInfo) {
        if (this.pendingText === null)
          this.currentTokenLocation = token.location;
        else
          this.currentTokenLocation.endOffset = token.location.endOffset;
      }
      this.pendingText = (this.pendingText || "") + token.chars;
    } else {
      this._emitPendingText();
      this._handleToken(token);
    }
  } while (!this.stopped && token.type !== Tokenizer3.EOF_TOKEN);
};
SAXParser.prototype._handleToken = function(token) {
  if (this.options.locationInfo)
    this.currentTokenLocation = token.location;
  if (token.type === Tokenizer3.START_TAG_TOKEN)
    this.emit("startTag", token.tagName, token.attrs, token.selfClosing, this.currentTokenLocation);
  else if (token.type === Tokenizer3.END_TAG_TOKEN)
    this.emit("endTag", token.tagName, this.currentTokenLocation);
  else if (token.type === Tokenizer3.COMMENT_TOKEN)
    this.emit("comment", token.data, this.currentTokenLocation);
  else if (token.type === Tokenizer3.DOCTYPE_TOKEN)
    this.emit("doctype", token.name, token.publicId, token.systemId, this.currentTokenLocation);
};
SAXParser.prototype._emitPendingText = function() {
  if (this.pendingText !== null) {
    this.emit("text", this.pendingText, this.currentTokenLocation);
    this.pendingText = null;
  }
};
var Parser3 = parserExports, Serializer = serializerExports;
lib.parse = function parse(html2, options2) {
  var parser2 = new Parser3(options2);
  return parser2.parse(html2);
};
lib.parseFragment = function parseFragment2(fragmentContext, html2, options2) {
  if (typeof fragmentContext === "string") {
    options2 = html2;
    html2 = fragmentContext;
    fragmentContext = null;
  }
  var parser2 = new Parser3(options2);
  return parser2.parseFragment(html2, fragmentContext);
};
lib.serialize = function(node2, options2) {
  var serializer2 = new Serializer(node2, options2);
  return serializer2.serialize();
};
lib.treeAdapters = {
  default: _default,
  htmlparser2
};
lib.ParserStream = parser_streamExports;
lib.PlainTextConversionStream = plain_text_conversion_streamExports;
lib.SerializerStream = serializer_streamExports;
lib.SAXParser = saxExports;
(function(module, exports) {
  var htmlparser = requireLib(), parse5 = lib;
  exports = module.exports = function(content, options2, isDocument2) {
    var dom = exports.evaluate(content, options2, isDocument2), root2 = exports.evaluate("<root></root>", options2, false)[0];
    root2.type = "root";
    root2.parent = null;
    exports.update(dom, root2);
    return root2;
  };
  function parseWithParse52(content, isDocument2) {
    var parse3 = isDocument2 ? parse5.parse : parse5.parseFragment, root2 = parse3(content, { treeAdapter: parse5.treeAdapters.htmlparser2 });
    return root2.children;
  }
  exports.evaluate = function(content, options2, isDocument2) {
    var dom;
    if (Buffer.isBuffer(content))
      content = content.toString();
    if (typeof content === "string") {
      var useHtmlParser2 = options2.xmlMode || options2._useHtmlParser2;
      dom = useHtmlParser2 ? htmlparser.parseDOM(content, options2) : parseWithParse52(content, isDocument2);
    } else {
      dom = content;
    }
    return dom;
  };
  exports.update = function(arr, parent2) {
    if (!Array.isArray(arr))
      arr = [arr];
    if (parent2) {
      parent2.children = arr;
    } else {
      parent2 = null;
    }
    for (var i2 = 0; i2 < arr.length; i2++) {
      var node2 = arr[i2];
      var oldParent = node2.parent || node2.root, oldSiblings = oldParent && oldParent.children;
      if (oldSiblings && oldSiblings !== arr) {
        oldSiblings.splice(oldSiblings.indexOf(node2), 1);
        if (node2.prev) {
          node2.prev.next = node2.next;
        }
        if (node2.next) {
          node2.next.prev = node2.prev;
        }
      }
      if (parent2) {
        node2.prev = arr[i2 - 1] || null;
        node2.next = arr[i2 + 1] || null;
      } else {
        node2.prev = node2.next = null;
      }
      if (parent2 && parent2.type === "root") {
        node2.root = parent2;
        node2.parent = null;
      } else {
        node2.root = null;
        node2.parent = parent2;
      }
    }
    return parent2;
  };
})(parse$6, parseExports);
var options = {};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$c = freeGlobal || freeSelf || Function("return this")();
var _root = root$c;
var root$b = _root;
var Symbol$6 = root$b.Symbol;
var _Symbol = Symbol$6;
var Symbol$5 = _Symbol;
var objectProto$i = Object.prototype;
var hasOwnProperty$g = objectProto$i.hasOwnProperty;
var nativeObjectToString$1 = objectProto$i.toString;
var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$g.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag2;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$h = Object.prototype;
var nativeObjectToString = objectProto$h.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$4 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : void 0;
function baseGetTag$6(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$6;
function isObject$b(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$b;
var baseGetTag$5 = _baseGetTag, isObject$a = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$a(value)) {
    return false;
  }
  var tag2 = baseGetTag$5(value);
  return tag2 == funcTag$1 || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var isFunction_1 = isFunction$3;
var root$a = _root;
var coreJsData$1 = root$a["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$9 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$g = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$f = objectProto$g.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$f).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$9(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative$6(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty = defineProperty$2;
var defineProperty$1 = _defineProperty;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
function eq$6(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$6;
var baseAssignValue$2 = _baseAssignValue, eq$5 = eq_1;
var objectProto$f = Object.prototype;
var hasOwnProperty$e = objectProto$f.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$e.call(object, key) && eq$5(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
function copyObject$3(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$3;
function identity$5(value) {
  return value;
}
var identity_1 = identity$5;
function apply$3(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$3;
var apply$2 = _apply;
var nativeMax$3 = Math.max;
function overRest$2(func, start, transform) {
  start = nativeMax$3(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$3(args.length - start, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start + index2];
    }
    index2 = -1;
    var otherArgs = Array(start + 1);
    while (++index2 < start) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start] = transform(array);
    return apply$2(func, this, otherArgs);
  };
}
var _overRest = overRest$2;
function constant$1(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$1;
var constant = constant_1, defineProperty = _defineProperty, identity$4 = identity_1;
var baseSetToString$1 = !defineProperty ? identity$4 : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$2(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$2;
var baseSetToString = _baseSetToString, shortOut$1 = _shortOut;
var setToString$3 = shortOut$1(baseSetToString);
var _setToString = setToString$3;
var identity$3 = identity_1, overRest$1 = _overRest, setToString$2 = _setToString;
function baseRest$3(func, start) {
  return setToString$2(overRest$1(func, start, identity$3), func + "");
}
var _baseRest = baseRest$3;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var isFunction$1 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$7(value) {
  return value != null && isLength$2(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$7;
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$5(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$5;
var eq$4 = eq_1, isArrayLike$6 = isArrayLike_1, isIndex$4 = _isIndex, isObject$8 = isObject_1;
function isIterateeCall$3(value, index2, object) {
  if (!isObject$8(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike$6(object) && isIndex$4(index2, object.length) : type == "string" && index2 in object) {
    return eq$4(object[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$3;
var baseRest$2 = _baseRest, isIterateeCall$2 = _isIterateeCall;
function createAssigner$3(assigner) {
  return baseRest$2(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall$2(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$3;
var objectProto$e = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$e;
  return value === proto;
}
var _isPrototype = isPrototype$4;
function baseTimes$1(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$8(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$8;
var baseGetTag$4 = _baseGetTag, isObjectLike$7 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$7(value) && baseGetTag$4(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$6 = isObjectLike_1;
var objectProto$d = Object.prototype;
var hasOwnProperty$d = objectProto$d.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$d.propertyIsEnumerable;
var isArguments$4 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$6(value) && hasOwnProperty$d.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isArray$h = Array.isArray;
var isArray_1 = isArray$h;
var isBufferExports = {};
var isBuffer$3 = {
  get exports() {
    return isBufferExports;
  },
  set exports(v) {
    isBufferExports = v;
  }
};
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$3, isBufferExports);
var baseGetTag$3 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$5 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$5(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$3(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtilExports = {};
var _nodeUtil = {
  get exports() {
    return _nodeUtilExports;
  },
  set exports(v) {
    _nodeUtilExports = v;
  }
};
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtilExports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
var baseTimes = _baseTimes, isArguments$3 = isArguments_1, isArray$g = isArray_1, isBuffer$2 = isBufferExports, isIndex$3 = _isIndex, isTypedArray$2 = isTypedArray_1;
var objectProto$c = Object.prototype;
var hasOwnProperty$c = objectProto$c.hasOwnProperty;
function arrayLikeKeys$2(value, inherited) {
  var isArr = isArray$g(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$2(value), isType = !isArr && !isArg && !isBuff && isTypedArray$2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$c.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$2;
function overArg$2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$2;
var overArg$1 = _overArg;
var nativeKeys$1 = overArg$1(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype$3 = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$b = Object.prototype;
var hasOwnProperty$b = objectProto$b.hasOwnProperty;
function baseKeys$1(object) {
  if (!isPrototype$3(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$b.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$5 = isArrayLike_1;
function keys$4(object) {
  return isArrayLike$5(object) ? arrayLikeKeys$1(object) : baseKeys(object);
}
var keys_1 = keys$4;
var assignValue$1 = _assignValue, copyObject$2 = _copyObject, createAssigner$2 = _createAssigner, isArrayLike$4 = isArrayLike_1, isPrototype$2 = _isPrototype, keys$3 = keys_1;
var objectProto$a = Object.prototype;
var hasOwnProperty$a = objectProto$a.hasOwnProperty;
var assign$2 = createAssigner$2(function(object, source) {
  if (isPrototype$2(source) || isArrayLike$4(source)) {
    copyObject$2(source, keys$3(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty$a.call(source, key)) {
      assignValue$1(object, key, source[key]);
    }
  }
});
var assign_1 = assign$2;
var assign$1 = assign_1;
options.default = {
  withDomLvl1: true,
  normalizeWhitespace: false,
  xml: false,
  decodeEntities: true
};
options.flatten = function(options2) {
  return options2 && options2.xml ? assign$1({ xmlMode: true }, options2.xml) : options2;
};
var utils = {};
var parse$5 = parseExports, render = domSerializerExports, assign = assign_1;
var tags = { tag: true, script: true, style: true };
utils.isTag = function(type) {
  if (type.type)
    type = type.type;
  return tags[type] || false;
};
utils.camelCase = function(str) {
  return str.replace(/[_.-](\w|$)/g, function(_2, x) {
    return x.toUpperCase();
  });
};
utils.cssCase = function(str) {
  return str.replace(/[A-Z]/g, "-$&").toLowerCase();
};
utils.domEach = function(cheerio2, fn) {
  var i2 = 0, len = cheerio2.length;
  while (i2 < len && fn.call(cheerio2, i2, cheerio2[i2]) !== false)
    ++i2;
  return cheerio2;
};
utils.cloneDom = function(dom, options2) {
  options2 = assign({}, options2, { _useHtmlParser2: true });
  return parse$5(render(dom, options2), options2, false).children;
};
var quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
utils.isHtml = function(str) {
  if (str.charAt(0) === "<" && str.charAt(str.length - 1) === ">" && str.length >= 3)
    return true;
  var match = quickExpr.exec(str);
  return !!(match && match[1]);
};
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var isObject$7 = isObject_1, isPrototype$1 = _isPrototype, nativeKeysIn = _nativeKeysIn;
var objectProto$9 = Object.prototype;
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject$7(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype$1(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeysIn = _baseKeysIn, isArrayLike$3 = isArrayLike_1;
function keysIn$4(object) {
  return isArrayLike$3(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var keysIn_1 = keysIn$4;
var copyObject$1 = _copyObject, createAssigner$1 = _createAssigner, keysIn$3 = keysIn_1;
var assignIn = createAssigner$1(function(object, source) {
  copyObject$1(source, keysIn$3(source), object);
});
var assignIn_1 = assignIn;
var getNative$5 = _getNative, root$9 = _root;
var WeakMap$2 = getNative$5(root$9, "WeakMap");
var _WeakMap = WeakMap$2;
var WeakMap$1 = _WeakMap;
var metaMap$2 = WeakMap$1 && new WeakMap$1();
var _metaMap = metaMap$2;
var identity$2 = identity_1, metaMap$1 = _metaMap;
var baseSetData$2 = !metaMap$1 ? identity$2 : function(func, data2) {
  metaMap$1.set(func, data2);
  return func;
};
var _baseSetData = baseSetData$2;
var isObject$6 = isObject_1;
var objectCreate = Object.create;
var baseCreate$4 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$6(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$4;
var baseCreate$3 = _baseCreate, isObject$5 = isObject_1;
function createCtor$4(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate$3(Ctor.prototype), result = Ctor.apply(thisBinding, args);
    return isObject$5(result) ? result : thisBinding;
  };
}
var _createCtor = createCtor$4;
var createCtor$3 = _createCtor, root$8 = _root;
var WRAP_BIND_FLAG$7 = 1;
function createBind$1(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG$7, Ctor = createCtor$3(func);
  function wrapper() {
    var fn = this && this !== root$8 && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var _createBind = createBind$1;
var nativeMax$2 = Math.max;
function composeArgs$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$2(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}
var _composeArgs = composeArgs$2;
var nativeMax$1 = Math.max;
function composeArgsRight$2(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$1(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}
var _composeArgsRight = composeArgsRight$2;
function countHolders$1(array, placeholder) {
  var length = array.length, result = 0;
  while (length--) {
    if (array[length] === placeholder) {
      ++result;
    }
  }
  return result;
}
var _countHolders = countHolders$1;
function baseLodash$3() {
}
var _baseLodash = baseLodash$3;
var baseCreate$2 = _baseCreate, baseLodash$2 = _baseLodash;
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper$3(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper$3.prototype = baseCreate$2(baseLodash$2.prototype);
LazyWrapper$3.prototype.constructor = LazyWrapper$3;
var _LazyWrapper = LazyWrapper$3;
function noop$1() {
}
var noop_1 = noop$1;
var metaMap = _metaMap, noop = noop_1;
var getData$2 = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};
var _getData = getData$2;
var realNames$1 = {};
var _realNames = realNames$1;
var realNames = _realNames;
var objectProto$8 = Object.prototype;
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;
function getFuncName$1(func) {
  var result = func.name + "", array = realNames[result], length = hasOwnProperty$8.call(realNames, result) ? array.length : 0;
  while (length--) {
    var data2 = array[length], otherFunc = data2.func;
    if (otherFunc == null || otherFunc == func) {
      return data2.name;
    }
  }
  return result;
}
var _getFuncName = getFuncName$1;
var baseCreate$1 = _baseCreate, baseLodash$1 = _baseLodash;
function LodashWrapper$2(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper$2.prototype = baseCreate$1(baseLodash$1.prototype);
LodashWrapper$2.prototype.constructor = LodashWrapper$2;
var _LodashWrapper = LodashWrapper$2;
function copyArray$3(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$3;
var LazyWrapper$2 = _LazyWrapper, LodashWrapper$1 = _LodashWrapper, copyArray$2 = _copyArray;
function wrapperClone$1(wrapper) {
  if (wrapper instanceof LazyWrapper$2) {
    return wrapper.clone();
  }
  var result = new LodashWrapper$1(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray$2(wrapper.__actions__);
  result.__index__ = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}
var _wrapperClone = wrapperClone$1;
var LazyWrapper$1 = _LazyWrapper, LodashWrapper = _LodashWrapper, baseLodash = _baseLodash, isArray$f = isArray_1, isObjectLike$4 = isObjectLike_1, wrapperClone = _wrapperClone;
var objectProto$7 = Object.prototype;
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;
function lodash$1(value) {
  if (isObjectLike$4(value) && !isArray$f(value) && !(value instanceof LazyWrapper$1)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty$7.call(value, "__wrapped__")) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}
lodash$1.prototype = baseLodash.prototype;
lodash$1.prototype.constructor = lodash$1;
var wrapperLodash = lodash$1;
var LazyWrapper = _LazyWrapper, getData$1 = _getData, getFuncName = _getFuncName, lodash = wrapperLodash;
function isLaziable$1(func) {
  var funcName = getFuncName(func), other = lodash[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data2 = getData$1(other);
  return !!data2 && func === data2[0];
}
var _isLaziable = isLaziable$1;
var baseSetData$1 = _baseSetData, shortOut = _shortOut;
var setData$2 = shortOut(baseSetData$1);
var _setData = setData$2;
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
function getWrapDetails$1(source) {
  var match = source.match(reWrapDetails);
  return match ? match[1].split(reSplitDetails) : [];
}
var _getWrapDetails = getWrapDetails$1;
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails$1(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var _insertWrapDetails = insertWrapDetails$1;
function arrayEach$2(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$2;
function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
  var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return index2;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$1;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array, value, fromIndex) {
  var index2 = fromIndex - 1, length = array.length;
  while (++index2 < length) {
    if (array[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
var arrayEach$1 = _arrayEach, arrayIncludes = _arrayIncludes;
var WRAP_BIND_FLAG$6 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$4 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_PARTIAL_FLAG$3 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$1 = 256, WRAP_FLIP_FLAG$1 = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG$2],
  ["bind", WRAP_BIND_FLAG$6],
  ["bindKey", WRAP_BIND_KEY_FLAG$4],
  ["curry", WRAP_CURRY_FLAG$4],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG$2],
  ["flip", WRAP_FLIP_FLAG$1],
  ["partial", WRAP_PARTIAL_FLAG$3],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$2],
  ["rearg", WRAP_REARG_FLAG$1]
];
function updateWrapDetails$1(details, bitmask) {
  arrayEach$1(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var _updateWrapDetails = updateWrapDetails$1;
var getWrapDetails = _getWrapDetails, insertWrapDetails = _insertWrapDetails, setToString$1 = _setToString, updateWrapDetails = _updateWrapDetails;
function setWrapToString$2(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString$1(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
}
var _setWrapToString = setWrapToString$2;
var isLaziable = _isLaziable, setData$1 = _setData, setWrapToString$1 = _setWrapToString;
var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$3 = 8, WRAP_PARTIAL_FLAG$2 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
function createRecurry$2(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG$3, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG$2 : WRAP_PARTIAL_RIGHT_FLAG$1;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
    bitmask &= ~(WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary,
    arity
  ];
  var result = wrapFunc.apply(void 0, newData);
  if (isLaziable(func)) {
    setData$1(result, newData);
  }
  result.placeholder = placeholder;
  return setWrapToString$1(result, func, bitmask);
}
var _createRecurry = createRecurry$2;
function getHolder$3(func) {
  var object = func;
  return object.placeholder;
}
var _getHolder = getHolder$3;
var copyArray$1 = _copyArray, isIndex$2 = _isIndex;
var nativeMin$1 = Math.min;
function reorder$1(array, indexes) {
  var arrLength = array.length, length = nativeMin$1(indexes.length, arrLength), oldArray = copyArray$1(array);
  while (length--) {
    var index2 = indexes[length];
    array[length] = isIndex$2(index2, arrLength) ? oldArray[index2] : void 0;
  }
  return array;
}
var _reorder = reorder$1;
var PLACEHOLDER$1 = "__lodash_placeholder__";
function replaceHolders$4(array, placeholder) {
  var index2 = -1, length = array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (value === placeholder || value === PLACEHOLDER$1) {
      array[index2] = PLACEHOLDER$1;
      result[resIndex++] = index2;
    }
  }
  return result;
}
var _replaceHolders = replaceHolders$4;
var composeArgs$1 = _composeArgs, composeArgsRight$1 = _composeArgsRight, countHolders = _countHolders, createCtor$2 = _createCtor, createRecurry$1 = _createRecurry, getHolder$2 = _getHolder, reorder = _reorder, replaceHolders$3 = _replaceHolders, root$7 = _root;
var WRAP_BIND_FLAG$4 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$2 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_ARY_FLAG$1 = 128, WRAP_FLIP_FLAG = 512;
function createHybrid$2(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG$1, isBind = bitmask & WRAP_BIND_FLAG$4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2, isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor$2(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index2 = length;
    while (index2--) {
      args[index2] = arguments[index2];
    }
    if (isCurried) {
      var placeholder = getHolder$2(wrapper), holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs$1(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight$1(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders$3(args, placeholder);
      return createRecurry$1(
        func,
        bitmask,
        createHybrid$2,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary,
        arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root$7 && this instanceof wrapper) {
      fn = Ctor || createCtor$2(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var _createHybrid = createHybrid$2;
var apply$1 = _apply, createCtor$1 = _createCtor, createHybrid$1 = _createHybrid, createRecurry = _createRecurry, getHolder$1 = _getHolder, replaceHolders$2 = _replaceHolders, root$6 = _root;
function createCurry$1(func, bitmask, arity) {
  var Ctor = createCtor$1(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index2 = length, placeholder = getHolder$1(wrapper);
    while (index2--) {
      args[index2] = arguments[index2];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders$2(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry(
        func,
        bitmask,
        createHybrid$1,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length
      );
    }
    var fn = this && this !== root$6 && this instanceof wrapper ? Ctor : func;
    return apply$1(fn, this, args);
  }
  return wrapper;
}
var _createCurry = createCurry$1;
var apply = _apply, createCtor = _createCtor, root$5 = _root;
var WRAP_BIND_FLAG$3 = 1;
function createPartial$1(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG$3, Ctor = createCtor(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root$5 && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var _createPartial = createPartial$1;
var composeArgs = _composeArgs, composeArgsRight = _composeArgsRight, replaceHolders$1 = _replaceHolders;
var PLACEHOLDER = "__lodash_placeholder__";
var WRAP_BIND_FLAG$2 = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$1 = 8, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
var nativeMin = Math.min;
function mergeData$1(data2, source) {
  var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1 | WRAP_ARY_FLAG);
  var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG$1 || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$1;
  if (!(isCommon || isCombo)) {
    return data2;
  }
  if (srcBitmask & WRAP_BIND_FLAG$2) {
    data2[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG$2 ? 0 : WRAP_CURRY_BOUND_FLAG;
  }
  var value = source[3];
  if (value) {
    var partials = data2[3];
    data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data2[4] = partials ? replaceHolders$1(data2[3], PLACEHOLDER) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data2[5];
    data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data2[6] = partials ? replaceHolders$1(data2[5], PLACEHOLDER) : source[6];
  }
  value = source[7];
  if (value) {
    data2[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG) {
    data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
  }
  if (data2[9] == null) {
    data2[9] = source[9];
  }
  data2[0] = source[0];
  data2[1] = newBitmask;
  return data2;
}
var _mergeData = mergeData$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var symbolTag$1 = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$2(value) == symbolTag$1;
}
var isSymbol_1 = isSymbol$4;
var baseTrim = _baseTrim, isObject$4 = isObject_1, isSymbol$3 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$3(value)) {
    return NAN;
  }
  if (isObject$4(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$4(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var toNumber = toNumber_1;
var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseSetData = _baseSetData, createBind = _createBind, createCurry = _createCurry, createHybrid = _createHybrid, createPartial = _createPartial, getData = _getData, mergeData = _mergeData, setData = _setData, setWrapToString = _setWrapToString, toInteger = toInteger_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var WRAP_BIND_FLAG$1 = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG$1 = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
var nativeMax = Math.max;
function createWrap$1(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG$1 | WRAP_PARTIAL_RIGHT_FLAG);
    partials = holders = void 0;
  }
  ary = ary === void 0 ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === void 0 ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data2 = isBindKey ? void 0 : getData(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary,
    arity
  ];
  if (data2) {
    mergeData(newData, data2);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
    bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG$1) {
    var result = createBind(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
    result = createCurry(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG$1 || bitmask == (WRAP_BIND_FLAG$1 | WRAP_PARTIAL_FLAG$1)) && !holders.length) {
    result = createPartial(func, bitmask, thisArg, partials);
  } else {
    result = createHybrid.apply(void 0, newData);
  }
  var setter = data2 ? baseSetData : setData;
  return setWrapToString(setter(result, newData), func, bitmask);
}
var _createWrap = createWrap$1;
var baseRest$1 = _baseRest, createWrap = _createWrap, getHolder = _getHolder, replaceHolders = _replaceHolders;
var WRAP_BIND_FLAG = 1, WRAP_PARTIAL_FLAG = 32;
var bind = baseRest$1(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG;
  if (partials.length) {
    var holders = replaceHolders(partials, getHolder(bind));
    bitmask |= WRAP_PARTIAL_FLAG;
  }
  return createWrap(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_1 = bind;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$2 = createBaseFor();
var _baseFor = baseFor$2;
var baseFor$1 = _baseFor, keys$2 = keys_1;
function baseForOwn$1(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys$2);
}
var _baseForOwn = baseForOwn$1;
var isArrayLike$2 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$2(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$5 = createBaseEach(baseForOwn);
var _baseEach = baseEach$5;
var identity$1 = identity_1;
function castFunction$1(value) {
  return typeof value == "function" ? value : identity$1;
}
var _castFunction = castFunction$1;
var arrayEach = _arrayEach, baseEach$4 = _baseEach, castFunction = _castFunction, isArray$e = isArray_1;
function forEach(collection, iteratee) {
  var func = isArray$e(collection) ? arrayEach : baseEach$4;
  return func(collection, castFunction(iteratee));
}
var forEach_1 = forEach;
var baseRest = _baseRest, eq$3 = eq_1, isIterateeCall$1 = _isIterateeCall, keysIn$2 = keysIn_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;
var defaults = baseRest(function(object, sources) {
  object = Object(object);
  var index2 = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall$1(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index2 < length) {
    var source = sources[index2];
    var props = keysIn$2(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq$3(value, objectProto$6[key]) && !hasOwnProperty$6.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_1 = defaults;
var attributes$2 = {};
var _static = {};
var nthCheckExports = {};
var nthCheck = {
  get exports() {
    return nthCheckExports;
  },
  set exports(v) {
    nthCheckExports = v;
  }
};
var parse_1 = parse$4;
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
function parse$4(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  } else {
    var parsed = formula.match(re_nthElement);
    if (!parsed) {
      throw new SyntaxError("n-th rule couldn't be parsed ('" + formula + "')");
    }
    var a;
    if (parsed[1]) {
      a = parseInt(parsed[1], 10);
      if (isNaN(a)) {
        if (parsed[1].charAt(0) === "-")
          a = -1;
        else
          a = 1;
      }
    } else
      a = 0;
    return [
      a,
      parsed[3] ? parseInt((parsed[2] || "") + parsed[3], 10) : 0
    ];
  }
}
var compile_1 = compile$4;
var BaseFuncs$2 = boolbase, trueFunc$2 = BaseFuncs$2.trueFunc, falseFunc$4 = BaseFuncs$2.falseFunc;
function compile$4(parsed) {
  var a = parsed[0], b = parsed[1] - 1;
  if (b < 0 && a <= 0)
    return falseFunc$4;
  if (a === -1)
    return function(pos) {
      return pos <= b;
    };
  if (a === 0)
    return function(pos) {
      return pos === b;
    };
  if (a === 1)
    return b < 0 ? trueFunc$2 : function(pos) {
      return pos >= b;
    };
  var bMod = b % a;
  if (bMod < 0)
    bMod += a;
  if (a > 1) {
    return function(pos) {
      return pos >= b && pos % a === bMod;
    };
  }
  a *= -1;
  return function(pos) {
    return pos <= b && pos % a === bMod;
  };
}
var parse$3 = parse_1, compile$3 = compile_1;
nthCheck.exports = function nthCheck2(formula) {
  return compile$3(parse$3(formula));
};
nthCheckExports.parse = parse$3;
nthCheckExports.compile = compile$3;
var DomUtils$4 = domutilsExports, hasAttrib$1 = DomUtils$4.hasAttrib, getAttributeValue = DomUtils$4.getAttributeValue, falseFunc$3 = boolbase.falseFunc;
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
var attributeRules = {
  __proto__: null,
  equals: function(next2, data2) {
    var name2 = data2.name, value = data2.value;
    if (data2.ignoreCase) {
      value = value.toLowerCase();
      return function equalsIC(elem) {
        var attr2 = getAttributeValue(elem, name2);
        return attr2 != null && attr2.toLowerCase() === value && next2(elem);
      };
    }
    return function equals2(elem) {
      return getAttributeValue(elem, name2) === value && next2(elem);
    };
  },
  hyphen: function(next2, data2) {
    var name2 = data2.name, value = data2.value, len = value.length;
    if (data2.ignoreCase) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        var attr2 = getAttributeValue(elem, name2);
        return attr2 != null && (attr2.length === len || attr2.charAt(len) === "-") && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return function hyphen2(elem) {
      var attr2 = getAttributeValue(elem, name2);
      return attr2 != null && attr2.substr(0, len) === value && (attr2.length === len || attr2.charAt(len) === "-") && next2(elem);
    };
  },
  element: function(next2, data2) {
    var name2 = data2.name, value = data2.value;
    if (/\s/.test(value)) {
      return falseFunc$3;
    }
    value = value.replace(reChars, "\\$&");
    var pattern = "(?:^|\\s)" + value + "(?:$|\\s)", flags = data2.ignoreCase ? "i" : "", regex = new RegExp(pattern, flags);
    return function element2(elem) {
      var attr2 = getAttributeValue(elem, name2);
      return attr2 != null && regex.test(attr2) && next2(elem);
    };
  },
  exists: function(next2, data2) {
    var name2 = data2.name;
    return function exists(elem) {
      return hasAttrib$1(elem, name2) && next2(elem);
    };
  },
  start: function(next2, data2) {
    var name2 = data2.name, value = data2.value, len = value.length;
    if (len === 0) {
      return falseFunc$3;
    }
    if (data2.ignoreCase) {
      value = value.toLowerCase();
      return function startIC(elem) {
        var attr2 = getAttributeValue(elem, name2);
        return attr2 != null && attr2.substr(0, len).toLowerCase() === value && next2(elem);
      };
    }
    return function start(elem) {
      var attr2 = getAttributeValue(elem, name2);
      return attr2 != null && attr2.substr(0, len) === value && next2(elem);
    };
  },
  end: function(next2, data2) {
    var name2 = data2.name, value = data2.value, len = -value.length;
    if (len === 0) {
      return falseFunc$3;
    }
    if (data2.ignoreCase) {
      value = value.toLowerCase();
      return function endIC(elem) {
        var attr2 = getAttributeValue(elem, name2);
        return attr2 != null && attr2.substr(len).toLowerCase() === value && next2(elem);
      };
    }
    return function end2(elem) {
      var attr2 = getAttributeValue(elem, name2);
      return attr2 != null && attr2.substr(len) === value && next2(elem);
    };
  },
  any: function(next2, data2) {
    var name2 = data2.name, value = data2.value;
    if (value === "") {
      return falseFunc$3;
    }
    if (data2.ignoreCase) {
      var regex = new RegExp(value.replace(reChars, "\\$&"), "i");
      return function anyIC(elem) {
        var attr2 = getAttributeValue(elem, name2);
        return attr2 != null && regex.test(attr2) && next2(elem);
      };
    }
    return function any(elem) {
      var attr2 = getAttributeValue(elem, name2);
      return attr2 != null && attr2.indexOf(value) >= 0 && next2(elem);
    };
  },
  not: function(next2, data2) {
    var name2 = data2.name, value = data2.value;
    if (value === "") {
      return function notEmpty(elem) {
        return !!getAttributeValue(elem, name2) && next2(elem);
      };
    } else if (data2.ignoreCase) {
      value = value.toLowerCase();
      return function notIC(elem) {
        var attr2 = getAttributeValue(elem, name2);
        return attr2 != null && attr2.toLowerCase() !== value && next2(elem);
      };
    }
    return function not2(elem) {
      return getAttributeValue(elem, name2) !== value && next2(elem);
    };
  }
};
var attributes$1 = {
  compile: function(next2, data2, options2) {
    if (options2 && options2.strict && (data2.ignoreCase || data2.action === "not"))
      throw SyntaxError("Unsupported attribute selector");
    return attributeRules[data2.action](next2, data2);
  },
  rules: attributeRules
};
var DomUtils$3 = domutilsExports, isTag$2 = DomUtils$3.isTag, getText = DomUtils$3.getText, getParent$2 = DomUtils$3.getParent, getChildren$3 = DomUtils$3.getChildren, getSiblings$1 = DomUtils$3.getSiblings, hasAttrib = DomUtils$3.hasAttrib, getName$1 = DomUtils$3.getName, getAttribute = DomUtils$3.getAttributeValue, getNCheck = nthCheckExports, checkAttrib = attributes$1.rules.equals, BaseFuncs$1 = boolbase, trueFunc$1 = BaseFuncs$1.trueFunc, falseFunc$2 = BaseFuncs$1.falseFunc;
function getFirstElement(elems) {
  for (var i2 = 0; elems && i2 < elems.length; i2++) {
    if (isTag$2(elems[i2]))
      return elems[i2];
  }
}
function getAttribFunc(name2, value) {
  var data2 = { name: name2, value };
  return function attribFunc(next2) {
    return checkAttrib(next2, data2);
  };
}
function getChildFunc(next2) {
  return function(elem) {
    return !!getParent$2(elem) && next2(elem);
  };
}
var filters$1 = {
  contains: function(next2, text2) {
    return function contains2(elem) {
      return next2(elem) && getText(elem).indexOf(text2) >= 0;
    };
  },
  icontains: function(next2, text2) {
    var itext = text2.toLowerCase();
    return function icontains(elem) {
      return next2(elem) && getText(elem).toLowerCase().indexOf(itext) >= 0;
    };
  },
  //location specific methods
  "nth-child": function(next2, rule) {
    var func = getNCheck(rule);
    if (func === falseFunc$2)
      return func;
    if (func === trueFunc$1)
      return getChildFunc(next2);
    return function nthChild(elem) {
      var siblings2 = getSiblings$1(elem);
      for (var i2 = 0, pos = 0; i2 < siblings2.length; i2++) {
        if (isTag$2(siblings2[i2])) {
          if (siblings2[i2] === elem)
            break;
          else
            pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-child": function(next2, rule) {
    var func = getNCheck(rule);
    if (func === falseFunc$2)
      return func;
    if (func === trueFunc$1)
      return getChildFunc(next2);
    return function nthLastChild(elem) {
      var siblings2 = getSiblings$1(elem);
      for (var pos = 0, i2 = siblings2.length - 1; i2 >= 0; i2--) {
        if (isTag$2(siblings2[i2])) {
          if (siblings2[i2] === elem)
            break;
          else
            pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-of-type": function(next2, rule) {
    var func = getNCheck(rule);
    if (func === falseFunc$2)
      return func;
    if (func === trueFunc$1)
      return getChildFunc(next2);
    return function nthOfType(elem) {
      var siblings2 = getSiblings$1(elem);
      for (var pos = 0, i2 = 0; i2 < siblings2.length; i2++) {
        if (isTag$2(siblings2[i2])) {
          if (siblings2[i2] === elem)
            break;
          if (getName$1(siblings2[i2]) === getName$1(elem))
            pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  "nth-last-of-type": function(next2, rule) {
    var func = getNCheck(rule);
    if (func === falseFunc$2)
      return func;
    if (func === trueFunc$1)
      return getChildFunc(next2);
    return function nthLastOfType(elem) {
      var siblings2 = getSiblings$1(elem);
      for (var pos = 0, i2 = siblings2.length - 1; i2 >= 0; i2--) {
        if (isTag$2(siblings2[i2])) {
          if (siblings2[i2] === elem)
            break;
          if (getName$1(siblings2[i2]) === getName$1(elem))
            pos++;
        }
      }
      return func(pos) && next2(elem);
    };
  },
  //TODO determine the actual root element
  root: function(next2) {
    return function(elem) {
      return !getParent$2(elem) && next2(elem);
    };
  },
  scope: function(next2, rule, options2, context) {
    if (!context || context.length === 0) {
      return filters$1.root(next2);
    }
    if (context.length === 1) {
      return function(elem) {
        return context[0] === elem && next2(elem);
      };
    }
    return function(elem) {
      return context.indexOf(elem) >= 0 && next2(elem);
    };
  },
  //jQuery extensions (others follow as pseudos)
  checkbox: getAttribFunc("type", "checkbox"),
  file: getAttribFunc("type", "file"),
  password: getAttribFunc("type", "password"),
  radio: getAttribFunc("type", "radio"),
  reset: getAttribFunc("type", "reset"),
  image: getAttribFunc("type", "image"),
  submit: getAttribFunc("type", "submit")
};
var pseudos = {
  empty: function(elem) {
    return !getChildren$3(elem).some(function(elem2) {
      return isTag$2(elem2) || elem2.type === "text";
    });
  },
  "first-child": function(elem) {
    return getFirstElement(getSiblings$1(elem)) === elem;
  },
  "last-child": function(elem) {
    var siblings2 = getSiblings$1(elem);
    for (var i2 = siblings2.length - 1; i2 >= 0; i2--) {
      if (siblings2[i2] === elem)
        return true;
      if (isTag$2(siblings2[i2]))
        break;
    }
    return false;
  },
  "first-of-type": function(elem) {
    var siblings2 = getSiblings$1(elem);
    for (var i2 = 0; i2 < siblings2.length; i2++) {
      if (isTag$2(siblings2[i2])) {
        if (siblings2[i2] === elem)
          return true;
        if (getName$1(siblings2[i2]) === getName$1(elem))
          break;
      }
    }
    return false;
  },
  "last-of-type": function(elem) {
    var siblings2 = getSiblings$1(elem);
    for (var i2 = siblings2.length - 1; i2 >= 0; i2--) {
      if (isTag$2(siblings2[i2])) {
        if (siblings2[i2] === elem)
          return true;
        if (getName$1(siblings2[i2]) === getName$1(elem))
          break;
      }
    }
    return false;
  },
  "only-of-type": function(elem) {
    var siblings2 = getSiblings$1(elem);
    for (var i2 = 0, j2 = siblings2.length; i2 < j2; i2++) {
      if (isTag$2(siblings2[i2])) {
        if (siblings2[i2] === elem)
          continue;
        if (getName$1(siblings2[i2]) === getName$1(elem))
          return false;
      }
    }
    return true;
  },
  "only-child": function(elem) {
    var siblings2 = getSiblings$1(elem);
    for (var i2 = 0; i2 < siblings2.length; i2++) {
      if (isTag$2(siblings2[i2]) && siblings2[i2] !== elem)
        return false;
    }
    return true;
  },
  //:matches(a, area, link)[href]
  link: function(elem) {
    return hasAttrib(elem, "href");
  },
  visited: falseFunc$2,
  //seems to be a valid implementation
  //TODO: :any-link once the name is finalized (as an alias of :link)
  //forms
  //to consider: :target
  //:matches([selected], select:not([multiple]):not(> option[selected]) > option:first-of-type)
  selected: function(elem) {
    if (hasAttrib(elem, "selected"))
      return true;
    else if (getName$1(elem) !== "option")
      return false;
    var parent2 = getParent$2(elem);
    if (!parent2 || getName$1(parent2) !== "select" || hasAttrib(parent2, "multiple"))
      return false;
    var siblings2 = getChildren$3(parent2), sawElem = false;
    for (var i2 = 0; i2 < siblings2.length; i2++) {
      if (isTag$2(siblings2[i2])) {
        if (siblings2[i2] === elem) {
          sawElem = true;
        } else if (!sawElem) {
          return false;
        } else if (hasAttrib(siblings2[i2], "selected")) {
          return false;
        }
      }
    }
    return sawElem;
  },
  //https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  //:matches(
  //  :matches(button, input, select, textarea, menuitem, optgroup, option)[disabled],
  //  optgroup[disabled] > option),
  // fieldset[disabled] * //TODO not child of first <legend>
  //)
  disabled: function(elem) {
    return hasAttrib(elem, "disabled");
  },
  enabled: function(elem) {
    return !hasAttrib(elem, "disabled");
  },
  //:matches(:matches(:radio, :checkbox)[checked], :selected) (TODO menuitem)
  checked: function(elem) {
    return hasAttrib(elem, "checked") || pseudos.selected(elem);
  },
  //:matches(input, select, textarea)[required]
  required: function(elem) {
    return hasAttrib(elem, "required");
  },
  //:matches(input, select, textarea):not([required])
  optional: function(elem) {
    return !hasAttrib(elem, "required");
  },
  //jQuery extensions
  //:not(:empty)
  parent: function(elem) {
    return !pseudos.empty(elem);
  },
  //:matches(h1, h2, h3, h4, h5, h6)
  header: function(elem) {
    var name2 = getName$1(elem);
    return name2 === "h1" || name2 === "h2" || name2 === "h3" || name2 === "h4" || name2 === "h5" || name2 === "h6";
  },
  //:matches(button, input[type=button])
  button: function(elem) {
    var name2 = getName$1(elem);
    return name2 === "button" || name2 === "input" && getAttribute(elem, "type") === "button";
  },
  //:matches(input, textarea, select, button)
  input: function(elem) {
    var name2 = getName$1(elem);
    return name2 === "input" || name2 === "textarea" || name2 === "select" || name2 === "button";
  },
  //input:matches(:not([type!='']), [type='text' i])
  text: function(elem) {
    var attr2;
    return getName$1(elem) === "input" && (!(attr2 = getAttribute(elem, "type")) || attr2.toLowerCase() === "text");
  }
};
function verifyArgs(func, name2, subselect) {
  if (subselect === null) {
    if (func.length > 1 && name2 !== "scope") {
      throw new SyntaxError("pseudo-selector :" + name2 + " requires an argument");
    }
  } else {
    if (func.length === 1) {
      throw new SyntaxError("pseudo-selector :" + name2 + " doesn't have any arguments");
    }
  }
}
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
var pseudos_1 = {
  compile: function(next2, data2, options2, context) {
    var name2 = data2.name, subselect = data2.data;
    if (options2 && options2.strict && !re_CSS3.test(name2)) {
      throw SyntaxError(":" + name2 + " isn't part of CSS3");
    }
    if (typeof filters$1[name2] === "function") {
      verifyArgs(filters$1[name2], name2, subselect);
      return filters$1[name2](next2, subselect, options2, context);
    } else if (typeof pseudos[name2] === "function") {
      var func = pseudos[name2];
      verifyArgs(func, name2, subselect);
      if (next2 === trueFunc$1)
        return func;
      return function pseudoArgs(elem) {
        return func(elem, subselect) && next2(elem);
      };
    } else {
      throw new SyntaxError("unmatched pseudo-class :" + name2);
    }
  },
  filters: filters$1,
  pseudos
};
var compileExports = {};
var compile$2 = {
  get exports() {
    return compileExports;
  },
  set exports(v) {
    compileExports = v;
  }
};
var cssWhat = parse$2;
var re_name = /^(?:\\.|[\w\-\u00b0-\uFFFF])+/, re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/ig, re_attr = /^\s*((?:\\.|[\w\u00b0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])([^]*?)\3|(#?(?:\\.|[\w\u00b0-\uFFFF\-])*)|)|)\s*(i)?\]/;
var actionTypes = {
  __proto__: null,
  "undefined": "exists",
  "": "equals",
  "~": "element",
  "^": "start",
  "$": "end",
  "*": "any",
  "!": "not",
  "|": "hyphen"
};
var simpleSelectors = {
  __proto__: null,
  ">": "child",
  "<": "parent",
  "~": "sibling",
  "+": "adjacent"
};
var attribSelectors = {
  __proto__: null,
  "#": ["id", "equals"],
  ".": ["class", "element"]
};
var unpackPseudos = {
  __proto__: null,
  "has": true,
  "not": true,
  "matches": true
};
var stripQuotesFromPseudos = {
  __proto__: null,
  "contains": true,
  "icontains": true
};
var quotes = {
  __proto__: null,
  '"': true,
  "'": true
};
function funescape(_2, escaped, escapedWhitespace) {
  var high = "0x" + escaped - 65536;
  return high !== high || escapedWhitespace ? escaped : (
    // BMP codepoint
    high < 0 ? String.fromCharCode(high + 65536) : (
      // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
    )
  );
}
function unescapeCSS(str) {
  return str.replace(re_escape, funescape);
}
function isWhitespace(c) {
  return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
}
function parse$2(selector, options2) {
  var subselects2 = [];
  selector = parseSelector(subselects2, selector + "", options2);
  if (selector !== "") {
    throw new SyntaxError("Unmatched selector: " + selector);
  }
  return subselects2;
}
function parseSelector(subselects2, selector, options2) {
  var tokens = [], sawWS = false, data2, firstChar, name2, quot2;
  function getName2() {
    var sub2 = selector.match(re_name)[0];
    selector = selector.substr(sub2.length);
    return unescapeCSS(sub2);
  }
  function stripWhitespace(start) {
    while (isWhitespace(selector.charAt(start)))
      start++;
    selector = selector.substr(start);
  }
  function isEscaped(pos2) {
    var slashCount = 0;
    while (selector.charAt(--pos2) === "\\")
      slashCount++;
    return (slashCount & 1) === 1;
  }
  stripWhitespace(0);
  while (selector !== "") {
    firstChar = selector.charAt(0);
    if (isWhitespace(firstChar)) {
      sawWS = true;
      stripWhitespace(1);
    } else if (firstChar in simpleSelectors) {
      tokens.push({ type: simpleSelectors[firstChar] });
      sawWS = false;
      stripWhitespace(1);
    } else if (firstChar === ",") {
      if (tokens.length === 0) {
        throw new SyntaxError("empty sub-selector");
      }
      subselects2.push(tokens);
      tokens = [];
      sawWS = false;
      stripWhitespace(1);
    } else {
      if (sawWS) {
        if (tokens.length > 0) {
          tokens.push({ type: "descendant" });
        }
        sawWS = false;
      }
      if (firstChar === "*") {
        selector = selector.substr(1);
        tokens.push({ type: "universal" });
      } else if (firstChar in attribSelectors) {
        selector = selector.substr(1);
        tokens.push({
          type: "attribute",
          name: attribSelectors[firstChar][0],
          action: attribSelectors[firstChar][1],
          value: getName2(),
          ignoreCase: false
        });
      } else if (firstChar === "[") {
        selector = selector.substr(1);
        data2 = selector.match(re_attr);
        if (!data2) {
          throw new SyntaxError("Malformed attribute selector: " + selector);
        }
        selector = selector.substr(data2[0].length);
        name2 = unescapeCSS(data2[1]);
        if (!options2 || ("lowerCaseAttributeNames" in options2 ? options2.lowerCaseAttributeNames : !options2.xmlMode)) {
          name2 = name2.toLowerCase();
        }
        tokens.push({
          type: "attribute",
          name: name2,
          action: actionTypes[data2[2]],
          value: unescapeCSS(data2[4] || data2[5] || ""),
          ignoreCase: !!data2[6]
        });
      } else if (firstChar === ":") {
        if (selector.charAt(1) === ":") {
          selector = selector.substr(2);
          tokens.push({ type: "pseudo-element", name: getName2().toLowerCase() });
          continue;
        }
        selector = selector.substr(1);
        name2 = getName2().toLowerCase();
        data2 = null;
        if (selector.charAt(0) === "(") {
          if (name2 in unpackPseudos) {
            quot2 = selector.charAt(1);
            var quoted = quot2 in quotes;
            selector = selector.substr(quoted + 1);
            data2 = [];
            selector = parseSelector(data2, selector, options2);
            if (quoted) {
              if (selector.charAt(0) !== quot2) {
                throw new SyntaxError("unmatched quotes in :" + name2);
              } else {
                selector = selector.substr(1);
              }
            }
            if (selector.charAt(0) !== ")") {
              throw new SyntaxError("missing closing parenthesis in :" + name2 + " " + selector);
            }
            selector = selector.substr(1);
          } else {
            var pos = 1, counter = 1;
            for (; counter > 0 && pos < selector.length; pos++) {
              if (selector.charAt(pos) === "(" && !isEscaped(pos))
                counter++;
              else if (selector.charAt(pos) === ")" && !isEscaped(pos))
                counter--;
            }
            if (counter) {
              throw new SyntaxError("parenthesis not matched");
            }
            data2 = selector.substr(1, pos - 2);
            selector = selector.substr(pos);
            if (name2 in stripQuotesFromPseudos) {
              quot2 = data2.charAt(0);
              if (quot2 === data2.slice(-1) && quot2 in quotes) {
                data2 = data2.slice(1, -1);
              }
              data2 = unescapeCSS(data2);
            }
          }
        }
        tokens.push({ type: "pseudo", name: name2, data: data2 });
      } else if (re_name.test(selector)) {
        name2 = getName2();
        if (!options2 || ("lowerCaseTags" in options2 ? options2.lowerCaseTags : !options2.xmlMode)) {
          name2 = name2.toLowerCase();
        }
        tokens.push({ type: "tag", name: name2 });
      } else {
        if (tokens.length && tokens[tokens.length - 1].type === "descendant") {
          tokens.pop();
        }
        addToken(subselects2, tokens);
        return selector;
      }
    }
  }
  addToken(subselects2, tokens);
  return selector;
}
function addToken(subselects2, tokens) {
  if (subselects2.length > 0 && tokens.length === 0) {
    throw new SyntaxError("empty sub-selector");
  }
  subselects2.push(tokens);
}
var DomUtils$2 = domutilsExports, isTag$1 = DomUtils$2.isTag, getParent$1 = DomUtils$2.getParent, getChildren$2 = DomUtils$2.getChildren, getSiblings = DomUtils$2.getSiblings, getName = DomUtils$2.getName;
var general = {
  __proto__: null,
  attribute: attributes$1.compile,
  pseudo: pseudos_1.compile,
  //tags
  tag: function(next2, data2) {
    var name2 = data2.name;
    return function tag2(elem) {
      return getName(elem) === name2 && next2(elem);
    };
  },
  //traversal
  descendant: function(next2, rule, options2, context, acceptSelf) {
    return function descendant2(elem) {
      if (acceptSelf && next2(elem))
        return true;
      var found = false;
      while (!found && (elem = getParent$1(elem))) {
        found = next2(elem);
      }
      return found;
    };
  },
  parent: function(next2, data2, options2) {
    if (options2 && options2.strict)
      throw SyntaxError("Parent selector isn't part of CSS3");
    return function parent2(elem) {
      return getChildren$2(elem).some(test);
    };
    function test(elem) {
      return isTag$1(elem) && next2(elem);
    }
  },
  child: function(next2) {
    return function child2(elem) {
      var parent2 = getParent$1(elem);
      return !!parent2 && next2(parent2);
    };
  },
  sibling: function(next2) {
    return function sibling2(elem) {
      var siblings2 = getSiblings(elem);
      for (var i2 = 0; i2 < siblings2.length; i2++) {
        if (isTag$1(siblings2[i2])) {
          if (siblings2[i2] === elem)
            break;
          if (next2(siblings2[i2]))
            return true;
        }
      }
      return false;
    };
  },
  adjacent: function(next2) {
    return function adjacent2(elem) {
      var siblings2 = getSiblings(elem), lastElement;
      for (var i2 = 0; i2 < siblings2.length; i2++) {
        if (isTag$1(siblings2[i2])) {
          if (siblings2[i2] === elem)
            break;
          lastElement = siblings2[i2];
        }
      }
      return !!lastElement && next2(lastElement);
    };
  },
  universal: function(next2) {
    return next2;
  }
};
const universal = 50;
const tag = 30;
const attribute = 1;
const pseudo = 0;
const descendant = -1;
const child = -1;
const parent = -1;
const sibling = -1;
const adjacent = -1;
const require$$5 = {
  universal,
  tag,
  attribute,
  pseudo,
  descendant,
  child,
  parent,
  sibling,
  adjacent
};
var sort = sortByProcedure;
var procedure$1 = require$$5;
var attributes = {
  __proto__: null,
  exists: 10,
  equals: 8,
  not: 7,
  start: 6,
  end: 6,
  any: 5,
  hyphen: 4,
  element: 4
};
function sortByProcedure(arr) {
  var procs = arr.map(getProcedure);
  for (var i2 = 1; i2 < arr.length; i2++) {
    var procNew = procs[i2];
    if (procNew < 0)
      continue;
    for (var j2 = i2 - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
      var token = arr[j2 + 1];
      arr[j2 + 1] = arr[j2];
      arr[j2] = token;
      procs[j2 + 1] = procs[j2];
      procs[j2] = procNew;
    }
  }
}
function getProcedure(token) {
  var proc = procedure$1[token.type];
  if (proc === procedure$1.attribute) {
    proc = attributes[token.action];
    if (proc === attributes.equals && token.name === "id") {
      proc = 9;
    }
    if (token.ignoreCase) {
      proc >>= 1;
    }
  } else if (proc === procedure$1.pseudo) {
    if (!token.data) {
      proc = 3;
    } else if (token.name === "has" || token.name === "contains") {
      proc = 0;
    } else if (token.name === "matches" || token.name === "not") {
      proc = 0;
      for (var i2 = 0; i2 < token.data.length; i2++) {
        if (token.data[i2].length !== 1)
          continue;
        var cur = getProcedure(token.data[i2][0]);
        if (cur === 0) {
          proc = 0;
          break;
        }
        if (cur > proc)
          proc = cur;
      }
      if (token.data.length > 1 && proc > 0)
        proc -= 1;
    } else {
      proc = 1;
    }
  }
  return proc;
}
compile$2.exports = compile$1;
compileExports.compileUnsafe = compileUnsafe$1;
compileExports.compileToken = compileToken$1;
var parse$1 = cssWhat, DomUtils$1 = domutilsExports, isTag = DomUtils$1.isTag, Rules = general, sortRules = sort, BaseFuncs = boolbase, trueFunc2 = BaseFuncs.trueFunc, falseFunc$1 = BaseFuncs.falseFunc, procedure = require$$5;
function compile$1(selector, options2, context) {
  var next2 = compileUnsafe$1(selector, options2, context);
  return wrap(next2);
}
function wrap(next2) {
  return function base(elem) {
    return isTag(elem) && next2(elem);
  };
}
function compileUnsafe$1(selector, options2, context) {
  var token = parse$1(selector, options2);
  return compileToken$1(token, options2, context);
}
function includesScopePseudo(t) {
  return t.type === "pseudo" && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data2) {
    return data2.some(includesScopePseudo);
  }));
}
var DESCENDANT_TOKEN = { type: "descendant" }, SCOPE_TOKEN = { type: "pseudo", name: "scope" }, PLACEHOLDER_ELEMENT = {}, getParent = DomUtils$1.getParent;
function absolutize(token, context) {
  var hasContext = !!context && !!context.length && context.every(function(e) {
    return e === PLACEHOLDER_ELEMENT || !!getParent(e);
  });
  token.forEach(function(t) {
    if (t.length > 0 && isTraversal(t[0]) && t[0].type !== "descendant")
      ;
    else if (hasContext && !includesScopePseudo(t)) {
      t.unshift(DESCENDANT_TOKEN);
    } else {
      return;
    }
    t.unshift(SCOPE_TOKEN);
  });
}
function compileToken$1(token, options2, context) {
  token = token.filter(function(t) {
    return t.length > 0;
  });
  token.forEach(sortRules);
  var isArrayContext = Array.isArray(context);
  context = options2 && options2.context || context;
  if (context && !isArrayContext)
    context = [context];
  absolutize(token, context);
  return token.map(function(rules) {
    return compileRules(rules, options2, context, isArrayContext);
  }).reduce(reduceRules, falseFunc$1);
}
function isTraversal(t) {
  return procedure[t.type] < 0;
}
function compileRules(rules, options2, context, isArrayContext) {
  var acceptSelf = isArrayContext && rules[0].name === "scope" && rules[1].type === "descendant";
  return rules.reduce(function(func, rule, index2) {
    if (func === falseFunc$1)
      return func;
    return Rules[rule.type](func, rule, options2, context, acceptSelf && index2 === 1);
  }, options2 && options2.rootFunc || trueFunc2);
}
function reduceRules(a, b) {
  if (b === falseFunc$1 || a === trueFunc2) {
    return a;
  }
  if (a === falseFunc$1 || b === trueFunc2) {
    return b;
  }
  return function combine(elem) {
    return a(elem) || b(elem);
  };
}
var Pseudos$1 = pseudos_1, filters = Pseudos$1.filters, existsOne = DomUtils$1.existsOne, isTag = DomUtils$1.isTag, getChildren$1 = DomUtils$1.getChildren;
function containsTraversal(t) {
  return t.some(isTraversal);
}
filters.not = function(next2, token, options2, context) {
  var opts = {
    xmlMode: !!(options2 && options2.xmlMode),
    strict: !!(options2 && options2.strict)
  };
  if (opts.strict) {
    if (token.length > 1 || token.some(containsTraversal)) {
      throw new SyntaxError("complex selectors in :not aren't allowed in strict mode");
    }
  }
  var func = compileToken$1(token, opts, context);
  if (func === falseFunc$1)
    return next2;
  if (func === trueFunc2)
    return falseFunc$1;
  return function(elem) {
    return !func(elem) && next2(elem);
  };
};
filters.has = function(next2, token, options2) {
  var opts = {
    xmlMode: !!(options2 && options2.xmlMode),
    strict: !!(options2 && options2.strict)
  };
  var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;
  var func = compileToken$1(token, opts, context);
  if (func === falseFunc$1)
    return falseFunc$1;
  if (func === trueFunc2)
    return function(elem) {
      return getChildren$1(elem).some(isTag) && next2(elem);
    };
  func = wrap(func);
  if (context) {
    return function has2(elem) {
      return next2(elem) && (context[0] = elem, existsOne(func, getChildren$1(elem)));
    };
  }
  return function has2(elem) {
    return next2(elem) && existsOne(func, getChildren$1(elem));
  };
};
filters.matches = function(next2, token, options2, context) {
  var opts = {
    xmlMode: !!(options2 && options2.xmlMode),
    strict: !!(options2 && options2.strict),
    rootFunc: next2
  };
  return compileToken$1(token, opts, context);
};
var cssSelect = CSSselect;
var Pseudos = pseudos_1, DomUtils = domutilsExports, findOne = DomUtils.findOne, findAll = DomUtils.findAll, getChildren = DomUtils.getChildren, removeSubsets = DomUtils.removeSubsets, falseFunc2 = boolbase.falseFunc, compile = compileExports, compileUnsafe = compile.compileUnsafe, compileToken = compile.compileToken;
function getSelectorFunc(searchFunc) {
  return function select2(query, elems, options2) {
    if (typeof query !== "function")
      query = compileUnsafe(query, options2, elems);
    if (!Array.isArray(elems))
      elems = getChildren(elems);
    else
      elems = removeSubsets(elems);
    return searchFunc(query, elems);
  };
}
var selectAll = getSelectorFunc(function selectAll2(query, elems) {
  return query === falseFunc2 || !elems || elems.length === 0 ? [] : findAll(query, elems);
});
var selectOne = getSelectorFunc(function selectOne2(query, elems) {
  return query === falseFunc2 || !elems || elems.length === 0 ? null : findOne(query, elems);
});
function is(elem, query, options2) {
  return (typeof query === "function" ? query : compile(query, options2))(elem);
}
function CSSselect(query, elems, options2) {
  return selectAll(query, elems, options2);
}
CSSselect.compile = compile;
CSSselect.filters = Pseudos.filters;
CSSselect.pseudos = Pseudos.pseudos;
CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;
CSSselect.is = is;
CSSselect.parse = compile;
CSSselect.iterate = selectAll;
CSSselect._compileUnsafe = compileUnsafe;
CSSselect._compileToken = compileToken;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
var eq$2 = eq_1;
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var getNative$4 = _getNative, root$4 = _root;
var Map$4 = getNative$4(root$4, "Map");
var _Map = Map$4;
var getNative$3 = _getNative;
var nativeCreate$4 = getNative$3(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function hashGet$1(key) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$5.call(data2, key) ? data2[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function hashHas$1(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$4.call(data2, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$1) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$2(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$3(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack$3.prototype.clear = stackClear;
Stack$3.prototype["delete"] = stackDelete;
Stack$3.prototype.get = stackGet;
Stack$3.prototype.has = stackHas;
Stack$3.prototype.set = stackSet;
var _Stack = Stack$3;
var baseAssignValue = _baseAssignValue, eq$1 = eq_1;
function assignMergeValue$2(object, key, value) {
  if (value !== void 0 && !eq$1(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
var _assignMergeValue = assignMergeValue$2;
var _cloneBufferExports = {};
var _cloneBuffer = {
  get exports() {
    return _cloneBufferExports;
  },
  set exports(v) {
    _cloneBufferExports = v;
  }
};
(function(module, exports) {
  var root2 = _root;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBufferExports);
var root$3 = _root;
var Uint8Array$3 = root$3.Uint8Array;
var _Uint8Array = Uint8Array$3;
var Uint8Array$2 = _Uint8Array;
function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$1;
var cloneArrayBuffer = _cloneArrayBuffer;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
var overArg = _overArg;
var getPrototype$2 = overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
var baseCreate = _baseCreate, getPrototype$1 = _getPrototype, isPrototype = _isPrototype;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype$1(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var isArrayLike$1 = isArrayLike_1, isObjectLike$2 = isObjectLike_1;
function isArrayLikeObject$1(value) {
  return isObjectLike$2(value) && isArrayLike$1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var baseGetTag$1 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$1 = isObjectLike_1;
var objectTag$2 = "[object Object]";
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike$1(value) || baseGetTag$1(value) != objectTag$2) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;
function safeGet$2(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$2;
var copyObject = _copyObject, keysIn$1 = keysIn_1;
function toPlainObject$1(value) {
  return copyObject(value, keysIn$1(value));
}
var toPlainObject_1 = toPlainObject$1;
var assignMergeValue$1 = _assignMergeValue, cloneBuffer = _cloneBufferExports, cloneTypedArray = _cloneTypedArray, copyArray = _copyArray, initCloneObject = _initCloneObject, isArguments$2 = isArguments_1, isArray$d = isArray_1, isArrayLikeObject = isArrayLikeObject_1, isBuffer$1 = isBufferExports, isFunction = isFunction_1, isObject$3 = isObject_1, isPlainObject = isPlainObject_1, isTypedArray$1 = isTypedArray_1, safeGet$1 = _safeGet, toPlainObject = toPlainObject_1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet$1(object, key), srcValue = safeGet$1(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue$1(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$d(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$d(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$2(srcValue)) {
      newValue = objValue;
      if (isArguments$2(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$3(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue$1(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
var Stack$2 = _Stack, assignMergeValue = _assignMergeValue, baseFor = _baseFor, baseMergeDeep = _baseMergeDeep, isObject$2 = isObject_1, keysIn = keysIn_1, safeGet = _safeGet;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack$2());
    if (isObject$2(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var _baseMerge = baseMerge$1;
var baseMerge = _baseMerge, createAssigner = _createAssigner;
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge_1 = merge;
var hasRequired_static;
function require_static() {
  if (hasRequired_static)
    return _static;
  hasRequired_static = 1;
  (function(exports) {
    var serialize2 = domSerializerExports, defaultOptions2 = options.default, flattenOptions = options.flatten, select2 = cssSelect, parse3 = parseExports, _2 = {
      merge: merge_1,
      defaults: defaults_1
    };
    exports.load = function(content, options2, isDocument2) {
      var Cheerio2 = requireCheerio();
      options2 = _2.defaults(flattenOptions(options2 || {}), defaultOptions2);
      if (isDocument2 === void 0)
        isDocument2 = true;
      var root2 = parse3(content, options2, isDocument2);
      var initialize = function(selector, context, r, opts) {
        if (!(this instanceof initialize)) {
          return new initialize(selector, context, r, opts);
        }
        opts = _2.defaults(opts || {}, options2);
        return Cheerio2.call(this, selector, context, r || root2, opts);
      };
      initialize.prototype = Object.create(Cheerio2.prototype);
      initialize.prototype.constructor = initialize;
      initialize.fn = initialize.prototype;
      initialize.prototype._originalRoot = root2;
      _2.merge(initialize, exports);
      initialize._root = root2;
      initialize._options = options2;
      return initialize;
    };
    function render2(that, dom, options2) {
      if (!dom) {
        if (that._root && that._root.children) {
          dom = that._root.children;
        } else {
          return "";
        }
      } else if (typeof dom === "string") {
        dom = select2(dom, that._root, options2);
      }
      return serialize2(dom, options2);
    }
    exports.html = function(dom, options2) {
      if (Object.prototype.toString.call(dom) === "[object Object]" && !options2 && !("length" in dom) && !("type" in dom)) {
        options2 = dom;
        dom = void 0;
      }
      options2 = _2.defaults(flattenOptions(options2 || {}), this._options, defaultOptions2);
      return render2(this, dom, options2);
    };
    exports.xml = function(dom) {
      var options2 = _2.defaults({ xml: true }, this._options);
      return render2(this, dom, options2);
    };
    exports.text = function(elems) {
      if (!elems) {
        elems = this.root();
      }
      var ret = "", len = elems.length, elem;
      for (var i2 = 0; i2 < len; i2++) {
        elem = elems[i2];
        if (elem.type === "text")
          ret += elem.data;
        else if (elem.children && elem.type !== "comment" && elem.tagName !== "script" && elem.tagName !== "style") {
          ret += exports.text(elem.children);
        }
      }
      return ret;
    };
    exports.parseHTML = function(data2, context, keepScripts) {
      var parsed;
      if (!data2 || typeof data2 !== "string") {
        return null;
      }
      if (typeof context === "boolean") {
        keepScripts = context;
      }
      parsed = this.load(data2, defaultOptions2, false);
      if (!keepScripts) {
        parsed("script").remove();
      }
      return parsed.root()[0].children.slice();
    };
    exports.root = function() {
      return this(this._root);
    };
    exports.contains = function(container, contained) {
      if (contained === container) {
        return false;
      }
      while (contained && contained !== contained.parent) {
        contained = contained.parent;
        if (contained === container) {
          return true;
        }
      }
      return false;
    };
    exports.merge = function(arr1, arr2) {
      if (!(isArrayLike2(arr1) && isArrayLike2(arr2))) {
        return;
      }
      var newLength = arr1.length + arr2.length;
      var i2 = 0;
      while (i2 < arr2.length) {
        arr1[i2 + arr1.length] = arr2[i2];
        i2++;
      }
      arr1.length = newLength;
      return arr1;
    };
    function isArrayLike2(item) {
      if (Array.isArray(item)) {
        return true;
      }
      if (typeof item !== "object") {
        return false;
      }
      if (!item.hasOwnProperty("length")) {
        return false;
      }
      if (typeof item.length !== "number") {
        return false;
      }
      if (item.length < 0) {
        return false;
      }
      var i2 = 0;
      while (i2 < item.length) {
        if (!(i2 in item)) {
          return false;
        }
        i2++;
      }
      return true;
    }
  })(_static);
  return _static;
}
function arraySome$2(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome$1 = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
function mapToArray$1(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$3 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object, other, tag2, bitmask, customizer, equalFunc, stack) {
  switch (tag2) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$2(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
var _arrayPush = arrayPush$2;
var arrayPush$1 = _arrayPush, isArray$c = isArray_1;
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$c(object) ? result : arrayPush$1(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$3(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$3;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter$2 = _arrayFilter, stubArray = stubArray_1;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$2(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var _getSymbols = getSymbols$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$1 = keys_1;
function getAllKeys$1(object) {
  return baseGetAllKeys(object, keys$1, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$2 = _getNative, root$2 = _root;
var DataView$1 = getNative$2(root$2, "DataView");
var _DataView = DataView$1;
var getNative$1 = _getNative, root$1 = _root;
var Promise$2 = getNative$1(root$1, "Promise");
var _Promise = Promise$2;
var getNative = _getNative, root = _root;
var Set$2 = getNative(root, "Set");
var _Set = Set$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap);
var getTag$1 = baseGetTag;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap && getTag$1(new WeakMap()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$b = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$b(object), othIsArr = isArray$b(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}
var _baseIsEqual = baseIsEqual$2;
var Stack = _Stack, baseIsEqual$1 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data2 = matchData[index2];
    if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data2 = matchData[index2];
    var key = data2[0], objValue = object[key], srcValue = data2[1];
    if (noCustomizer && data2[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$1 = isObject_1;
function isStrictComparable$2(value) {
  return value === value && !isObject$1(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys = keys_1;
function getMatchData$1(object) {
  var result = keys(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
var isArray$a = isArray_1, isSymbol$2 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object) {
  if (isArray$a(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$3;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$1(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$2(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap$2;
var Symbol$2 = _Symbol, arrayMap$1 = _arrayMap, isArray$9 = isArray_1, isSymbol$1 = isSymbol_1;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$9(value)) {
    return arrayMap$1(value, baseToString$1) + "";
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$2(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$2;
var isArray$8 = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$1 = toString_1;
function castPath$4(value, object) {
  if (isArray$8(value)) {
    return value;
  }
  return isKey$2(value, object) ? [value] : stringToPath(toString$1(value));
}
var _castPath = castPath$4;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$5(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var _toKey = toKey$5;
var castPath$3 = _castPath, toKey$4 = _toKey;
function baseGet$3(object, path2) {
  path2 = castPath$3(path2, object);
  var index2 = 0, length = path2.length;
  while (object != null && index2 < length) {
    object = object[toKey$4(path2[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$1(object, path2, defaultValue) {
  var result = object == null ? void 0 : baseGet$2(object, path2);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
function baseHasIn$1(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$1;
var castPath$2 = _castPath, isArguments$1 = isArguments_1, isArray$7 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$3 = _toKey;
function hasPath$1(object, path2, hasFunc) {
  path2 = castPath$2(path2, object);
  var index2 = -1, length = path2.length, result = false;
  while (++index2 < length) {
    var key = toKey$3(path2[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$7(object) || isArguments$1(object));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$2(object, path2) {
  return object != null && hasPath(object, path2, baseHasIn);
}
var hasIn_1 = hasIn$2;
var baseIsEqual = _baseIsEqual, get = get_1, hasIn$1 = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path2, srcValue) {
  if (isKey$1(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$2(path2), srcValue);
  }
  return function(object) {
    var objValue = get(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function baseProperty$1(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$1 = _baseGet;
function basePropertyDeep$1(path2) {
  return function(object) {
    return baseGet$1(object, path2);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey$1 = _toKey;
function property$1(path2) {
  return isKey(path2) ? baseProperty(toKey$1(path2)) : basePropertyDeep(path2);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity = identity_1, isArray$6 = isArray_1, property = property_1;
function baseIteratee$5(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$6(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$5;
var baseEach$3 = _baseEach;
function baseSome$1(collection, predicate) {
  var result;
  baseEach$3(collection, function(value, index2, collection2) {
    result = predicate(value, index2, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome$1;
var arraySome = _arraySome, baseIteratee$4 = _baseIteratee, baseSome = _baseSome, isArray$5 = isArray_1, isIterateeCall = _isIterateeCall;
function some(collection, predicate, guard) {
  var func = isArray$5(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee$4(predicate));
}
var some_1 = some;
var hasRequiredAttributes;
function requireAttributes() {
  if (hasRequiredAttributes)
    return attributes$2;
  hasRequiredAttributes = 1;
  (function(exports) {
    var $2 = require_static(), utils$1 = utils, isTag2 = utils$1.isTag, domEach2 = utils$1.domEach, hasOwn2 = Object.prototype.hasOwnProperty, camelCase2 = utils$1.camelCase, cssCase2 = utils$1.cssCase, rspace2 = /\s+/, dataAttrPrefix2 = "data-", _2 = {
      forEach: forEach_1,
      extend: assignIn_1,
      some: some_1
    }, primitives2 = {
      null: null,
      true: true,
      false: false
    }, rboolean2 = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, rbrace2 = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;
    var getAttr2 = function(elem, name2) {
      if (!elem || !isTag2(elem))
        return;
      if (!elem.attribs) {
        elem.attribs = {};
      }
      if (!name2) {
        return elem.attribs;
      }
      if (hasOwn2.call(elem.attribs, name2)) {
        return rboolean2.test(name2) ? name2 : elem.attribs[name2];
      }
      if (elem.name === "option" && name2 === "value") {
        return $2.text(elem.children);
      }
      if (elem.name === "input" && (elem.attribs.type === "radio" || elem.attribs.type === "checkbox") && name2 === "value") {
        return "on";
      }
    };
    var setAttr2 = function(el2, name2, value) {
      if (value === null) {
        removeAttribute2(el2, name2);
      } else {
        el2.attribs[name2] = value + "";
      }
    };
    exports.attr = function(name2, value) {
      if (typeof name2 === "object" || value !== void 0) {
        if (typeof value === "function") {
          return domEach2(this, function(i2, el2) {
            setAttr2(el2, name2, value.call(el2, i2, el2.attribs[name2]));
          });
        }
        return domEach2(this, function(i2, el2) {
          if (!isTag2(el2))
            return;
          if (typeof name2 === "object") {
            _2.forEach(name2, function(objValue, objName) {
              setAttr2(el2, objName, objValue);
            });
          } else {
            setAttr2(el2, name2, value);
          }
        });
      }
      return getAttr2(this[0], name2);
    };
    var getProp2 = function(el2, name2) {
      if (!el2 || !isTag2(el2))
        return;
      return hasOwn2.call(el2, name2) ? el2[name2] : rboolean2.test(name2) ? getAttr2(el2, name2) !== void 0 : getAttr2(el2, name2);
    };
    var setProp2 = function(el2, name2, value) {
      el2[name2] = rboolean2.test(name2) ? !!value : value;
    };
    exports.prop = function(name2, value) {
      var i2 = 0, property2;
      if (typeof name2 === "string" && value === void 0) {
        switch (name2) {
          case "style":
            property2 = this.css();
            _2.forEach(property2, function(v, p) {
              property2[i2++] = p;
            });
            property2.length = i2;
            break;
          case "tagName":
          case "nodeName":
            property2 = this[0].name.toUpperCase();
            break;
          default:
            property2 = getProp2(this[0], name2);
        }
        return property2;
      }
      if (typeof name2 === "object" || value !== void 0) {
        if (typeof value === "function") {
          return domEach2(this, function(j2, el2) {
            setProp2(el2, name2, value.call(el2, j2, getProp2(el2, name2)));
          });
        }
        return domEach2(this, function(__, el2) {
          if (!isTag2(el2))
            return;
          if (typeof name2 === "object") {
            _2.forEach(name2, function(val2, key) {
              setProp2(el2, key, val2);
            });
          } else {
            setProp2(el2, name2, value);
          }
        });
      }
    };
    var setData2 = function(el2, name2, value) {
      if (!el2.data) {
        el2.data = {};
      }
      if (typeof name2 === "object")
        return _2.extend(el2.data, name2);
      if (typeof name2 === "string" && value !== void 0) {
        el2.data[name2] = value;
      }
    };
    var readData2 = function(el2, name2) {
      var readAll = arguments.length === 1;
      var domNames, domName, jsNames, jsName, value, idx, length;
      if (readAll) {
        domNames = Object.keys(el2.attribs).filter(function(attrName) {
          return attrName.slice(0, dataAttrPrefix2.length) === dataAttrPrefix2;
        });
        jsNames = domNames.map(function(_domName) {
          return camelCase2(_domName.slice(dataAttrPrefix2.length));
        });
      } else {
        domNames = [dataAttrPrefix2 + cssCase2(name2)];
        jsNames = [name2];
      }
      for (idx = 0, length = domNames.length; idx < length; ++idx) {
        domName = domNames[idx];
        jsName = jsNames[idx];
        if (hasOwn2.call(el2.attribs, domName)) {
          value = el2.attribs[domName];
          if (hasOwn2.call(primitives2, value)) {
            value = primitives2[value];
          } else if (value === String(Number(value))) {
            value = Number(value);
          } else if (rbrace2.test(value)) {
            try {
              value = JSON.parse(value);
            } catch (e) {
            }
          }
          el2.data[jsName] = value;
        }
      }
      return readAll ? el2.data : value;
    };
    exports.data = function(name2, value) {
      var elem = this[0];
      if (!elem || !isTag2(elem))
        return;
      if (!elem.data) {
        elem.data = {};
      }
      if (!name2) {
        return readData2(elem);
      }
      if (typeof name2 === "object" || value !== void 0) {
        domEach2(this, function(i2, el2) {
          setData2(el2, name2, value);
        });
        return this;
      } else if (hasOwn2.call(elem.data, name2)) {
        return elem.data[name2];
      }
      return readData2(elem, name2);
    };
    exports.val = function(value) {
      var querying2 = arguments.length === 0, element2 = this[0];
      if (!element2)
        return;
      switch (element2.name) {
        case "textarea":
          return this.text(value);
        case "input":
          switch (this.attr("type")) {
            case "radio":
              if (querying2) {
                return this.attr("value");
              } else {
                this.attr("value", value);
                return this;
              }
            default:
              return this.attr("value", value);
          }
        case "select":
          var option = this.find("option:selected"), returnValue;
          if (option === void 0)
            return void 0;
          if (!querying2) {
            if (!hasOwn2.call(this.attr(), "multiple") && typeof value == "object") {
              return this;
            }
            if (typeof value != "object") {
              value = [value];
            }
            this.find("option").removeAttr("selected");
            for (var i2 = 0; i2 < value.length; i2++) {
              this.find('option[value="' + value[i2] + '"]').attr("selected", "");
            }
            return this;
          }
          returnValue = option.attr("value");
          if (hasOwn2.call(this.attr(), "multiple")) {
            returnValue = [];
            domEach2(option, function(__, el2) {
              returnValue.push(getAttr2(el2, "value"));
            });
          }
          return returnValue;
        case "option":
          if (!querying2) {
            this.attr("value", value);
            return this;
          }
          return this.attr("value");
      }
    };
    var removeAttribute2 = function(elem, name2) {
      if (!elem.attribs || !hasOwn2.call(elem.attribs, name2))
        return;
      delete elem.attribs[name2];
    };
    exports.removeAttr = function(name2) {
      domEach2(this, function(i2, elem) {
        removeAttribute2(elem, name2);
      });
      return this;
    };
    exports.hasClass = function(className) {
      return _2.some(this, function(elem) {
        var attrs = elem.attribs, clazz = attrs && attrs["class"], idx = -1, end2;
        if (clazz && className.length) {
          while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
            end2 = idx + className.length;
            if ((idx === 0 || rspace2.test(clazz[idx - 1])) && (end2 === clazz.length || rspace2.test(clazz[end2]))) {
              return true;
            }
          }
        }
      });
    };
    exports.addClass = function(value) {
      if (typeof value === "function") {
        return domEach2(this, function(i3, el2) {
          var className2 = el2.attribs["class"] || "";
          exports.addClass.call([el2], value.call(el2, i3, className2));
        });
      }
      if (!value || typeof value !== "string")
        return this;
      var classNames = value.split(rspace2), numElements = this.length;
      for (var i2 = 0; i2 < numElements; i2++) {
        if (!isTag2(this[i2]))
          continue;
        var className = getAttr2(this[i2], "class"), numClasses, setClass;
        if (!className) {
          setAttr2(this[i2], "class", classNames.join(" ").trim());
        } else {
          setClass = " " + className + " ";
          numClasses = classNames.length;
          for (var j2 = 0; j2 < numClasses; j2++) {
            var appendClass = classNames[j2] + " ";
            if (setClass.indexOf(" " + appendClass) < 0)
              setClass += appendClass;
          }
          setAttr2(this[i2], "class", setClass.trim());
        }
      }
      return this;
    };
    var splitClass = function(className) {
      return className ? className.trim().split(rspace2) : [];
    };
    exports.removeClass = function(value) {
      var classes, numClasses, removeAll;
      if (typeof value === "function") {
        return domEach2(this, function(i2, el2) {
          exports.removeClass.call(
            [el2],
            value.call(el2, i2, el2.attribs["class"] || "")
          );
        });
      }
      classes = splitClass(value);
      numClasses = classes.length;
      removeAll = arguments.length === 0;
      return domEach2(this, function(i2, el2) {
        if (!isTag2(el2))
          return;
        if (removeAll) {
          el2.attribs.class = "";
        } else {
          var elClasses = splitClass(el2.attribs.class), index2, changed;
          for (var j2 = 0; j2 < numClasses; j2++) {
            index2 = elClasses.indexOf(classes[j2]);
            if (index2 >= 0) {
              elClasses.splice(index2, 1);
              changed = true;
              j2--;
            }
          }
          if (changed) {
            el2.attribs.class = elClasses.join(" ");
          }
        }
      });
    };
    exports.toggleClass = function(value, stateVal) {
      if (typeof value === "function") {
        return domEach2(this, function(i3, el2) {
          exports.toggleClass.call(
            [el2],
            value.call(el2, i3, el2.attribs["class"] || "", stateVal),
            stateVal
          );
        });
      }
      if (!value || typeof value !== "string")
        return this;
      var classNames = value.split(rspace2), numClasses = classNames.length, state = typeof stateVal === "boolean" ? stateVal ? 1 : -1 : 0, numElements = this.length, elementClasses, index2;
      for (var i2 = 0; i2 < numElements; i2++) {
        if (!isTag2(this[i2]))
          continue;
        elementClasses = splitClass(this[i2].attribs.class);
        for (var j2 = 0; j2 < numClasses; j2++) {
          index2 = elementClasses.indexOf(classNames[j2]);
          if (state >= 0 && index2 < 0) {
            elementClasses.push(classNames[j2]);
          } else if (state <= 0 && index2 >= 0) {
            elementClasses.splice(index2, 1);
          }
        }
        this[i2].attribs.class = elementClasses.join(" ");
      }
      return this;
    };
    exports.is = function(selector) {
      if (selector) {
        return this.filter(selector).length > 0;
      }
      return false;
    };
  })(attributes$2);
  return attributes$2;
}
var traversing = {};
var baseEach$2 = _baseEach;
function baseFilter$2(collection, predicate) {
  var result = [];
  baseEach$2(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var _baseFilter = baseFilter$2;
var FUNC_ERROR_TEXT = "Expected a function";
function negate$1(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_1 = negate$1;
var arrayFilter$1 = _arrayFilter, baseFilter$1 = _baseFilter, baseIteratee$3 = _baseIteratee, isArray$4 = isArray_1, negate = negate_1;
function reject(collection, predicate) {
  var func = isArray$4(collection) ? arrayFilter$1 : baseFilter$1;
  return func(collection, negate(baseIteratee$3(predicate)));
}
var reject_1 = reject;
var arrayFilter = _arrayFilter, baseFilter = _baseFilter, baseIteratee$2 = _baseIteratee, isArray$3 = isArray_1;
function filter(collection, predicate) {
  var func = isArray$3(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee$2(predicate));
}
var filter_1 = filter;
function arrayReduce$1(array, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array[index2], index2, array);
  }
  return accumulator;
}
var _arrayReduce = arrayReduce$1;
function baseReduce$1(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index2, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
  });
  return accumulator;
}
var _baseReduce = baseReduce$1;
var arrayReduce = _arrayReduce, baseEach$1 = _baseEach, baseIteratee$1 = _baseIteratee, baseReduce = _baseReduce, isArray$2 = isArray_1;
function reduce(collection, iteratee, accumulator) {
  var func = isArray$2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
  return func(collection, baseIteratee$1(iteratee), accumulator, initAccum, baseEach$1);
}
var reduce_1 = reduce;
(function(exports) {
  var select2 = cssSelect, utils$1 = utils, domEach2 = utils$1.domEach, uniqueSort2 = requireLib().DomUtils.uniqueSort, isTag2 = utils$1.isTag, _2 = {
    bind: bind_1,
    forEach: forEach_1,
    reject: reject_1,
    filter: filter_1,
    reduce: reduce_1
  };
  exports.find = function(selectorOrHaystack) {
    var elems = _2.reduce(this, function(memo, elem) {
      return memo.concat(_2.filter(elem.children, isTag2));
    }, []);
    var contains2 = this.constructor.contains;
    var haystack;
    if (selectorOrHaystack && typeof selectorOrHaystack !== "string") {
      if (selectorOrHaystack.cheerio) {
        haystack = selectorOrHaystack.get();
      } else {
        haystack = [selectorOrHaystack];
      }
      return this._make(haystack.filter(function(elem) {
        var idx, len;
        for (idx = 0, len = this.length; idx < len; ++idx) {
          if (contains2(this[idx], elem)) {
            return true;
          }
        }
      }, this));
    }
    var options2 = { __proto__: this.options, context: this.toArray() };
    return this._make(select2(selectorOrHaystack, elems, options2));
  };
  exports.parent = function(selector) {
    var set = [];
    domEach2(this, function(idx, elem) {
      var parentElem = elem.parent;
      if (parentElem && set.indexOf(parentElem) < 0) {
        set.push(parentElem);
      }
    });
    if (arguments.length) {
      set = exports.filter.call(set, selector, this);
    }
    return this._make(set);
  };
  exports.parents = function(selector) {
    var parentNodes = [];
    this.get().reverse().forEach(function(elem) {
      traverseParents(this, elem.parent, selector, Infinity).forEach(
        function(node2) {
          if (parentNodes.indexOf(node2) === -1) {
            parentNodes.push(node2);
          }
        }
      );
    }, this);
    return this._make(parentNodes);
  };
  exports.parentsUntil = function(selector, filter2) {
    var parentNodes = [], untilNode, untilNodes;
    if (typeof selector === "string") {
      untilNode = select2(selector, this.parents().toArray(), this.options)[0];
    } else if (selector && selector.cheerio) {
      untilNodes = selector.toArray();
    } else if (selector) {
      untilNode = selector;
    }
    this.toArray().reverse().forEach(function(elem) {
      while (elem = elem.parent) {
        if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
          if (isTag2(elem) && parentNodes.indexOf(elem) === -1) {
            parentNodes.push(elem);
          }
        } else {
          break;
        }
      }
    }, this);
    return this._make(filter2 ? select2(filter2, parentNodes, this.options) : parentNodes);
  };
  exports.closest = function(selector) {
    var set = [];
    if (!selector) {
      return this._make(set);
    }
    domEach2(this, function(idx, elem) {
      var closestElem = traverseParents(this, elem, selector, 1)[0];
      if (closestElem && set.indexOf(closestElem) < 0) {
        set.push(closestElem);
      }
    }.bind(this));
    return this._make(set);
  };
  exports.next = function(selector) {
    if (!this[0]) {
      return this;
    }
    var elems = [];
    _2.forEach(this, function(elem) {
      while (elem = elem.next) {
        if (isTag2(elem)) {
          elems.push(elem);
          return;
        }
      }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
  };
  exports.nextAll = function(selector) {
    if (!this[0]) {
      return this;
    }
    var elems = [];
    _2.forEach(this, function(elem) {
      while (elem = elem.next) {
        if (isTag2(elem) && elems.indexOf(elem) === -1) {
          elems.push(elem);
        }
      }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
  };
  exports.nextUntil = function(selector, filterSelector) {
    if (!this[0]) {
      return this;
    }
    var elems = [], untilNode, untilNodes;
    if (typeof selector === "string") {
      untilNode = select2(selector, this.nextAll().get(), this.options)[0];
    } else if (selector && selector.cheerio) {
      untilNodes = selector.get();
    } else if (selector) {
      untilNode = selector;
    }
    _2.forEach(this, function(elem) {
      while (elem = elem.next) {
        if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
          if (isTag2(elem) && elems.indexOf(elem) === -1) {
            elems.push(elem);
          }
        } else {
          break;
        }
      }
    });
    return filterSelector ? exports.filter.call(elems, filterSelector, this) : this._make(elems);
  };
  exports.prev = function(selector) {
    if (!this[0]) {
      return this;
    }
    var elems = [];
    _2.forEach(this, function(elem) {
      while (elem = elem.prev) {
        if (isTag2(elem)) {
          elems.push(elem);
          return;
        }
      }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
  };
  exports.prevAll = function(selector) {
    if (!this[0]) {
      return this;
    }
    var elems = [];
    _2.forEach(this, function(elem) {
      while (elem = elem.prev) {
        if (isTag2(elem) && elems.indexOf(elem) === -1) {
          elems.push(elem);
        }
      }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
  };
  exports.prevUntil = function(selector, filterSelector) {
    if (!this[0]) {
      return this;
    }
    var elems = [], untilNode, untilNodes;
    if (typeof selector === "string") {
      untilNode = select2(selector, this.prevAll().get(), this.options)[0];
    } else if (selector && selector.cheerio) {
      untilNodes = selector.get();
    } else if (selector) {
      untilNode = selector;
    }
    _2.forEach(this, function(elem) {
      while (elem = elem.prev) {
        if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
          if (isTag2(elem) && elems.indexOf(elem) === -1) {
            elems.push(elem);
          }
        } else {
          break;
        }
      }
    });
    return filterSelector ? exports.filter.call(elems, filterSelector, this) : this._make(elems);
  };
  exports.siblings = function(selector) {
    var parent2 = this.parent();
    var elems = _2.filter(
      parent2 ? parent2.children() : this.siblingsAndMe(),
      _2.bind(function(elem) {
        return isTag2(elem) && !this.is(elem);
      }, this)
    );
    if (selector !== void 0) {
      return exports.filter.call(elems, selector, this);
    } else {
      return this._make(elems);
    }
  };
  exports.children = function(selector) {
    var elems = _2.reduce(this, function(memo, elem) {
      return memo.concat(_2.filter(elem.children, isTag2));
    }, []);
    if (selector === void 0)
      return this._make(elems);
    return exports.filter.call(elems, selector, this);
  };
  exports.contents = function() {
    return this._make(_2.reduce(this, function(all, elem) {
      all.push.apply(all, elem.children);
      return all;
    }, []));
  };
  exports.each = function(fn) {
    var i2 = 0, len = this.length;
    while (i2 < len && fn.call(this[i2], i2, this[i2]) !== false)
      ++i2;
    return this;
  };
  exports.map = function(fn) {
    return this._make(_2.reduce(this, function(memo, el2, i2) {
      var val2 = fn.call(el2, i2, el2);
      return val2 == null ? memo : memo.concat(val2);
    }, []));
  };
  var makeFilterMethod = function(filterFn) {
    return function(match, container) {
      var testFn;
      container = container || this;
      if (typeof match === "string") {
        testFn = select2.compile(match, container.options);
      } else if (typeof match === "function") {
        testFn = function(el2, i2) {
          return match.call(el2, i2, el2);
        };
      } else if (match.cheerio) {
        testFn = match.is.bind(match);
      } else {
        testFn = function(el2) {
          return match === el2;
        };
      }
      return container._make(filterFn(this, testFn));
    };
  };
  exports.filter = makeFilterMethod(_2.filter);
  exports.not = makeFilterMethod(_2.reject);
  exports.has = function(selectorOrHaystack) {
    var that = this;
    return exports.filter.call(this, function() {
      return that._make(this).find(selectorOrHaystack).length > 0;
    });
  };
  exports.first = function() {
    return this.length > 1 ? this._make(this[0]) : this;
  };
  exports.last = function() {
    return this.length > 1 ? this._make(this[this.length - 1]) : this;
  };
  exports.eq = function(i2) {
    i2 = +i2;
    if (i2 === 0 && this.length <= 1)
      return this;
    if (i2 < 0)
      i2 = this.length + i2;
    return this[i2] ? this._make(this[i2]) : this._make([]);
  };
  exports.get = function(i2) {
    if (i2 == null) {
      return Array.prototype.slice.call(this);
    } else {
      return this[i2 < 0 ? this.length + i2 : i2];
    }
  };
  exports.index = function(selectorOrNeedle) {
    var $haystack, needle;
    if (arguments.length === 0) {
      $haystack = this.parent().children();
      needle = this[0];
    } else if (typeof selectorOrNeedle === "string") {
      $haystack = this._make(selectorOrNeedle);
      needle = this[0];
    } else {
      $haystack = this;
      needle = selectorOrNeedle.cheerio ? selectorOrNeedle[0] : selectorOrNeedle;
    }
    return $haystack.get().indexOf(needle);
  };
  exports.slice = function() {
    return this._make([].slice.apply(this, arguments));
  };
  function traverseParents(self2, elem, selector, limit) {
    var elems = [];
    while (elem && elems.length < limit) {
      if (!selector || exports.filter.call([elem], selector, self2).length) {
        elems.push(elem);
      }
      elem = elem.parent;
    }
    return elems;
  }
  exports.end = function() {
    return this.prevObject || this._make([]);
  };
  exports.add = function(other, context) {
    var selection = this._make(other, context);
    var contents2 = uniqueSort2(selection.get().concat(this.get()));
    for (var i2 = 0; i2 < contents2.length; ++i2) {
      selection[i2] = contents2[i2];
    }
    selection.length = contents2.length;
    return selection;
  };
  exports.addBack = function(selector) {
    return this.add(
      arguments.length ? this.prevObject.filter(selector) : this.prevObject
    );
  };
})(traversing);
var manipulation = {};
var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$1 = isArray_1;
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$1(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$1(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$1(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$1;
var baseFlatten = _baseFlatten;
function flatten$1(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}
var flatten_1 = flatten$1;
var hasRequiredManipulation;
function requireManipulation() {
  if (hasRequiredManipulation)
    return manipulation;
  hasRequiredManipulation = 1;
  (function(exports) {
    var parse3 = parseExports, $2 = require_static(), updateDOM = parse3.update, evaluate = parse3.evaluate, utils$1 = utils, domEach2 = utils$1.domEach, cloneDom2 = utils$1.cloneDom, isHtml2 = utils$1.isHtml, slice2 = Array.prototype.slice, _2 = {
      flatten: flatten_1,
      bind: bind_1,
      forEach: forEach_1
    };
    exports._makeDomArray = function makeDomArray(elem, clone2) {
      if (elem == null) {
        return [];
      } else if (elem.cheerio) {
        return clone2 ? cloneDom2(elem.get(), elem.options) : elem.get();
      } else if (Array.isArray(elem)) {
        return _2.flatten(elem.map(function(el2) {
          return this._makeDomArray(el2, clone2);
        }, this));
      } else if (typeof elem === "string") {
        return evaluate(elem, this.options, false);
      } else {
        return clone2 ? cloneDom2([elem]) : [elem];
      }
    };
    var _insert2 = function(concatenator) {
      return function() {
        var elems = slice2.call(arguments), lastIdx = this.length - 1;
        return domEach2(this, function(i2, el2) {
          var dom, domSrc;
          if (typeof elems[0] === "function") {
            domSrc = elems[0].call(el2, i2, $2.html(el2.children));
          } else {
            domSrc = elems;
          }
          dom = this._makeDomArray(domSrc, i2 < lastIdx);
          concatenator(dom, el2.children, el2);
        });
      };
    };
    var uniqueSplice2 = function(array, spliceIdx, spliceCount, newElems, parent2) {
      var spliceArgs = [spliceIdx, spliceCount].concat(newElems), prev2 = array[spliceIdx - 1] || null, next2 = array[spliceIdx] || null;
      var idx, len, prevIdx, node2, oldParent;
      for (idx = 0, len = newElems.length; idx < len; ++idx) {
        node2 = newElems[idx];
        oldParent = node2.parent || node2.root;
        prevIdx = oldParent && oldParent.children.indexOf(newElems[idx]);
        if (oldParent && prevIdx > -1) {
          oldParent.children.splice(prevIdx, 1);
          if (parent2 === oldParent && spliceIdx > prevIdx) {
            spliceArgs[0]--;
          }
        }
        node2.root = null;
        node2.parent = parent2;
        if (node2.prev) {
          node2.prev.next = node2.next || null;
        }
        if (node2.next) {
          node2.next.prev = node2.prev || null;
        }
        node2.prev = newElems[idx - 1] || prev2;
        node2.next = newElems[idx + 1] || next2;
      }
      if (prev2) {
        prev2.next = newElems[0];
      }
      if (next2) {
        next2.prev = newElems[newElems.length - 1];
      }
      return array.splice.apply(array, spliceArgs);
    };
    exports.appendTo = function(target2) {
      if (!target2.cheerio) {
        target2 = this.constructor.call(this.constructor, target2, null, this._originalRoot);
      }
      target2.append(this);
      return this;
    };
    exports.prependTo = function(target2) {
      if (!target2.cheerio) {
        target2 = this.constructor.call(this.constructor, target2, null, this._originalRoot);
      }
      target2.prepend(this);
      return this;
    };
    exports.append = _insert2(function(dom, children2, parent2) {
      uniqueSplice2(children2, children2.length, 0, dom, parent2);
    });
    exports.prepend = _insert2(function(dom, children2, parent2) {
      uniqueSplice2(children2, 0, 0, dom, parent2);
    });
    exports.wrap = function(wrapper) {
      var wrapperFn = typeof wrapper === "function" && wrapper, lastIdx = this.length - 1;
      _2.forEach(this, _2.bind(function(el2, i2) {
        var parent2 = el2.parent || el2.root, siblings2 = parent2.children, wrapperDom, elInsertLocation, j2, index2;
        if (!parent2) {
          return;
        }
        if (wrapperFn) {
          wrapper = wrapperFn.call(el2, i2);
        }
        if (typeof wrapper === "string" && !isHtml2(wrapper)) {
          wrapper = this.parents().last().find(wrapper).clone();
        }
        wrapperDom = this._makeDomArray(wrapper, i2 < lastIdx).slice(0, 1);
        elInsertLocation = wrapperDom[0];
        j2 = 0;
        while (elInsertLocation && elInsertLocation.children) {
          if (j2 >= elInsertLocation.children.length) {
            break;
          }
          if (elInsertLocation.children[j2].type === "tag") {
            elInsertLocation = elInsertLocation.children[j2];
            j2 = 0;
          } else {
            j2++;
          }
        }
        index2 = siblings2.indexOf(el2);
        updateDOM([el2], elInsertLocation);
        uniqueSplice2(siblings2, index2, 0, wrapperDom, parent2);
      }, this));
      return this;
    };
    exports.after = function() {
      var elems = slice2.call(arguments), lastIdx = this.length - 1;
      domEach2(this, function(i2, el2) {
        var parent2 = el2.parent || el2.root;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children, index2 = siblings2.indexOf(el2), domSrc, dom;
        if (index2 < 0)
          return;
        if (typeof elems[0] === "function") {
          domSrc = elems[0].call(el2, i2, $2.html(el2.children));
        } else {
          domSrc = elems;
        }
        dom = this._makeDomArray(domSrc, i2 < lastIdx);
        uniqueSplice2(siblings2, index2 + 1, 0, dom, parent2);
      });
      return this;
    };
    exports.insertAfter = function(target2) {
      var clones = [], self2 = this;
      if (typeof target2 === "string") {
        target2 = this.constructor.call(this.constructor, target2, null, this._originalRoot);
      }
      target2 = this._makeDomArray(target2);
      self2.remove();
      domEach2(target2, function(i2, el2) {
        var clonedSelf = self2._makeDomArray(self2.clone());
        var parent2 = el2.parent || el2.root;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children, index2 = siblings2.indexOf(el2);
        if (index2 < 0)
          return;
        uniqueSplice2(siblings2, index2 + 1, 0, clonedSelf, parent2);
        clones.push(clonedSelf);
      });
      return this.constructor.call(this.constructor, this._makeDomArray(clones));
    };
    exports.before = function() {
      var elems = slice2.call(arguments), lastIdx = this.length - 1;
      domEach2(this, function(i2, el2) {
        var parent2 = el2.parent || el2.root;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children, index2 = siblings2.indexOf(el2), domSrc, dom;
        if (index2 < 0)
          return;
        if (typeof elems[0] === "function") {
          domSrc = elems[0].call(el2, i2, $2.html(el2.children));
        } else {
          domSrc = elems;
        }
        dom = this._makeDomArray(domSrc, i2 < lastIdx);
        uniqueSplice2(siblings2, index2, 0, dom, parent2);
      });
      return this;
    };
    exports.insertBefore = function(target2) {
      var clones = [], self2 = this;
      if (typeof target2 === "string") {
        target2 = this.constructor.call(this.constructor, target2, null, this._originalRoot);
      }
      target2 = this._makeDomArray(target2);
      self2.remove();
      domEach2(target2, function(i2, el2) {
        var clonedSelf = self2._makeDomArray(self2.clone());
        var parent2 = el2.parent || el2.root;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children, index2 = siblings2.indexOf(el2);
        if (index2 < 0)
          return;
        uniqueSplice2(siblings2, index2, 0, clonedSelf, parent2);
        clones.push(clonedSelf);
      });
      return this.constructor.call(this.constructor, this._makeDomArray(clones));
    };
    exports.remove = function(selector) {
      var elems = this;
      if (selector)
        elems = elems.filter(selector);
      domEach2(elems, function(i2, el2) {
        var parent2 = el2.parent || el2.root;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children, index2 = siblings2.indexOf(el2);
        if (index2 < 0)
          return;
        siblings2.splice(index2, 1);
        if (el2.prev) {
          el2.prev.next = el2.next;
        }
        if (el2.next) {
          el2.next.prev = el2.prev;
        }
        el2.prev = el2.next = el2.parent = el2.root = null;
      });
      return this;
    };
    exports.replaceWith = function(content) {
      var self2 = this;
      domEach2(this, function(i2, el2) {
        var parent2 = el2.parent || el2.root;
        if (!parent2) {
          return;
        }
        var siblings2 = parent2.children, dom = self2._makeDomArray(typeof content === "function" ? content.call(el2, i2, el2) : content), index2;
        updateDOM(dom, null);
        index2 = siblings2.indexOf(el2);
        uniqueSplice2(siblings2, index2, 1, dom, parent2);
        el2.parent = el2.prev = el2.next = el2.root = null;
      });
      return this;
    };
    exports.empty = function() {
      domEach2(this, function(i2, el2) {
        _2.forEach(el2.children, function(child2) {
          child2.next = child2.prev = child2.parent = null;
        });
        el2.children.length = 0;
      });
      return this;
    };
    exports.html = function(str) {
      if (str === void 0) {
        if (!this[0] || !this[0].children)
          return null;
        return $2.html(this[0].children, this.options);
      }
      var opts = this.options;
      domEach2(this, function(i2, el2) {
        _2.forEach(el2.children, function(child2) {
          child2.next = child2.prev = child2.parent = null;
        });
        var content = str.cheerio ? str.clone().get() : evaluate("" + str, opts, false);
        updateDOM(content, el2);
      });
      return this;
    };
    exports.toString = function() {
      return $2.html(this, this.options);
    };
    exports.text = function(str) {
      if (str === void 0) {
        return $2.text(this);
      } else if (typeof str === "function") {
        return domEach2(this, function(i2, el2) {
          var $el = [el2];
          return exports.text.call($el, str.call(el2, i2, $2.text($el)));
        });
      }
      domEach2(this, function(i2, el2) {
        _2.forEach(el2.children, function(child2) {
          child2.next = child2.prev = child2.parent = null;
        });
        var elem = {
          data: "" + str,
          type: "text",
          parent: el2,
          prev: null,
          next: null,
          children: []
        };
        updateDOM(elem, el2);
      });
      return this;
    };
    exports.clone = function() {
      return this._make(cloneDom2(this.get(), this.options));
    };
  })(manipulation);
  return manipulation;
}
var css = {};
var assignValue = _assignValue, castPath$1 = _castPath, isIndex = _isIndex, isObject = isObject_1, toKey = _toKey;
function baseSet$1(object, path2, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path2 = castPath$1(path2, object);
  var index2 = -1, length = path2.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = toKey(path2[index2]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet$1;
var baseGet = _baseGet, baseSet = _baseSet, castPath = _castPath;
function basePickBy$1(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path2 = paths[index2], value = baseGet(object, path2);
    if (predicate(value, path2)) {
      baseSet(result, castPath(path2, object), value);
    }
  }
  return result;
}
var _basePickBy = basePickBy$1;
var basePickBy = _basePickBy, hasIn = hasIn_1;
function basePick$1(object, paths) {
  return basePickBy(object, paths, function(value, path2) {
    return hasIn(object, path2);
  });
}
var _basePick = basePick$1;
var flatten = flatten_1, overRest = _overRest, setToString = _setToString;
function flatRest$1(func) {
  return setToString(overRest(func, void 0, flatten), func + "");
}
var _flatRest = flatRest$1;
var basePick = _basePick, flatRest = _flatRest;
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});
var pick_1 = pick;
var domEach = utils.domEach, _$1 = {
  pick: pick_1
};
var toString = Object.prototype.toString;
css.css = function(prop2, val2) {
  if (arguments.length === 2 || // When `prop` is a "plain" object
  toString.call(prop2) === "[object Object]") {
    return domEach(this, function(idx, el2) {
      setCss(el2, prop2, val2, idx);
    });
  } else {
    return getCss(this[0], prop2);
  }
};
function setCss(el2, prop2, val2, idx) {
  if ("string" == typeof prop2) {
    var styles = getCss(el2);
    if (typeof val2 === "function") {
      val2 = val2.call(el2, idx, styles[prop2]);
    }
    if (val2 === "") {
      delete styles[prop2];
    } else if (val2 != null) {
      styles[prop2] = val2;
    }
    el2.attribs.style = stringify(styles);
  } else if ("object" == typeof prop2) {
    Object.keys(prop2).forEach(function(k) {
      setCss(el2, k, prop2[k]);
    });
  }
}
function getCss(el2, prop2) {
  var styles = parse2(el2.attribs.style);
  if (typeof prop2 === "string") {
    return styles[prop2];
  } else if (Array.isArray(prop2)) {
    return _$1.pick(styles, prop2);
  } else {
    return styles;
  }
}
function stringify(obj) {
  return Object.keys(obj || {}).reduce(function(str, prop2) {
    return str += (str ? " " : "") + prop2 + ": " + obj[prop2] + ";";
  }, "");
}
function parse2(styles) {
  styles = (styles || "").trim();
  if (!styles)
    return {};
  return styles.split(";").reduce(function(obj, str) {
    var n = str.indexOf(":");
    if (n < 1 || n === str.length - 1)
      return obj;
    obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();
    return obj;
  }, {});
}
var forms = {};
var baseEach = _baseEach, isArrayLike = isArrayLike_1;
function baseMap$1(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$1;
var arrayMap = _arrayMap, baseIteratee = _baseIteratee, baseMap = _baseMap, isArray = isArray_1;
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var map_1 = map;
var submittableSelector = "input,select,textarea,keygen", r20 = /%20/g, rCRLF = /\r?\n/g, _ = {
  map: map_1
};
forms.serialize = function() {
  var arr = this.serializeArray();
  var retArr = _.map(arr, function(data2) {
    return encodeURIComponent(data2.name) + "=" + encodeURIComponent(data2.value);
  });
  return retArr.join("&").replace(r20, "+");
};
forms.serializeArray = function() {
  var Cheerio2 = this.constructor;
  return this.map(function() {
    var elem = this;
    var $elem = Cheerio2(elem);
    if (elem.name === "form") {
      return $elem.find(submittableSelector).toArray();
    } else {
      return $elem.filter(submittableSelector).toArray();
    }
  }).filter(
    // Verify elements have a name (`attr.name`) and are not disabled (`:disabled`)
    '[name!=""]:not(:disabled):not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))'
    // Convert each of the elements to its value(s)
  ).map(function(i2, elem) {
    var $elem = Cheerio2(elem);
    var name2 = $elem.attr("name");
    var value = $elem.val();
    if (value == null) {
      value = "";
    }
    if (Array.isArray(value)) {
      return _.map(value, function(val2) {
        return { name: name2, value: val2.replace(rCRLF, "\r\n") };
      });
    } else {
      return { name: name2, value: value.replace(rCRLF, "\r\n") };
    }
  }).get();
};
var hasRequiredCheerio;
function requireCheerio() {
  if (hasRequiredCheerio)
    return cheerioExports;
  hasRequiredCheerio = 1;
  var parse3 = parseExports, defaultOptions2 = options.default, flattenOptions = options.flatten, isHtml2 = utils.isHtml, _2 = {
    extend: assignIn_1,
    bind: bind_1,
    forEach: forEach_1,
    defaults: defaults_1
  };
  var api = [
    requireAttributes(),
    traversing,
    requireManipulation(),
    css,
    forms
  ];
  var Cheerio2 = cheerio.exports = function(selector, context, root2, options2) {
    if (!(this instanceof Cheerio2))
      return new Cheerio2(selector, context, root2, options2);
    this.options = _2.defaults(flattenOptions(options2), this.options, defaultOptions2);
    if (!selector)
      return this;
    if (root2) {
      if (typeof root2 === "string")
        root2 = parse3(root2, this.options, false);
      this._root = Cheerio2.call(this, root2);
    }
    if (selector.cheerio)
      return selector;
    if (isNode2(selector))
      selector = [selector];
    if (Array.isArray(selector)) {
      _2.forEach(selector, _2.bind(function(elem, idx) {
        this[idx] = elem;
      }, this));
      this.length = selector.length;
      return this;
    }
    if (typeof selector === "string" && isHtml2(selector)) {
      return Cheerio2.call(this, parse3(selector, this.options, false).children);
    }
    if (!context) {
      context = this._root;
    } else if (typeof context === "string") {
      if (isHtml2(context)) {
        context = parse3(context, this.options, false);
        context = Cheerio2.call(this, context);
      } else {
        selector = [context, selector].join(" ");
        context = this._root;
      }
    } else if (!context.cheerio) {
      context = Cheerio2.call(this, context);
    }
    if (!context)
      return this;
    return context.find(selector);
  };
  _2.extend(Cheerio2, require_static());
  Cheerio2.prototype.cheerio = "[cheerio object]";
  Cheerio2.prototype.length = 0;
  Cheerio2.prototype.splice = Array.prototype.splice;
  Cheerio2.prototype._make = function(dom, context) {
    var cheerio2 = new this.constructor(dom, context, this._root, this.options);
    cheerio2.prevObject = this;
    return cheerio2;
  };
  Cheerio2.prototype.toArray = function() {
    return this.get();
  };
  api.forEach(function(mod) {
    _2.extend(Cheerio2.prototype, mod);
  });
  var isNode2 = function(obj) {
    return obj.name || obj.type === "text" || obj.type === "comment";
  };
  return cheerioExports;
}
const name = "cheerio";
const version = "1.0.0-rc.3";
const description = "Tiny, fast, and elegant implementation of core jQuery designed specifically for the server";
const author = "Matt Mueller <mattmuelle@gmail.com> (mat.io)";
const license = "MIT";
const keywords = [
  "htmlparser",
  "jquery",
  "selector",
  "scraper",
  "parser",
  "html"
];
const repository = {
  type: "git",
  url: "git://github.com/cheeriojs/cheerio.git"
};
const main = "./index.js";
const files = [
  "index.js",
  "lib"
];
const engines = {
  node: ">= 0.6"
};
const dependencies = {
  "css-select": "~1.2.0",
  "dom-serializer": "~0.1.1",
  entities: "~1.1.1",
  htmlparser2: "^3.9.1",
  lodash: "^4.15.0",
  parse5: "^3.0.1"
};
const devDependencies = {
  benchmark: "^2.1.0",
  coveralls: "^2.11.9",
  "expect.js": "~0.3.1",
  istanbul: "^0.4.3",
  jquery: "^3.0.0",
  jsdom: "^9.2.1",
  jshint: "^2.9.2",
  mocha: "^3.1.2",
  xyz: "~1.1.0"
};
const scripts = {
  test: "make test"
};
const require$$1 = {
  name,
  version,
  description,
  author,
  license,
  keywords,
  repository,
  main,
  files,
  engines,
  dependencies,
  devDependencies,
  scripts
};
(function(module, exports) {
  exports = module.exports = requireCheerio();
  exports.version = require$$1.version;
})(cheerio$1, cheerioExports$1);
(function(exports) {
  exports.__esModule = true;
  exports.parseByPath = exports.parseByString = exports.getRootFolder = exports.MarkType = void 0;
  var fs_1 = fs;
  var cheerio_1 = cheerioExports$1;
  (function(MarkType) {
    MarkType["folder"] = "folder";
    MarkType["site"] = "site";
  })(exports.MarkType || (exports.MarkType = {}));
  exports.getRootFolder = function(body) {
    var h3 = body.find("h3").first();
    var isChrome = typeof h3.attr("personal_toolbar_folder") === "string";
    if (isChrome) {
      return body.children("dl").first();
    }
    var isSafari = typeof h3.attr("folded") === "string";
    if (isSafari) {
      return body;
    }
    var isIE = typeof h3.attr("item_id") === "string";
    if (isIE) {
      return body.children("dl").first();
    }
    var isFireFox = h3.text() === "Mozilla Firefox";
    if (isFireFox) {
      return body.children("dl").first();
    }
    return body.children("dl").first();
  };
  exports.parseByString = function(content) {
    var $2 = cheerio_1.load(content, {
      decodeEntities: false
    });
    var body = $2("body");
    var root2 = [];
    var rdt = exports.getRootFolder(body).children("dt");
    var parseNode = function(node2) {
      var eq0 = node2.children().eq(0);
      var name2 = eq0.html() || "";
      var type = "site";
      var href = "";
      var icon2 = "";
      var children2 = [];
      switch (eq0[0].name) {
        case "h3":
          type = "folder";
          var dl = node2.children("dl").first();
          var dts = dl.children();
          var ls = dts.toArray().map(function(ele) {
            if (ele.name !== "dt")
              return null;
            return parseNode($2(ele));
          });
          children2 = ls.filter(function(item) {
            return item !== null;
          });
        case "a":
          href = eq0.attr("href") || "";
          icon2 = eq0.attr("icon") || "";
      }
      return {
        name: name2,
        type,
        href,
        icon: icon2,
        children: children2
      };
    };
    rdt.each(function(_2, item) {
      var node2 = $2(item);
      var child2 = parseNode(node2);
      root2.push(child2);
    });
    return root2;
  };
  exports.parseByPath = function(path2) {
    var content = fs_1.readFileSync(path2, "utf-8");
    return exports.parseByString(content);
  };
  exports["default"] = { parseByPath: exports.parseByPath, parseByString: exports.parseByString };
})(lib$2);
const USER_DATA_PATH = electron.app.getPath("userData");
const STORAGE_PATH = USER_DATA_PATH + "/storage/database";
const CleePIXMain = {
  Windows: {},
  storage: {},
  configTemp: {},
  config: new Store({ encryptionKey: "ymzkrk33" }),
  run: function() {
    if (this.config.size === 0) {
      this.config.store = {
        instance: [{
          label: "default",
          id: 1,
          path: STORAGE_PATH + `/ite_${randomString()}.db`
        }, {
          label: "main",
          id: 2,
          path: STORAGE_PATH + `/ite_${randomString()}.db`
        }],
        cache: { currentInstanceId: 1, tagTreeDomStrings: null }
      };
    }
    this.configTemp = this.config.store;
    this.config.store.instance.forEach((db) => {
      this.initializeDB(db);
    });
    electron.app.whenReady().then(() => {
      this.Windows.main = this.createWindowInstance();
      electron.app.on("activate", () => {
        if (electron.BrowserWindow.getAllWindows().length === 0)
          CleePIXMain.createWindowInstance();
      });
    });
    electron.ipcMain.handle("get-config", () => {
      return this.config.store;
    });
    electron.ipcMain.handle("config-update", (_2, config) => {
      this.configTemp = config;
      this.config.store = this.configTemp;
      return this.config.store;
    });
    electron.ipcMain.handle("bookmark-file", () => {
      const bookmarks = lib$2.parseByPath("./bookmarks_2023_04_03_vivaldi.html");
      return bookmarks;
    });
    electron.ipcMain.on("window-close", () => {
      Object.values(this.storage).forEach((value) => {
        value.db?.close();
      });
      electron.app.quit();
    });
    electron.ipcMain.on("window-maximize", () => {
      if (this.Windows.main?.isMaximized()) {
        this.Windows.main?.unmaximize();
      } else
        this.Windows.main?.maximize();
    });
    electron.ipcMain.on("window-minize", () => {
      this.Windows.main?.minimize();
    });
    electron.app.on("window-all-closed", () => {
      if (process.platform !== "darwin") {
        electron.app.quit();
      }
    });
    electron.ipcMain.on("ite-name-update", (_2, ite) => {
      this.config.store.instance.forEach((i2, index2) => {
        if (i2.id == ite.id) {
          this.configTemp.instance[index2].label = ite.name;
          this.config.store = this.configTemp;
          return;
        }
      });
    });
    electron.ipcMain.handle("set-tag-tree-cache", (_2, domString) => {
      this.configTemp.cache.tagTreeDomStrings = domString;
      this.config.store = this.configTemp;
    });
    electron.ipcMain.handle("add-instance", () => {
      this.configTemp.instance = this.configTemp.instance?.sort((a, b) => {
        return a.id < b.id ? -1 : 1;
      });
      const newId = this.configTemp.instance.slice(-1)[0].id + 1;
      const newInstance = { label: "new instance", id: newId, path: STORAGE_PATH + `/ite_${randomString()}.db` };
      this.configTemp.instance?.push(newInstance);
      this.initializeDB(newInstance);
      this.config.store = this.configTemp;
      this.Windows.main?.webContents.send("instance-update", this.config.store.instance);
      return newInstance;
    });
    electron.ipcMain.on("remove-instance", (_2, id) => {
      let instancePath = "";
      let instanceId = 0;
      let indexTemp = 0;
      this.configTemp.instance?.forEach((ite, index2) => {
        if (ite.id === id) {
          indexTemp = index2;
          instanceId = ite.id;
          instancePath = ite.path;
          return;
        }
      });
      this.storage[instanceId].db?.close();
      fs.unlink(instancePath, (e) => {
        console.log(e);
        if (e === null) {
          delete this.storage[instanceId];
          this.configTemp.instance?.splice(indexTemp, 1);
          this.config.store = this.configTemp;
          this.Windows.main?.webContents.send("ite-change", this.config.store);
        }
      });
    });
    electron.ipcMain.handle("get-add-tag-list", async (_2, query) => {
      return this.storage[query.id].db?.prepare(
        `SELECT * FROM tags WHERE name LIKE ?`
      ).all(query.keyword + "%");
    });
    electron.ipcMain.handle("add-tag-suggest", (_2, query) => {
      return this.storage[query.id].db?.prepare(
        `SELECT * FROM tags WHERE name LIKE ?`
      ).get(query.value + "%");
    });
    electron.ipcMain.handle("add-tag", (_2, query) => {
      let res = null;
      let child_id = 0;
      try {
        res = this.storage[query.instanceId].db?.prepare(
          `SELECT * FROM tags WHERE name = ?`
        ).get(query.name);
        child_id = res === void 0 ? 0 : res.id;
        if (res === void 0) {
          res = this.storage[query.instanceId].db.prepare(
            `INSERT INTO tags (name) VALUES ( ? )`
          ).run(query.name);
          child_id = res.lastInsertRowid;
        }
        this.storage[query.instanceId].db.prepare(
          `INSERT INTO tags_structure (parent_id, child_id) VALUES ( ?, ? )`
        ).run(query.parentTagId !== null ? query.parentTagId : 0, child_id);
        return res;
      } catch (e) {
        console.log(e);
        return null;
      }
    });
    electron.ipcMain.handle("update-tag-name", (_2, query) => {
      let res = null;
      try {
        res = this.storage[query.instanceId].db?.prepare(
          `SELECT * FROM tags WHERE name = ?`
        ).get(query.name);
        if (res === void 0) {
          res = this.storage[query.instanceId].db.prepare(
            `UPDATE tags SET name = ? WHERE id = ?`
          ).run(query.name, query.tagId);
        }
        return res;
      } catch (e) {
        console.log(e);
        return null;
      }
    });
    electron.ipcMain.handle("get-tag-tree", async (_2, id) => {
      let res, editres = [];
      try {
        res = this.storage[id].db?.prepare(`SELECT * FROM tags`).all();
        const isParentQuery = this.storage[id].db?.prepare(`SELECT * FROM tags_structure WHERE parent_id = ?`);
        const isHit = isParentQuery?.all(0);
        res.forEach((tag2) => {
          isHit.forEach((hit) => {
            if (tag2.id === hit.child_id) {
              editres.push(tag2);
            }
          });
        });
      } catch (e) {
        res = null;
      }
      return editres;
    });
    electron.ipcMain.handle("get-sub-tags", (_2, res) => {
      const tagsStructure = this.storage[res.instanceId].db?.prepare(`SELECT * FROM tags_structure WHERE parent_id = ?`);
      const tags2 = this.storage[res.instanceId].db?.prepare(`SELECT * FROM tags WHERE id = ?`);
      const tagsRes = [];
      tagsStructure?.all(res.parentId).forEach((structure) => {
        tagsRes.push(tags2?.get(structure.child_id));
      });
      return tagsRes;
    });
    electron.ipcMain.handle("update-tag-structure", (_2, structure) => {
      try {
        const delRes = this.storage[structure.instanceId].db.prepare(
          `DELETE FROM tags_structure WHERE parent_id = ? AND child_id = ?`
        ).run(structure.delete.parentId, structure.delete.childId);
        const setRes = this.storage[structure.instanceId].db.prepare(
          `INSERT INTO tags_structure (parent_id, child_id) VALUES ( ?, ? )`
        ).run(structure.set.parentId, structure.set.childId);
        if (delRes.changes === 1 && setRes.changes === 1) {
          return true;
        } else
          return false;
      } catch (e) {
        console.log(e);
        return false;
      }
    });
    electron.ipcMain.handle("get-http-request", async (_2, url) => {
      const response = await fetch(url, {
        method: "GET",
        mode: "no-cors",
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36"
        }
      });
      if (response && response.ok) {
        const $2 = load(await response.text());
        let description2 = $2(`meta[property="og:description"]`).attr("content");
        if (description2 === void 0)
          description2 = $2(`meta[name="description"]`).attr("content");
        return {
          title: $2("title").text(),
          description: description2,
          image: $2(`meta[property='og:image']`).attr("content")
        };
      } else
        return null;
    });
  },
  initializeDB: function(storage) {
    this.storage[storage.id] = {};
    this.storage[storage.id].stmt = {};
    if (fs.existsSync(STORAGE_PATH) && fs.existsSync(storage.path)) {
      this.storage[storage.id].db = new Database(storage.path);
      return;
    }
    const initDB = () => {
      this.storage[storage.id].db = new Database(storage.path);
      this.storage[storage.id].db.prepare(
        `CREATE TABLE "bookmarks" (
          "id"	INTEGER NOT NULL UNIQUE,
          "title"	TEXT NOT NULL, "description"	TEXT,
          "data"	TEXT NOT NULL, "thunb"	TEXT NOT NULL,
          "register_time"	TEXT NOT NULL DEFAULT '2023-03-05 06:00:00',
          "update_time"	TEXT NOT NULL DEFAULT '2023-03-05 06:00:00',
          PRIMARY KEY("id" AUTOINCREMENT)
        )`
      ).run();
      this.storage[storage.id].db.prepare(
        `CREATE TABLE "tags" (
          "id"	INTEGER UNIQUE, "name"  TEXT NOT NULL UNIQUE,
          "font_color"	TEXT NOT NULL DEFAULT '#c6c4be',
          "bg_color"	TEXT NOT NULL DEFAULT 'gray',
          "register_time"	TEXT NOT NULL DEFAULT '2023-03-05 06:00:00',
          "update_time"	TEXT NOT NULL DEFAULT '2023-03-05 06:00:00',
          PRIMARY KEY("id" AUTOINCREMENT)
        )`
      ).run();
      this.storage[storage.id].db.prepare(
        `CREATE TABLE "tags_bookmarks" (
          "tags_id"	INTEGER NOT NULL, "bookmark_id"	INTEGER NOT NULL,
          FOREIGN KEY("bookmark_id") REFERENCES "bookmarks"("id") on delete cascade,
          FOREIGN KEY("tags_id") REFERENCES "tags"("id") on delete cascade,
          PRIMARY KEY("tags_id","bookmark_id")
        )`
      ).run();
      this.storage[storage.id].db.prepare(
        `CREATE TABLE "tags_structure" (
          "parent_id"	INTEGER NOT NULL, "child_id"	INTEGER NOT NULL,
          FOREIGN KEY("child_id") REFERENCES "tags"("id") ON DELETE CASCADE,
          PRIMARY KEY("parent_id", "child_id")
        )`
      ).run();
      [
        "ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°",
        "ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èª",
        "ãƒ—ãƒ­ãƒŸã‚¹",
        "ãƒ—ãƒ­ãƒ‘ãƒ³ã‚¬ã‚¹",
        "engineer",
        "ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢",
        "Programming",
        "promise",
        "glass",
        "ã‚°ãƒ©ã‚¹",
        "Python",
        "C/C++",
        "JavaScript",
        "TypeScript",
        "PHP",
        "HTML",
        "SCSS",
        "Rust",
        "ãƒ•ãƒªãƒ¼ãƒ©ãƒ³ã‚¹",
        "ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯",
        "ã‚¤ãƒ³ãƒ•ãƒ©",
        "ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰",
        "ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰"
      ].forEach((word) => {
        this.storage[storage.id].db.prepare(
          `INSERT INTO tags (name) VALUES ( ? )`
        ).run(word);
      });
      for (let i2 = 1; i2 <= 10; i2++) {
        this.storage[storage.id].db.prepare(
          `INSERT INTO tags_structure ( parent_id, child_id ) VALUES ( ?, ? )`
        ).run(0, i2);
      }
      for (let i2 = 11; i2 <= 18; i2++) {
        this.storage[storage.id].db.prepare(
          `INSERT INTO tags_structure ( parent_id, child_id ) VALUES ( ?, ? )`
        ).run(2, i2);
      }
      for (let i2 = 19; i2 <= 23; i2++) {
        this.storage[storage.id].db.prepare(
          `INSERT INTO tags_structure ( parent_id, child_id ) VALUES ( ?, ? )`
        ).run(6, i2);
      }
    };
    if (!fs.existsSync(STORAGE_PATH)) {
      fs.mkdir(STORAGE_PATH, (err) => {
        if (err === null) {
          initDB();
        }
      });
    } else
      initDB();
  },
  createWindowInstance: function() {
    const window2 = new electron.BrowserWindow({
      width: 1360,
      height: 830,
      show: false,
      frame: false,
      autoHideMenuBar: true,
      backgroundColor: "#0f0f0f",
      ...process.platform === "linux" ? { icon } : {},
      webPreferences: {
        preload: path.join(__dirname, "../preload/index.js"),
        sandbox: false,
        webviewTag: true
      }
    });
    window2.on("ready-to-show", () => {
      window2.show();
    });
    window2.webContents.setWindowOpenHandler((details) => {
      electron.shell.openExternal(details.url);
      return { action: "deny" };
    });
    if (!electron.app.isPackaged && process.env["ELECTRON_RENDERER_URL"]) {
      window2.loadURL(process.env["ELECTRON_RENDERER_URL"]);
    } else {
      window2.loadFile(path.join(__dirname, "../renderer/index.html"));
    }
    return window2;
  }
};
function randomString(len = 10) {
  let str = "0123456789abcdefghijklmnopqrstuvwxyz";
  let strLen = str.length;
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += str[Math.floor(Math.random() * strLen)];
  }
  return result;
}
CleePIXMain.run();
